diff --git a/.github/workflows/appimage.yml b/.github/workflows/appimage.yml
index 9ad9a6cbd..fae43ed25 100644
--- a/.github/workflows/appimage.yml
+++ b/.github/workflows/appimage.yml
@@ -11,7 +11,7 @@ on:
       - dev
   workflow_dispatch:
 env:
-  publish_pre_dev_labels: '[]'
+  publish_pre_dev_labels: '["Beep6581:metadata-exiv2"]'
 jobs:
   build:
     runs-on: ubuntu-20.04
@@ -30,7 +30,21 @@ jobs:
           echo "Running apt update."
           sudo apt update
           echo "Installing dependencies with apt."
-          DEBIAN_FRONTEND=noninteractive sudo apt install -y cmake libgtk-3-dev libgtkmm-3.0-dev liblensfun-dev librsvg2-dev liblcms2-dev libfftw3-dev libiptcdata0-dev libtiff5-dev libcanberra-gtk3-dev liblensfun-bin
+          DEBIAN_FRONTEND=noninteractive sudo apt install -y cmake libgtk-3-dev libgtkmm-3.0-dev liblensfun-dev librsvg2-dev liblcms2-dev libfftw3-dev libiptcdata0-dev libtiff5-dev libcanberra-gtk3-dev liblensfun-bin libexpat1-dev libbrotli-dev zlib1g-dev libinih-dev
+
+      - name: Install Exiv2
+        run: |
+          EXIV2_VERSION='v0.28.0'
+          echo "Cloning Exiv2 $EXIV2_VERSION."
+          git clone --depth 1 --branch "$EXIV2_VERSION" https://github.com/Exiv2/exiv2.git ext/exiv2
+
+          echo "Configuring build."
+          mkdir ext/exiv2/build
+          cd ext/exiv2/build
+          cmake -DCMAKE_BUILD_TYPE=Release -DEXIV2_ENABLE_BMFF=ON ..
+
+          echo "Building and installing."
+          sudo make -j$(nproc) install
 
       - name: Configure build
         run: |
@@ -113,6 +127,9 @@ jobs:
       - name: Package AppImage
         working-directory: ./build
         run: |
+          echo "LD_LIBRARY_PATH is '$LD_LIBRARY_PATH'. Adding /usr/local/lib."
+          export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:/usr/local/lib"
+
           echo "Creating artifact name."
           if [ '${{github.ref_type}}' == 'tag' ]; then
             ARTIFACT_NAME="RawTherapee_${REF_NAME_FILTERED}_${{matrix.build_type}}"
diff --git a/.github/workflows/codeql.yml b/.github/workflows/codeql.yml
index b90d30e27..d3b3244b4 100644
--- a/.github/workflows/codeql.yml
+++ b/.github/workflows/codeql.yml
@@ -35,7 +35,7 @@ jobs:
           echo "Running apt update."
           sudo apt update
           echo "Installing dependencies with apt."
-          DEBIAN_FRONTEND=noninteractive sudo apt install -y cmake libgtk-3-dev libgtkmm-3.0-dev liblensfun-dev librsvg2-dev liblcms2-dev libfftw3-dev libiptcdata0-dev libtiff5-dev libcanberra-gtk3-dev liblensfun-bin
+          DEBIAN_FRONTEND=noninteractive sudo apt install -y cmake libgtk-3-dev libgtkmm-3.0-dev liblensfun-dev librsvg2-dev liblcms2-dev libfftw3-dev libiptcdata0-dev libtiff5-dev libcanberra-gtk3-dev liblensfun-bin libexiv2-dev
 
       - name: Configure build
         run: |
diff --git a/.github/workflows/macos.yml b/.github/workflows/macos.yml
index 3348d48b9..0deac5cec 100644
--- a/.github/workflows/macos.yml
+++ b/.github/workflows/macos.yml
@@ -21,7 +21,7 @@ jobs:
            mkdir build
            date +%s > build/stamp
            brew uninstall --ignore-dependencies libtiff
-           brew install libtiff gtk+3 gtkmm3 gtk-mac-integration adwaita-icon-theme libsigc++@2 little-cms2 libiptcdata fftw lensfun expat pkgconfig llvm shared-mime-info | tee -a depslog
+           brew install libtiff gtk+3 gtkmm3 gtk-mac-integration adwaita-icon-theme libsigc++@2 little-cms2 libiptcdata fftw lensfun expat pkgconfig llvm shared-mime-info exiv2 | tee -a depslog
            date -u
            echo "----====Pourage====----"
            cat depslog | grep Pouring
diff --git a/.github/workflows/windows.yml b/.github/workflows/windows.yml
index 4ab10212c..81450a61a 100644
--- a/.github/workflows/windows.yml
+++ b/.github/workflows/windows.yml
@@ -11,7 +11,7 @@ on:
       - dev
   workflow_dispatch:
 env:
-  publish_pre_dev_labels: '[]'
+  publish_pre_dev_labels: '["Beep6581:metadata-exiv2"]'
 jobs:
   build:
     runs-on: windows-2022
@@ -47,6 +47,7 @@ jobs:
             mingw-w64-x86_64-fftw
             mingw-w64-x86_64-lensfun
             mingw-w64-x86_64-libiptcdata
+            mingw-w64-x86_64-exiv2
 
       - name: Configure build
         run: |
@@ -118,9 +119,12 @@ jobs:
             "libcairo-2.dll" \
             "libcairo-gobject-2.dll" \
             "libcairomm-1.0-1.dll" \
+            "libcrypto-3-x64.dll" \
+            "libcurl-4.dll" \
             "libdatrie-1.dll" \
             "libdeflate.dll" \
             "libepoxy-0.dll" \
+            "libexiv2.dll" \
             "libexpat-1.dll" \
             libffi-*.dll \
             "libfftw3f-3.dll" \
@@ -144,6 +148,7 @@ jobs:
             "libgtkmm-3.0-1.dll" \
             "libharfbuzz-0.dll" \
             "libiconv-2.dll" \
+            "libidn2-0.dll" \
             "libintl-8.dll" \
             "libjbig-0.dll" \
             "libjpeg-8.dll" \
@@ -151,6 +156,7 @@ jobs:
             "liblensfun.dll" \
             "libLerc.dll" \
             "liblzma-5.dll" \
+            "libnghttp2-14.dll" \
             "libpango-1.0-0.dll" \
             "libpangocairo-1.0-0.dll" \
             "libpangoft2-1.0-0.dll" \
@@ -159,14 +165,18 @@ jobs:
             "libpcre2-8-0.dll" \
             "libpixman-1-0.dll" \
             "libpng16-16.dll" \
+            "libpsl-5.dll" \
             "librsvg-2-2.dll" \
             "libsharpyuv-0.dll" \
             "libsigc-2.0-0.dll" \
+            "libssh2-1.dll" \
+            "libssl-3-x64.dll" \
             "libstdc++-6.dll" \
             "libsystre-0.dll" \
             "libthai-0.dll" \
             "libtiff-6.dll" \
             "libtre-5.dll" \
+            "libunistring-5.dll" \
             "libwebp-7.dll" \
             "libwinpthread-1.dll" \
             "libxml2-2.dll" \
diff --git a/.gitignore b/.gitignore
index fc65c877c..7774f1f3a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -23,7 +23,6 @@ Release
 
 rtdata/rawtherapee.desktop
 rtengine/librtengine.a
-rtexif/librtexif.a
 rtgui/config.h
 rtgui/version.h
 rtgui/rawtherapee
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 92888424c..0e33d28cf 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -46,7 +46,7 @@ endif()
 
 # Warning for GCC vectorization issues, which causes problems #5749 and #6384:
 if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" AND CMAKE_CXX_COMPILER_VERSION VERSION_GREATER "10.0" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS "10.2")
-    message(STATUS "WARNING: gcc ${CMAKE_CXX_COMPILER_VERSION} is known to miscompile RawTherapee when using -ftree-loop-vectorize, forcing the option to be off")    
+    message(STATUS "WARNING: gcc ${CMAKE_CXX_COMPILER_VERSION} is known to miscompile RawTherapee when using -ftree-loop-vectorize, forcing the option to be off")
     set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fno-tree-loop-vectorize")
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fno-tree-loop-vectorize")
 elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" AND CMAKE_CXX_COMPILER_VERSION VERSION_GREATER_EQUAL "11.0")
@@ -497,6 +497,31 @@ pkg_check_modules(SIGC REQUIRED sigc++-2.0>=2.3.1)
 pkg_check_modules(LENSFUN REQUIRED lensfun>=0.2)
 pkg_check_modules(RSVG REQUIRED librsvg-2.0>=2.40)
 
+# Require exiv2 >= 0.24 to make sure everything we need is available
+#find_package(Exiv2 0.24 REQUIRED)
+pkg_check_modules(EXIV2 REQUIRED exiv2>=0.24)
+#include_directories(SYSTEM ${Exiv2_INCLUDE_DIRS})
+#list(APPEND LIBS ${EXIV2_LIBRARIES})
+add_definitions(${EXIV2_DEFINITIONS})
+set(_exiv2_libs ${EXIV2_LIBRARIES})
+set(EXIV2_LIBRARIES "")
+foreach(l ${_exiv2_libs})
+    set(_el "_el-NOTFOUND")
+    if(EXIV2_LIBRARY_DIRS)
+        message(STATUS "searching for library ${l} in ${EXIV2_LIBRARY_DIRS}")
+        find_library(_el ${l} PATHS ${EXIV2_LIBRARY_DIRS} NO_DEFAULT_PATH)
+        if(NOT _el)
+            message(STATUS  "  NOT FOUND, searching again in default path")
+            find_library(_el ${l})
+        endif()
+    else()
+        message(STATUS "searching for library ${l}")
+        find_library(_el ${l})# PATHS ${EXIV2_LIBRARY_DIRS})
+    endif()
+    message(STATUS "  result: ${_el}")
+    set(EXIV2_LIBRARIES ${EXIV2_LIBRARIES} ${_el})
+endforeach()
+
 if(WIN32)
     add_definitions(-DWIN32)
     add_definitions(-D_WIN32)
@@ -606,6 +631,7 @@ if(OPENMP_FOUND)
     set(CMAKE_REQUIRED_INCLUDES ${FFTW3F_INCLUDE_DIRS})
     set(CMAKE_REQUIRED_LIBRARIES)
     foreach(l ${FFTW3F_LIBRARIES})
+        set(_f "_f-NOTFOUND")
         find_library(_f ${l} PATHS ${FFTW3F_LIBRARY_DIRS})
         set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} ${_f})
     endforeach()
@@ -790,13 +816,18 @@ foreach(l ${LENSFUN_LIBRARIES})
         # the NO_DEFAULT_PATH is to make sure we find the lensfun version we
         # want, and not the system's one (e.g. if we have a custom version
         # installed in a non-standard location)
+        set(_l "_l-NOTFOUND")
+        message(STATUS "searching for library ${l} in ${LENSFUN_LIBRARY_DIRS}")
         find_library(_l ${l} PATHS ${LENSFUN_LIBRARY_DIRS} NO_DEFAULT_PATH)
     else()
         # LENSFUN_LIBRARY_DIRS can be empty if lensfun is installed in the
         # default path. In this case, adding NO_DEFAULT_PATH would make
         # find_library fail...
+        set(_l "_l-NOTFOUND")
+        message(STATUS "searching for library ${l}")
         find_library(_l ${l})
     endif()
+    message(STATUS "  result: ${_l}")
     set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} ${_l})
 endforeach()
 check_cxx_source_compiles(
@@ -838,7 +869,6 @@ else()
         CACHE INTERNAL "" FORCE)
 endif()
 
-add_subdirectory(rtexif)
 add_subdirectory(rtengine)
 add_subdirectory(rtgui)
 add_subdirectory(rtdata)
diff --git a/clean.bat b/clean.bat
index 6a549821e..7196af4b0 100644
--- a/clean.bat
+++ b/clean.bat
@@ -4,24 +4,19 @@ del .\install_manifest.txt
 
 rmdir /s /q .\CMakeFiles 
 rmdir /s /q .\rtengine\CMakeFiles
-rmdir /s /q .\rtexif\CMakeFiles
 rmdir /s /q .\rtgui\CMakeFiles
 rmdir /s /q .\rtdata\CMakeFiles
 
 del .\cmake_*
 del .\rtengine\cmake_*
-del .\rtexif\cmake_*
 del .\rtgui\cmake_*
 del .\rtdata\cmake_*
 
 del .\Makefile
 del .\rtengine\Makefile
-del .\rtexif\Makefile
 del .\rtgui\Makefile
 del .\rtdata\Makefile
 
 del .\rtengine\librtengine.so
 del .\rtengine\librtengine.a
 del .\rtgui\rawtherapee
-del .\rtexif\librtexif.so
-del .\rtexif\librtexif.a
diff --git a/rtdata/images/svg/add.svg b/rtdata/images/svg/add.svg
index c45f9f584..41fa7cc39 100644
--- a/rtdata/images/svg/add.svg
+++ b/rtdata/images/svg/add.svg
@@ -17,7 +17,7 @@
    inkscape:export-filename="/tmp/template.png"
    inkscape:export-xdpi="96"
    inkscape:export-ydpi="96"
-   inkscape:version="0.92.2 2405546, 2018-03-11"
+   inkscape:version="0.91 r13725"
    sodipodi:docname="add.svg">
   <sodipodi:namedview
      id="base"
@@ -26,16 +26,16 @@
      borderopacity="1.0"
      inkscape:pageopacity="0"
      inkscape:pageshadow="2"
-     inkscape:zoom="1"
+     inkscape:zoom="11.313708"
      inkscape:cx="20.683456"
      inkscape:cy="15.839861"
      inkscape:document-units="px"
      inkscape:current-layer="layer1"
      showgrid="true"
      inkscape:window-width="1920"
-     inkscape:window-height="1019"
+     inkscape:window-height="1017"
      inkscape:window-x="0"
-     inkscape:window-y="0"
+     inkscape:window-y="30"
      inkscape:window-maximized="1"
      inkscape:grid-bbox="true"
      inkscape:pagecheckerboard="false"
@@ -70,7 +70,7 @@
         <dc:format>image/svg+xml</dc:format>
         <dc:type
            rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title></dc:title>
+        <dc:title />
         <dc:creator>
           <cc:Agent>
             <dc:title>Maciej Dworak</dc:title>
@@ -120,8 +120,8 @@
        style="opacity:0.7;fill:none;fill-opacity:0.53333285;fill-rule:nonzero;stroke:#2a7fff;stroke-width:1.99999988;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;paint-order:normal" />
     <path
        id="path4951"
-       style="opacity:0.7;fill:none;fill-rule:evenodd;stroke:#2a7fff;stroke-width:4;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
-       d="M 12,3 V 21 M 3,12 h 18"
+       style="opacity:0.7;fill:none;fill-rule:evenodd;stroke:#2a7fff;stroke-width:3.33607316;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       d="m 12.447464,4.4346736 0,15.1306544 M 5,12 19.89493,12"
        inkscape:connector-curvature="0"
        sodipodi:nodetypes="cccc" />
   </g>
diff --git a/rtdata/images/svg/box.svg b/rtdata/images/svg/box.svg
new file mode 100644
index 000000000..2ebee4b8c
--- /dev/null
+++ b/rtdata/images/svg/box.svg
@@ -0,0 +1,110 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="24px"
+   height="24px"
+   viewBox="0 0 24 24"
+   version="1.1"
+   id="SVGRoot"
+   inkscape:export-filename="/tmp/template.png"
+   inkscape:export-xdpi="96"
+   inkscape:export-ydpi="96"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="box.svg">
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#E0E1E2"
+     bordercolor="#666768"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="44.944444"
+     inkscape:cx="12"
+     inkscape:cy="12"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1017"
+     inkscape:window-x="0"
+     inkscape:window-y="30"
+     inkscape:window-maximized="1"
+     inkscape:grid-bbox="true"
+     inkscape:pagecheckerboard="false"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-others="false"
+     inkscape:object-nodes="false"
+     inkscape:snap-grids="true"
+     inkscape:snap-bbox-midpoints="false">
+    <inkscape:grid
+       type="xygrid"
+       id="grid1374"
+       originx="1"
+       originy="1"
+       empspacing="11"
+       dotted="false" />
+  </sodipodi:namedview>
+  <defs
+     id="defs815" />
+  <metadata
+     id="metadata818">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+        <dc:creator>
+          <cc:Agent>
+            <dc:title>Maciej Dworak</dc:title>
+          </cc:Agent>
+        </dc:creator>
+        <dc:rights>
+          <cc:Agent>
+            <dc:title />
+          </cc:Agent>
+        </dc:rights>
+        <dc:description>RawTherapee icon.</dc:description>
+        <cc:license
+           rdf:resource="http://creativecommons.org/licenses/by-sa/4.0/" />
+      </cc:Work>
+      <cc:License
+         rdf:about="http://creativecommons.org/licenses/by-sa/4.0/">
+        <cc:permits
+           rdf:resource="http://creativecommons.org/ns#Reproduction" />
+        <cc:permits
+           rdf:resource="http://creativecommons.org/ns#Distribution" />
+        <cc:requires
+           rdf:resource="http://creativecommons.org/ns#Notice" />
+        <cc:requires
+           rdf:resource="http://creativecommons.org/ns#Attribution" />
+        <cc:permits
+           rdf:resource="http://creativecommons.org/ns#DerivativeWorks" />
+        <cc:requires
+           rdf:resource="http://creativecommons.org/ns#ShareAlike" />
+      </cc:License>
+    </rdf:RDF>
+  </metadata>
+  <g
+     id="layer1"
+     inkscape:groupmode="layer"
+     inkscape:label="Layer 1">
+    <rect
+       style="opacity:0.7;fill:#ffffff;fill-opacity:0;fill-rule:nonzero;stroke:#2a7fff;stroke-width:2.34782624;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       id="rect3335"
+       width="15.652174"
+       height="15.652174"
+       x="4.173913"
+       y="4.173913" />
+  </g>
+</svg>
diff --git a/rtdata/images/svg/edit-small.svg b/rtdata/images/svg/edit-small.svg
new file mode 100644
index 000000000..6306f06df
--- /dev/null
+++ b/rtdata/images/svg/edit-small.svg
@@ -0,0 +1,128 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="16"
+   height="16"
+   viewBox="0 0 16 16"
+   version="1.1"
+   id="SVGRoot"
+   inkscape:export-filename="/tmp/template.png"
+   inkscape:export-xdpi="96"
+   inkscape:export-ydpi="96"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="edit-small.svg">
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#E0E1E2"
+     bordercolor="#666768"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1.04"
+     inkscape:cx="8"
+     inkscape:cy="7.5803253"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1017"
+     inkscape:window-x="0"
+     inkscape:window-y="30"
+     inkscape:window-maximized="1"
+     inkscape:grid-bbox="true"
+     inkscape:pagecheckerboard="false"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-others="false"
+     inkscape:object-nodes="true"
+     inkscape:snap-grids="true"
+     inkscape:snap-bbox-midpoints="false">
+    <inkscape:grid
+       type="xygrid"
+       id="grid1374"
+       originx="1"
+       originy="1"
+       empspacing="7"
+       dotted="false" />
+  </sodipodi:namedview>
+  <defs
+     id="defs815" />
+  <metadata
+     id="metadata818">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+        <dc:creator>
+          <cc:Agent>
+            <dc:title>Maciej Dworak</dc:title>
+          </cc:Agent>
+        </dc:creator>
+        <dc:rights>
+          <cc:Agent>
+            <dc:title />
+          </cc:Agent>
+        </dc:rights>
+        <dc:description>RawTherapee icon.</dc:description>
+        <cc:license
+           rdf:resource="http://creativecommons.org/licenses/by-sa/4.0/" />
+      </cc:Work>
+      <cc:License
+         rdf:about="http://creativecommons.org/licenses/by-sa/4.0/">
+        <cc:permits
+           rdf:resource="http://creativecommons.org/ns#Reproduction" />
+        <cc:permits
+           rdf:resource="http://creativecommons.org/ns#Distribution" />
+        <cc:requires
+           rdf:resource="http://creativecommons.org/ns#Notice" />
+        <cc:requires
+           rdf:resource="http://creativecommons.org/ns#Attribution" />
+        <cc:permits
+           rdf:resource="http://creativecommons.org/ns#DerivativeWorks" />
+        <cc:requires
+           rdf:resource="http://creativecommons.org/ns#ShareAlike" />
+      </cc:License>
+    </rdf:RDF>
+  </metadata>
+  <g
+     id="layer1"
+     inkscape:groupmode="layer"
+     inkscape:label="Layer 1"
+     transform="translate(0,-8)">
+    <path
+       sodipodi:nodetypes="cccc"
+       inkscape:connector-curvature="0"
+       d="M 55,16 H 65 M 60,11 V 21"
+       style="opacity:0.7;fill:none;fill-rule:evenodd;stroke:#2a7fff;stroke-width:4;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       id="path4977" />
+    <path
+       sodipodi:nodetypes="cccc"
+       inkscape:connector-curvature="0"
+       d="M 24,16 H 34 M 29,11 V 21"
+       style="opacity:0.7;fill:none;fill-rule:evenodd;stroke:#2a7fff;stroke-width:2;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       id="path4981" />
+    <path
+       sodipodi:nodetypes="cccc"
+       inkscape:connector-curvature="0"
+       d="M 39,16 H 49 M 44,11 V 21"
+       style="opacity:0.7;fill:none;fill-rule:evenodd;stroke:#2a7fff;stroke-width:3;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       id="path4983" />
+    <path
+       style="opacity:0.7;fill:#2a7fff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.00157475;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       d="m 11.413246,9.78023 c 0.784726,0 2.23775,1.576711 2.23775,2.428236 0,0.851523 -1.091559,1.184475 -1.091559,1.184475 l -2.237749,-2.428235 c 0,0 0.306833,-1.184476 1.091558,-1.184476 z M 9.762249,11.571765 12,14 6.405626,20.070587 4.1678762,17.642352 Z m -6.1538101,6.677647 2.237749,2.428235 -0.027314,0.02964 -3.9160622,1.821176 1.6783123,-4.249412 z"
+       id="path1658"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="zzcczccccccccccc" />
+  </g>
+</svg>
diff --git a/rtdata/images/svg/edit.svg b/rtdata/images/svg/edit.svg
new file mode 100644
index 000000000..71f3d0b06
--- /dev/null
+++ b/rtdata/images/svg/edit.svg
@@ -0,0 +1,136 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="24px"
+   height="24px"
+   viewBox="0 0 24 24"
+   version="1.1"
+   id="SVGRoot"
+   inkscape:export-filename="/tmp/template.png"
+   inkscape:export-xdpi="96"
+   inkscape:export-ydpi="96"
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="edit.svg">
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#E0E1E2"
+     bordercolor="#666768"
+     borderopacity="1.0"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="34.25"
+     inkscape:cx="12"
+     inkscape:cy="12"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="true"
+     inkscape:window-width="1920"
+     inkscape:window-height="1017"
+     inkscape:window-x="0"
+     inkscape:window-y="30"
+     inkscape:window-maximized="1"
+     inkscape:grid-bbox="true"
+     inkscape:pagecheckerboard="false"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-nodes="true"
+     inkscape:snap-others="false"
+     inkscape:object-nodes="false"
+     inkscape:snap-grids="true"
+     inkscape:snap-bbox-midpoints="false">
+    <inkscape:grid
+       type="xygrid"
+       id="grid1374"
+       originx="1"
+       originy="1"
+       empspacing="11"
+       dotted="false" />
+  </sodipodi:namedview>
+  <defs
+     id="defs815" />
+  <metadata
+     id="metadata818">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+        <dc:creator>
+          <cc:Agent>
+            <dc:title>Maciej Dworak</dc:title>
+          </cc:Agent>
+        </dc:creator>
+        <dc:rights>
+          <cc:Agent>
+            <dc:title />
+          </cc:Agent>
+        </dc:rights>
+        <dc:description>RawTherapee icon.</dc:description>
+        <cc:license
+           rdf:resource="http://creativecommons.org/licenses/by-sa/4.0/" />
+      </cc:Work>
+      <cc:License
+         rdf:about="http://creativecommons.org/licenses/by-sa/4.0/">
+        <cc:permits
+           rdf:resource="http://creativecommons.org/ns#Reproduction" />
+        <cc:permits
+           rdf:resource="http://creativecommons.org/ns#Distribution" />
+        <cc:requires
+           rdf:resource="http://creativecommons.org/ns#Notice" />
+        <cc:requires
+           rdf:resource="http://creativecommons.org/ns#Attribution" />
+        <cc:permits
+           rdf:resource="http://creativecommons.org/ns#DerivativeWorks" />
+        <cc:requires
+           rdf:resource="http://creativecommons.org/ns#ShareAlike" />
+      </cc:License>
+    </rdf:RDF>
+  </metadata>
+  <g
+     id="layer1"
+     inkscape:groupmode="layer"
+     inkscape:label="Layer 1">
+    <path
+       style="opacity:0.7;fill:#2a7fff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.00157475;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       d="M 17.761905,2 C 18.897428,2 21,4.1025723 21,5.238095 c 0,1.1355228 -1.57952,1.57952 -1.57952,1.57952 L 16.182385,3.57952 c 0,0 0.443997,-1.57952 1.57952,-1.57952 z M 15.372861,4.3890438 18.610956,7.6271387 10.515719,15.722376 7.277624,12.484281 Z M 6.4681002,13.293805 9.7061953,16.5319 9.6666663,16.571429 4,19 6.4285712,13.333334 Z"
+       id="path1658"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="zzcczccccccccccc" />
+    <path
+       style="opacity:0.7;fill:#2a7fff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.00157475;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       d="m -34.951172,1.048828 c -1.402705,0 -4,2.5972953 -4,4 0,1.4027047 1.951172,1.9511719 1.951172,1.9511719 l 4,-4 c 0,0 -0.548467,-1.9511719 -1.951172,-1.9511719 z M -32,3.9999999 l -4,4 L -26,18 -22,14 Z M -21,15 l -4,4 0.04883,0.04883 7,3 -3,-7 z"
+       id="path1658-3"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="zzcczccccccccccc" />
+    <path
+       style="fill:#2a7fff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M -34,6.9999999 -25,16 l -1,1 -9,-9.0000001 z"
+       id="path1682"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:#2a7fff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m -24,19 5,2 -4,-3 z"
+       id="path1686"
+       inkscape:connector-curvature="0" />
+    <circle
+       style="opacity:0.7;fill:#2a7fff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1.00157475;stroke-linecap:round;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;paint-order:normal"
+       id="path1690"
+       cx="-35"
+       cy="19"
+       r="3" />
+    <path
+       inkscape:connector-curvature="0"
+       style="opacity:0.7;fill:#2a7fff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1.00157475;stroke-linecap:round;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;paint-order:normal"
+       d="M -36.898437,16.679688 A 3,3 0 0 0 -38,19 a 3,3 0 0 0 3,3 3,3 0 0 0 2.322266,-1.101562 A 3.5,3.5 0 0 1 -33.5,21 3.5,3.5 0 0 1 -37,17.5 a 3.5,3.5 0 0 1 0.101563,-0.820312 z"
+       id="circle1692" />
+  </g>
+</svg>
diff --git a/rtdata/images/svg/tick.svg b/rtdata/images/svg/tick.svg
index 8ab7a2e27..dd4ab4bdd 100644
--- a/rtdata/images/svg/tick.svg
+++ b/rtdata/images/svg/tick.svg
@@ -17,8 +17,8 @@
    inkscape:export-filename="/tmp/template.png"
    inkscape:export-xdpi="96"
    inkscape:export-ydpi="96"
-   inkscape:version="0.92.2 2405546, 2018-03-11"
-   sodipodi:docname="tick-large.svg">
+   inkscape:version="0.91 r13725"
+   sodipodi:docname="tick.svg">
   <sodipodi:namedview
      id="base"
      pagecolor="#E0E1E2"
@@ -33,9 +33,9 @@
      inkscape:current-layer="layer1"
      showgrid="true"
      inkscape:window-width="1920"
-     inkscape:window-height="1019"
+     inkscape:window-height="1017"
      inkscape:window-x="0"
-     inkscape:window-y="0"
+     inkscape:window-y="30"
      inkscape:window-maximized="1"
      inkscape:grid-bbox="true"
      inkscape:pagecheckerboard="false"
@@ -63,7 +63,7 @@
         <dc:format>image/svg+xml</dc:format>
         <dc:type
            rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title></dc:title>
+        <dc:title />
         <dc:creator>
           <cc:Agent>
             <dc:title>Maciej Dworak</dc:title>
@@ -103,7 +103,7 @@
        sodipodi:nodetypes="ccccccc"
        inkscape:connector-curvature="0"
        id="path2996-6"
-       d="M 4.6666624,10.166665 8.3333305,13.833335 19.333336,2.833329 23.000006,6.4999972 8.3333305,21.166671 0.99999442,13.833335 Z"
+       d="M 6.0000005,10.299997 9.0000007,13.533332 18.000004,3.833329 21.000006,7.066663 9.0000007,20 3,13.533332 Z"
        style="opacity:0.7;fill:#2a7fff;fill-opacity:1;stroke:none;stroke-width:2.30911016" />
   </g>
 </svg>
diff --git a/rtdata/languages/default b/rtdata/languages/default
index 45471bb5c..3ddfaa5e9 100644
--- a/rtdata/languages/default
+++ b/rtdata/languages/default
@@ -52,6 +52,7 @@ DYNPROFILEEDITOR_PROFILE;Processing Profile
 EDITWINDOW_TITLE;Image Edit
 EDIT_OBJECT_TOOLTIP;Displays a widget on the preview window which lets you adjust this tool.
 EDIT_PIPETTE_TOOLTIP;To add an adjustment point to the curve, hold the Ctrl key while left-clicking the desired spot in the image preview.\nTo adjust the point, hold the Ctrl key while left-clicking the corresponding area in the preview, then let go of Ctrl (unless you desire fine control) and while still holding the left mouse button move the mouse up or down to move that point up or down in the curve.
+ERROR_MSG_METADATA_VALUE;Metadata: error setting %1 to %2
 EXIFFILTER_APERTURE;Aperture
 EXIFFILTER_CAMERA;Camera
 EXIFFILTER_EXPOSURECOMPENSATION;Exposure compensation (EV)
@@ -63,6 +64,8 @@ EXIFFILTER_LENS;Lens
 EXIFFILTER_METADATAFILTER;Enable metadata filters
 EXIFFILTER_PATH;File path
 EXIFFILTER_SHUTTER;Shutter
+EXIFPANEL_ACTIVATE_ALL_HINT;Select all tags
+EXIFPANEL_ACTIVATE_NONE_HINT;Unselect all tags
 EXIFPANEL_ADDEDIT;Add/Edit
 EXIFPANEL_ADDEDITHINT;Add new tag or edit tag.
 EXIFPANEL_ADDTAGDLG_ENTERVALUE;Enter value
@@ -76,8 +79,8 @@ EXIFPANEL_RESET;Reset
 EXIFPANEL_RESETALL;Reset All
 EXIFPANEL_RESETALLHINT;Reset all tags to their original values.
 EXIFPANEL_RESETHINT;Reset the selected tags to their original values.
-EXIFPANEL_SHOWALL;Show all
-EXIFPANEL_SUBDIRECTORY;Subdirectory
+EXIFPANEL_BASIC_GROUP;Basic
+EXIFPANEL_VALUE_NOT_SHOWN;Not shown
 EXPORT_BYPASS;Processing steps to bypass
 EXPORT_BYPASS_ALL;Select / Unselect All
 EXPORT_BYPASS_DEFRINGE;Bypass Defringe
@@ -1661,7 +1664,7 @@ MAIN_TAB_COLOR;Color
 MAIN_TAB_COLOR_TOOLTIP;Shortcut: <b>Alt-c</b>
 MAIN_TAB_DETAIL;Detail
 MAIN_TAB_DETAIL_TOOLTIP;Shortcut: <b>Alt-d</b>
-MAIN_TAB_DEVELOP; Batch Edit 
+MAIN_TAB_DEVELOP; Batch Edit
 MAIN_TAB_EXIF;Exif
 MAIN_TAB_EXPORT; Fast Export 
 MAIN_TAB_EXPOSURE;Exposure
@@ -1669,7 +1672,7 @@ MAIN_TAB_EXPOSURE_TOOLTIP;Shortcut: <b>Alt-e</b>
 MAIN_TAB_FAVORITES;Favorites
 MAIN_TAB_FAVORITES_TOOLTIP;Shortcut: <b>Alt-u</b>
 MAIN_TAB_FILTER; Filter 
-MAIN_TAB_INSPECT; Inspect 
+MAIN_TAB_INSPECT; Inspect
 MAIN_TAB_IPTC;IPTC
 MAIN_TAB_LOCALLAB;Local
 MAIN_TAB_LOCALLAB_TOOLTIP;Shortcut: <b>Alt-o</b>
@@ -1921,6 +1924,11 @@ PREFERENCES_MENUGROUPLABEL;Group 'Color label'
 PREFERENCES_MENUGROUPPROFILEOPERATIONS;Group 'Processing profile operations'
 PREFERENCES_MENUGROUPRANK;Group 'Rank'
 PREFERENCES_MENUOPTIONS;Context Menu Options
+PREFERENCES_METADATA;Metadata
+PREFERENCES_METADATA_SYNC;Metadata synchronization with XMP sidecars
+PREFERENCES_METADATA_SYNC_NONE;Off
+PREFERENCES_METADATA_SYNC_READ;Read only
+PREFERENCES_METADATA_SYNC_READWRITE;Bidirectional
 PREFERENCES_MONINTENT;Default rendering intent
 PREFERENCES_MONITOR;Monitor
 PREFERENCES_MONPROFILE;Default color profile
@@ -2003,6 +2011,9 @@ PREFERENCES_TP_LABEL;Tool panel:
 PREFERENCES_TP_VSCROLLBAR;Hide vertical scrollbar
 PREFERENCES_USEBUNDLEDPROFILES;Use bundled profiles
 PREFERENCES_WORKFLOW;Layout
+PREFERENCES_XMP_SIDECAR_MODE;XMP sidecar style
+PREFERENCES_XMP_SIDECAR_MODE_STD;Standard (FILENAME.xmp for FILENAME.ext)
+PREFERENCES_XMP_SIDECAR_MODE_EXT;darktable-like (FILENAME.ext.xmp for FILENAME.ext)
 PREFERENCES_ZOOMONSCROLL;Zoom images by scrolling
 PROFILEPANEL_COPYPPASTE;Parameters to copy
 PROFILEPANEL_GLOBALPROFILES;Bundled profiles
diff --git a/rtengine/CMakeLists.txt b/rtengine/CMakeLists.txt
index c657d6f9d..19a93c1c4 100644
--- a/rtengine/CMakeLists.txt
+++ b/rtengine/CMakeLists.txt
@@ -42,8 +42,11 @@ if(NOT WITH_SYSTEM_KLT)
 else()
     include_directories("${KLT_INCLUDE_DIRS}")
 endif()
+if(EXIV2_INCLUDE_DIRS)
+    include_directories("${EXIV2_INCLUDE_DIRS}")
+endif()
 
-link_directories("${PROJECT_SOURCE_DIR}/rtexif"
+link_directories(
     "${EXPAT_LIBRARY_DIRS}"
     "${EXTRA_LIBDIR}"
     "${FFTW3F_LIBRARY_DIRS}"
@@ -142,6 +145,7 @@ set(RTENGINESOURCEFILES
     lcp.cc
     lmmse_demosaic.cc
     loadinitial.cc
+    metadata.cc
     munselllch.cc
     myfile.cc
     panasonic_decoders.cc
@@ -222,7 +226,7 @@ endif()
 
 set_target_properties(rtengine PROPERTIES COMPILE_FLAGS "${RTENGINE_CXX_FLAGS}")
 
-target_link_libraries(rtengine rtexif
+target_link_libraries(rtengine
     ${EXPAT_LIBRARIES}
     ${EXTRA_LIB}
     ${FFTW3F_LIBRARIES}
@@ -239,7 +243,8 @@ target_link_libraries(rtengine rtexif
     ${LENSFUN_LIBRARIES}
     ${RSVG_LIBRARIES}
     ${KLT_LIBRARIES}
-)
+    ${EXIV2_LIBRARIES}
+    )
 
 if(OpenMP_FOUND)
     target_link_libraries(rtengine ${OpenMP_CXX_LIBRARIES})
diff --git a/rtengine/ashift_dt.c b/rtengine/ashift_dt.c
index 6ea96a752..4aa7d815c 100644
--- a/rtengine/ashift_dt.c
+++ b/rtengine/ashift_dt.c
@@ -103,6 +103,9 @@ using namespace std;
 
 //-----------------------------------------------------------------------------
 // RT: BEGIN COMMENT
+#ifdef near
+#  undef near
+#endif         
 #if 0
 DT_MODULE_INTROSPECTION(4, dt_iop_ashift_params_t)
 
diff --git a/rtengine/dcp.cc b/rtengine/dcp.cc
index b65bb5f72..76dfeff5c 100644
--- a/rtengine/dcp.cc
+++ b/rtengine/dcp.cc
@@ -24,6 +24,7 @@
 #include <glib/gstdio.h>
 #include <glibmm/fileutils.h>
 #include <glibmm/miscutils.h>
+#include <unordered_map>
 
 #include "dcp.h"
 
@@ -35,11 +36,9 @@
 #include "rawimagesource.h"
 #include "rt_math.h"
 #include "utils.h"
-#include "../rtexif/rtexif.h"
 #include "../rtgui/options.h"
 
 using namespace rtengine;
-using namespace rtexif;
 
 namespace
 {
@@ -430,7 +429,381 @@ std::map<std::string, std::string> getAliases(const Glib::ustring& profile_dir)
     return res;
 }
 
-}
+class DCPMetadata
+{
+private:
+    enum TagType {
+        INVALID = 0,
+        BYTE = 1,
+        ASCII = 2,
+        SHORT = 3,
+        LONG = 4,
+        RATIONAL = 5,
+        SBYTE = 6,
+        UNDEFINED = 7,
+        SSHORT = 8,
+        SLONG = 9,
+        SRATIONAL = 10,
+        FLOAT = 11,
+        DOUBLE = 12
+    };
+
+    enum ByteOrder {
+        UNKNOWN = 0,
+        INTEL = 0x4949,
+        MOTOROLA = 0x4D4D
+    };
+
+public:
+    explicit DCPMetadata(FILE *file) :
+        file_(file),
+        order_(UNKNOWN)
+    {
+    }
+
+    bool parse()
+    {
+        if (!file_) {
+#ifndef NDEBUG
+            std::cerr << "ERROR: No file opened." << std::endl;
+#endif
+            return false;
+        }
+
+        setlocale(LC_NUMERIC, "C"); // to set decimal point in sscanf
+
+        // read tiff header
+        std::fseek(file_, 0, SEEK_SET);
+        std::uint16_t bo;
+        std::fread(&bo, 1, 2, file_);
+        order_ = ByteOrder(bo);
+
+        get2(); // Skip
+
+        // Seek to IFD
+        const std::size_t offset = get4();
+        std::fseek(file_, offset, SEEK_SET);
+
+        // First read the IFD directory
+        const std::uint16_t numtags = get2();
+
+        if (numtags > 1000) { // KodakIfd has lots of tags, thus 1000 as the limit
+            return false;
+        }
+
+        for (std::uint16_t i = 0; i < numtags; ++i) {
+            Tag tag;
+            if (parseTag(tag)) {
+                tags_[tag.id] = std::move(tag);
+            }
+        }
+
+        return true;
+    }
+
+    bool find(int id) const
+    {
+        return tags_.find(id) != tags_.end();
+    }
+
+    std::string toString(int id) const
+    {
+        const Tags::const_iterator tag = tags_.find(id);
+        if (tag != tags_.end()) {
+            if (tag->second.type == ASCII) {
+                return std::string(tag->second.value.begin(), tag->second.value.end()).c_str();
+            }
+        }
+        return {};
+    }
+
+    std::int32_t toInt(int id, std::size_t offset = 0, TagType as_type = INVALID) const
+    {
+        const Tags::const_iterator tag = tags_.find(id);
+        if (tag == tags_.end()) {
+            return 0;
+        }
+
+        if (as_type == INVALID) {
+            as_type = tag->second.type;
+        }
+
+        switch (as_type) {
+            case SBYTE: {
+                if (offset < tag->second.value.size()) {
+                    return static_cast<signed char>(tag->second.value[offset]);
+                }
+                return 0;
+            }
+
+            case BYTE: {
+                if (offset < tag->second.value.size()) {
+                    return tag->second.value[offset];
+                }
+                return 0;
+            }
+
+            case SSHORT: {
+                if (offset + 1 < tag->second.value.size()) {
+                    return static_cast<std::int16_t>(sget2(tag->second.value.data() + offset));
+                }
+                return 0;
+            }
+
+            case SHORT: {
+                if (offset + 1 < tag->second.value.size()) {
+                    return sget2(tag->second.value.data() + offset);
+                }
+                return 0;
+            }
+
+            case SLONG:
+            case LONG: {
+                if (offset + 3 < tag->second.value.size()) {
+                    return sget4(tag->second.value.data() + offset);
+                }
+                return 0;
+            }
+
+            case SRATIONAL:
+            case RATIONAL: {
+                if (offset + 7 < tag->second.value.size()) {
+                    const std::uint32_t denominator = sget4(tag->second.value.data() + offset + 4);
+                    return
+                        denominator == 0
+                            ? 0
+                            : static_cast<std::int32_t>(sget4(tag->second.value.data() + offset)) / denominator;
+                }
+                return 0;
+            }
+
+            case FLOAT: {
+                return toDouble(id, offset);
+            }
+
+            default: {
+                return 0;
+            }
+        }
+    }
+
+    int toShort(int id, std::size_t offset = 0) const
+    {
+        return toInt(id, offset, SHORT);
+    }
+
+    double toDouble(int id, std::size_t offset = 0) const
+    {
+        const Tags::const_iterator tag = tags_.find(id);
+        if (tag == tags_.end()) {
+            return 0.0;
+        }
+
+        switch (tag->second.type) {
+            case SBYTE: {
+                if (offset < tag->second.value.size()) {
+                    return static_cast<signed char>(tag->second.value[offset]);
+                }
+                return 0.0;
+            }
+
+            case BYTE: {
+                if (offset < tag->second.value.size()) {
+                    return tag->second.value[offset];
+                }
+                return 0.0;
+            }
+
+            case SSHORT: {
+                if (offset + 1 < tag->second.value.size()) {
+                    return static_cast<std::int16_t>(sget2(tag->second.value.data() + offset));
+                }
+                return 0.0;
+            }
+
+            case SHORT: {
+                if (offset + 1 < tag->second.value.size()) {
+                    return sget2(tag->second.value.data() + offset);
+                }
+                return 0.0;
+            }
+
+            case SLONG:
+            case LONG: {
+                if (offset + 3 < tag->second.value.size()) {
+                    return sget4(tag->second.value.data() + offset);
+                }
+                return 0.0;
+            }
+
+            case SRATIONAL:
+            case RATIONAL: {
+                if (offset + 7 < tag->second.value.size()) {
+                    const std::int32_t numerator = sget4(tag->second.value.data() + offset);
+                    const std::int32_t denominator = sget4(tag->second.value.data() + offset + 4);
+                    return
+                        denominator == 0
+                            ? 0.0
+                            : static_cast<double>(numerator) / static_cast<double>(denominator);
+                }
+                return 0.0;
+            }
+
+            case FLOAT: {
+                if (offset + 3 < tag->second.value.size()) {
+                    union IntFloat {
+                        std::uint32_t i;
+                        float f;
+                    } conv;
+
+                    conv.i = sget4(tag->second.value.data() + offset);
+                    return conv.f;  // IEEE FLOATs are already C format, they just need a recast
+                }
+                return 0.0;
+            }
+
+            default: {
+                return 0.0;
+            }
+        }
+    }
+
+    unsigned int getCount(int id) const
+    {
+        const Tags::const_iterator tag = tags_.find(id);
+        if (tag != tags_.end()) {
+            return tag->second.count;
+        }
+        return 0;
+    }
+
+private:
+    struct Tag {
+        int id;
+        std::vector<unsigned char> value;
+        TagType type;
+        unsigned int count;
+    };
+
+    using Tags = std::unordered_map<int, Tag>;
+
+    std::uint16_t sget2(const std::uint8_t* s) const
+    {
+        if (order_ == INTEL) {
+            return s[0] | s[1] << 8;
+        } else {
+            return s[0] << 8 | s[1];
+        }
+    }
+
+    std::uint32_t sget4(const std::uint8_t* s) const
+    {
+        if (order_ == INTEL) {
+            return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;
+        } else {
+            return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];
+        }
+    }
+
+    std::uint16_t get2()
+    {
+        std::uint16_t res = std::numeric_limits<std::uint16_t>::max();
+        std::fread(&res, 1, 2, file_);
+        return sget2(reinterpret_cast<const std::uint8_t*>(&res));
+    }
+
+    std::uint32_t get4()
+    {
+        std::uint32_t res = std::numeric_limits<std::uint32_t>::max();
+        std::fread(&res, 1, 4, file_);
+        return sget4(reinterpret_cast<const std::uint8_t*>(&res));
+    }
+
+    static int getTypeSize(TagType type)
+    {
+        switch (type) {
+            case INVALID:
+            case BYTE:
+            case ASCII:
+            case SBYTE:
+            case UNDEFINED: {
+                return 1;
+            }
+
+            case SHORT:
+            case SSHORT: {
+                return 2;
+            }
+
+            case LONG:
+            case SLONG:
+            case FLOAT: {
+                return 4;
+            }
+
+            case RATIONAL:
+            case SRATIONAL:
+            case DOUBLE: {
+                return 8;
+            }
+        }
+
+        return 1;
+    }
+
+    bool parseTag(Tag& tag)
+    {
+        tag.id = get2();
+        tag.type  = TagType(get2());
+        tag.count = std::max(1U, get4());
+
+        // Filter out invalid tags
+        // Note: The large count is to be able to pass LeafData ASCII tag which can be up to almost 10 megabytes,
+        // (only a small part of it will actually be parsed though)
+        if (
+            tag.type == INVALID
+            || tag.type > DOUBLE
+            || tag.count > 10 * 1024 * 1024
+        ) {
+            tag.type = INVALID;
+            return false;
+        }
+
+        // Store next Tag's position in file
+        const std::size_t saved_position = std::ftell(file_) + 4;
+
+        // Load value field (possibly seek before)
+        const std::size_t value_size = static_cast<std::size_t>(tag.count) * getTypeSize(tag.type);
+
+        if (value_size > 4) {
+            if (std::fseek(file_, get4(), SEEK_SET) == -1) {
+                tag.type = INVALID;
+                return false;
+            }
+        }
+
+        // Read value
+        tag.value.resize(value_size + 1);
+        const std::size_t read = std::fread(tag.value.data(), 1, value_size, file_);
+        if (read != value_size) {
+            tag.type = INVALID;
+            return false;
+        }
+        tag.value[read] = '\0';
+
+        // Seek back to the saved position
+        std::fseek(file_, saved_position, SEEK_SET);
+
+        return true;
+    }
+
+    FILE* const file_;
+
+    Tags tags_;
+    ByteOrder order_;
+};
+
+} // namespace
 
 struct DCPProfileApplyState::Data {
     float pro_photo[3][3];
@@ -462,23 +835,23 @@ DCPProfile::DCPProfile(const Glib::ustring& filename) :
     delta_info.hue_step = delta_info.val_step = look_info.hue_step = look_info.val_step = 0;
     constexpr int tiff_float_size = 4;
 
-    enum class TagKey : int {
-        COLOR_MATRIX_1 = 50721,
-        COLOR_MATRIX_2 = 50722,
-        PROFILE_HUE_SAT_MAP_DIMS = 50937,
-        PROFILE_HUE_SAT_MAP_DATA_1 = 50938,
-        PROFILE_HUE_SAT_MAP_DATA_2 = 50939,
-        PROFILE_TONE_CURVE = 50940,
-        PROFILE_TONE_COPYRIGHT = 50942,
-        CALIBRATION_ILLUMINANT_1 = 50778,
-        CALIBRATION_ILLUMINANT_2 = 50779,
-        FORWARD_MATRIX_1 = 50964,
-        FORWARD_MATRIX_2 = 50965,
-        PROFILE_LOOK_TABLE_DIMS = 50981, // ProfileLookup is the low quality variant
-        PROFILE_LOOK_TABLE_DATA = 50982,
-        PROFILE_HUE_SAT_MAP_ENCODING = 51107,
-        PROFILE_LOOK_TABLE_ENCODING = 51108,
-        BASELINE_EXPOSURE_OFFSET = 51109
+    enum TagKey {
+        TAG_KEY_COLOR_MATRIX_1 = 50721,
+        TAG_KEY_COLOR_MATRIX_2 = 50722,
+        TAG_KEY_PROFILE_HUE_SAT_MAP_DIMS = 50937,
+        TAG_KEY_PROFILE_HUE_SAT_MAP_DATA_1 = 50938,
+        TAG_KEY_PROFILE_HUE_SAT_MAP_DATA_2 = 50939,
+        TAG_KEY_PROFILE_TONE_CURVE = 50940,
+        TAG_KEY_PROFILE_TONE_COPYRIGHT = 50942,
+        TAG_KEY_CALIBRATION_ILLUMINANT_1 = 50778,
+        TAG_KEY_CALIBRATION_ILLUMINANT_2 = 50779,
+        TAG_KEY_FORWARD_MATRIX_1 = 50964,
+        TAG_KEY_FORWARD_MATRIX_2 = 50965,
+        TAG_KEY_PROFILE_LOOK_TABLE_DIMS = 50981, // ProfileLookup is the low quality variant
+        TAG_KEY_PROFILE_LOOK_TABLE_DATA = 50982,
+        TAG_KEY_PROFILE_HUE_SAT_MAP_ENCODING = 51107,
+        TAG_KEY_PROFILE_LOOK_TABLE_ENCODING = 51108,
+        TAG_KEY_BASELINE_EXPOSURE_OFFSET = 51109
     };
 
     static const float adobe_camera_raw_default_curve[] = {
@@ -748,54 +1121,48 @@ DCPProfile::DCPProfile(const Glib::ustring& filename) :
         return;
     }
 
-    ExifManager exifManager(file, nullptr, true);
-    exifManager.parseTIFF(false);
-    std::unique_ptr<TagDirectory> tagDir(exifManager.roots.at(0));
+    DCPMetadata md(file);
+    if (!md.parse()) {
+        printf ("Unable to load DCP profile '%s'.", filename.c_str());
+        return;
+    }
 
-    Tag* tag = tagDir->getTag(toUnderlying(TagKey::CALIBRATION_ILLUMINANT_1));
     light_source_1 =
-        tag
-        ? tag->toInt(0, rtexif::SHORT)
-        : -1;
-    tag = tagDir->getTag(toUnderlying(TagKey::CALIBRATION_ILLUMINANT_2));
+        md.find(TAG_KEY_CALIBRATION_ILLUMINANT_1)
+            ? md.toShort(TAG_KEY_CALIBRATION_ILLUMINANT_1)
+            : -1;
     light_source_2 =
-        tag
-        ? tag->toInt(0, rtexif::SHORT)
-        : -1;
+        md.find(TAG_KEY_CALIBRATION_ILLUMINANT_2)
+            ? md.toShort(TAG_KEY_CALIBRATION_ILLUMINANT_2)
+            : -1;
     temperature_1 = calibrationIlluminantToTemperature(light_source_1);
     temperature_2 = calibrationIlluminantToTemperature(light_source_2);
 
-    const bool has_second_hue_sat = tagDir->getTag(toUnderlying(TagKey::PROFILE_HUE_SAT_MAP_DATA_2)); // Some profiles have two matrices, but just one huesat
+    const bool has_second_hue_sat = md.find(TAG_KEY_PROFILE_HUE_SAT_MAP_DATA_2); // Some profiles have two matrices, but just one huesat
 
     // Fetch Forward Matrices, if any
-    tag = tagDir->getTag(toUnderlying(TagKey::FORWARD_MATRIX_1));
-
-    if (tag) {
-        has_forward_matrix_1 = true;
+    has_forward_matrix_1 = md.find(TAG_KEY_FORWARD_MATRIX_1);
 
+    if (has_forward_matrix_1) {
         for (int row = 0; row < 3; ++row) {
             for (int col = 0; col < 3; ++col) {
-                forward_matrix_1[row][col] = tag->toDouble((col + row * 3) * 8);
+                forward_matrix_1[row][col] = md.toDouble(TAG_KEY_FORWARD_MATRIX_1, (col + row * 3) * 8);
             }
         }
     }
 
-    tag = tagDir->getTag(toUnderlying(TagKey::FORWARD_MATRIX_2));
-
-    if (tag) {
-        has_forward_matrix_2 = true;
+    has_forward_matrix_2 = md.find(TAG_KEY_FORWARD_MATRIX_2);
 
+    if (has_forward_matrix_2) {
         for (int row = 0; row < 3; ++row) {
             for (int col = 0; col < 3; ++col) {
-                forward_matrix_2[row][col] = tag->toDouble((col + row * 3) * 8);
+                forward_matrix_2[row][col] = md.toDouble(TAG_KEY_FORWARD_MATRIX_2, (col + row * 3) * 8);
             }
         }
     }
 
     // Color Matrix (one is always there)
-    tag = tagDir->getTag(toUnderlying(TagKey::COLOR_MATRIX_1));
-
-    if (!tag) {
+    if (!md.find(TAG_KEY_COLOR_MATRIX_1)) {
         std::cerr << "DCP '" << filename << "' is missing 'ColorMatrix1'. Skipped." << std::endl;
         fclose(file);
         return;
@@ -805,29 +1172,24 @@ DCPProfile::DCPProfile(const Glib::ustring& filename) :
 
     for (int row = 0; row < 3; ++row) {
         for (int col = 0; col < 3; ++col) {
-            color_matrix_1[row][col] = tag->toDouble((col + row * 3) * 8);
+            color_matrix_1[row][col] = md.toDouble(TAG_KEY_COLOR_MATRIX_1, (col + row * 3) * 8);
         }
     }
 
-    tag = tagDir->getTag(toUnderlying(TagKey::PROFILE_LOOK_TABLE_DIMS));
-
-    if (tag) {
-        look_info.hue_divisions = tag->toInt(0);
-        look_info.sat_divisions = tag->toInt(4);
-        look_info.val_divisions = tag->toInt(8);
-
-        tag = tagDir->getTag(toUnderlying(TagKey::PROFILE_LOOK_TABLE_ENCODING));
-        look_info.srgb_gamma = tag && tag->toInt(0);
+    if (md.find(TAG_KEY_PROFILE_LOOK_TABLE_DIMS)) {
+        look_info.hue_divisions = md.toInt(TAG_KEY_PROFILE_LOOK_TABLE_DIMS, 0);
+        look_info.sat_divisions = md.toInt(TAG_KEY_PROFILE_LOOK_TABLE_DIMS, 4);
+        look_info.val_divisions = md.toInt(TAG_KEY_PROFILE_LOOK_TABLE_DIMS, 8);
 
-        tag = tagDir->getTag(toUnderlying(TagKey::PROFILE_LOOK_TABLE_DATA));
-        look_info.array_count = tag->getCount() / 3;
+        look_info.srgb_gamma = md.find(TAG_KEY_PROFILE_LOOK_TABLE_ENCODING) && md.toInt(TAG_KEY_PROFILE_LOOK_TABLE_ENCODING);
 
+        look_info.array_count = md.getCount(TAG_KEY_PROFILE_LOOK_TABLE_DATA) / 3;
         look_table.resize(look_info.array_count);
 
         for (unsigned int i = 0; i < look_info.array_count; i++) {
-            look_table[i].hue_shift = tag->toDouble((i * 3) * tiff_float_size);
-            look_table[i].sat_scale = tag->toDouble((i * 3 + 1) * tiff_float_size);
-            look_table[i].val_scale = tag->toDouble((i * 3 + 2) * tiff_float_size);
+            look_table[i].hue_shift = md.toDouble(TAG_KEY_PROFILE_LOOK_TABLE_DATA, (i * 3) * tiff_float_size);
+            look_table[i].sat_scale = md.toDouble(TAG_KEY_PROFILE_LOOK_TABLE_DATA, (i * 3 + 1) * tiff_float_size);
+            look_table[i].val_scale = md.toDouble(TAG_KEY_PROFILE_LOOK_TABLE_DATA, (i * 3 + 2) * tiff_float_size);
         }
 
         // Precalculated constants for table application
@@ -844,25 +1206,20 @@ DCPProfile::DCPProfile(const Glib::ustring& filename) :
         look_info.pc.val_step = look_info.hue_divisions * look_info.pc.hue_step;
     }
 
-    tag = tagDir->getTag(toUnderlying(TagKey::PROFILE_HUE_SAT_MAP_DIMS));
-
-    if (tag) {
-        delta_info.hue_divisions = tag->toInt(0);
-        delta_info.sat_divisions = tag->toInt(4);
-        delta_info.val_divisions = tag->toInt(8);
-
-        tag = tagDir->getTag(toUnderlying(TagKey::PROFILE_HUE_SAT_MAP_ENCODING));
-        delta_info.srgb_gamma = tag && tag->toInt(0);
+    if (md.find(TAG_KEY_PROFILE_HUE_SAT_MAP_DIMS)) {
+        delta_info.hue_divisions = md.toInt(TAG_KEY_PROFILE_HUE_SAT_MAP_DIMS, 0);
+        delta_info.sat_divisions = md.toInt(TAG_KEY_PROFILE_HUE_SAT_MAP_DIMS, 4);
+        delta_info.val_divisions = md.toInt(TAG_KEY_PROFILE_HUE_SAT_MAP_DIMS, 8);
 
-        tag = tagDir->getTag(toUnderlying(TagKey::PROFILE_HUE_SAT_MAP_DATA_1));
-        delta_info.array_count = tag->getCount() / 3;
+        delta_info.srgb_gamma = md.find(TAG_KEY_PROFILE_HUE_SAT_MAP_ENCODING) && md.toInt(TAG_KEY_PROFILE_HUE_SAT_MAP_ENCODING);
 
+        delta_info.array_count = md.getCount(TAG_KEY_PROFILE_HUE_SAT_MAP_DATA_1) / 3;
         deltas_1.resize(delta_info.array_count);
 
         for (unsigned int i = 0; i < delta_info.array_count; ++i) {
-            deltas_1[i].hue_shift = tag->toDouble((i * 3) * tiff_float_size);
-            deltas_1[i].sat_scale = tag->toDouble((i * 3 + 1) * tiff_float_size);
-            deltas_1[i].val_scale = tag->toDouble((i * 3 + 2) * tiff_float_size);
+            deltas_1[i].hue_shift = md.toDouble(TAG_KEY_PROFILE_HUE_SAT_MAP_DATA_1, (i * 3) * tiff_float_size);
+            deltas_1[i].sat_scale = md.toDouble(TAG_KEY_PROFILE_HUE_SAT_MAP_DATA_1, (i * 3 + 1) * tiff_float_size);
+            deltas_1[i].val_scale = md.toDouble(TAG_KEY_PROFILE_HUE_SAT_MAP_DATA_1, (i * 3 + 2) * tiff_float_size);
         }
 
         delta_info.pc.h_scale =
@@ -882,14 +1239,14 @@ DCPProfile::DCPProfile(const Glib::ustring& filename) :
         // Second matrix
         has_color_matrix_2 = true;
 
-        tag = tagDir->getTag(toUnderlying(TagKey::COLOR_MATRIX_2));
+        const bool cm2 = md.find(TAG_KEY_COLOR_MATRIX_2);
 
         for (int row = 0; row < 3; ++row) {
             for (int col = 0; col < 3; ++col) {
                 color_matrix_2[row][col] =
-                    tag
-                    ? tag->toDouble((col + row * 3) * 8)
-                    : color_matrix_1[row][col];
+                    cm2
+                        ? md.toDouble(TAG_KEY_COLOR_MATRIX_2, (col + row * 3) * 8)
+                        : color_matrix_1[row][col];
             }
         }
 
@@ -898,27 +1255,21 @@ DCPProfile::DCPProfile(const Glib::ustring& filename) :
             deltas_2.resize(delta_info.array_count);
 
             // Saturation maps. Need to be unwinded.
-            tag = tagDir->getTag(toUnderlying(TagKey::PROFILE_HUE_SAT_MAP_DATA_2));
-
             for (unsigned int i = 0; i < delta_info.array_count; ++i) {
-                deltas_2[i].hue_shift = tag->toDouble((i * 3) * tiff_float_size);
-                deltas_2[i].sat_scale = tag->toDouble((i * 3 + 1) * tiff_float_size);
-                deltas_2[i].val_scale = tag->toDouble((i * 3 + 2) * tiff_float_size);
+                deltas_2[i].hue_shift = md.toDouble(TAG_KEY_PROFILE_HUE_SAT_MAP_DATA_2, (i * 3) * tiff_float_size);
+                deltas_2[i].sat_scale = md.toDouble(TAG_KEY_PROFILE_HUE_SAT_MAP_DATA_2, (i * 3 + 1) * tiff_float_size);
+                deltas_2[i].val_scale = md.toDouble(TAG_KEY_PROFILE_HUE_SAT_MAP_DATA_2, (i * 3 + 2) * tiff_float_size);
             }
         }
     }
 
-    tag = tagDir->getTag(toUnderlying(TagKey::BASELINE_EXPOSURE_OFFSET));
-
-    if (tag) {
-        has_baseline_exposure_offset = true;
-        baseline_exposure_offset = tag->toDouble();
+    has_baseline_exposure_offset = md.find(TAG_KEY_BASELINE_EXPOSURE_OFFSET);
+    if (has_baseline_exposure_offset) {
+        baseline_exposure_offset = md.toDouble(TAG_KEY_BASELINE_EXPOSURE_OFFSET);
     }
 
     // Read tone curve points, if any, but disable to RTs own profiles
-    tag = tagDir->getTag(toUnderlying(TagKey::PROFILE_TONE_CURVE));
-
-    if (tag) {
+    if (md.find(TAG_KEY_PROFILE_TONE_CURVE)) {
         std::vector<double> curve_points = {
             static_cast<double>(DCT_Spline) // The first value is the curve type
         };
@@ -926,9 +1277,9 @@ DCPProfile::DCPProfile(const Glib::ustring& filename) :
         // Push back each X/Y coordinates in a loop
         bool curve_is_linear = true;
 
-        for (int i = 0; i < tag->getCount(); i += 2) {
-            const double x = tag->toDouble((i + 0) * tiff_float_size);
-            const double y = tag->toDouble((i + 1) * tiff_float_size);
+        for (unsigned int i = 0, n = md.getCount(TAG_KEY_PROFILE_TONE_CURVE); i < n; i += 2) {
+            const double x = md.toDouble(TAG_KEY_PROFILE_TONE_CURVE, (i + 0) * tiff_float_size);
+            const double y = md.toDouble(TAG_KEY_PROFILE_TONE_CURVE, (i + 1) * tiff_float_size);
 
             if (x != y) {
                 curve_is_linear = false;
@@ -944,9 +1295,7 @@ DCPProfile::DCPProfile(const Glib::ustring& filename) :
             tone_curve.Set(DiagonalCurve(curve_points, CURVES_MIN_POLY_POINTS));
         }
     } else {
-        tag = tagDir->getTag(toUnderlying(TagKey::PROFILE_TONE_COPYRIGHT));
-
-        if (tag && tag->valueToString().find("Adobe Systems") != std::string::npos) {
+        if (md.find(TAG_KEY_PROFILE_TONE_COPYRIGHT) && md.toString(TAG_KEY_PROFILE_TONE_COPYRIGHT).find("Adobe Systems") != std::string::npos) {
             // An Adobe profile without tone curve is expected to have the Adobe Default Curve, we add that
             std::vector<double> curve_points = {
                 static_cast<double>(DCT_Spline)
@@ -1799,7 +2148,7 @@ void DCPStore::init(const Glib::ustring& rt_profile_dir, bool loadAll)
 
     std::deque<Glib::ustring> dirs = {
         rt_profile_dir,
-        Glib::build_filename(options.rtdir, "dcpprofiles")        
+        Glib::build_filename(options.rtdir, "dcpprofiles")
     };
 
     while (!dirs.empty()) {
diff --git a/rtengine/dfmanager.cc b/rtengine/dfmanager.cc
index 34215e58c..52de10339 100644
--- a/rtengine/dfmanager.cc
+++ b/rtengine/dfmanager.cc
@@ -569,7 +569,7 @@ dfInfo* rtengine::DFManager::Implementation::addFileInfo(const Glib::ustring& fi
             return &(iter->second);
         }
 
-        FramesData idata(filename, std::unique_ptr<RawMetaDataLocation>(new RawMetaDataLocation(ri.get_exifBase(), ri.get_ciffBase(), ri.get_ciffLen())), true);
+        FramesData idata(filename);
         /* Files are added in the map, divided by same maker/model,ISO and shutter*/
         std::string key(dfInfo::key(toUppercase(idata.getMake()), toUppercase(idata.getModel()), idata.getISOSpeed(), idata.getShutterSpeed()));
         auto iter = dfList.find(key);
diff --git a/rtengine/dynamicprofile.cc b/rtengine/dynamicprofile.cc
index 32be2ceb2..0f2ab0f31 100644
--- a/rtengine/dynamicprofile.cc
+++ b/rtengine/dynamicprofile.cc
@@ -88,7 +88,7 @@ bool DynamicProfileRule::matches (const rtengine::FramesMetaData *im,  const Gli
             && camera (im->getCamera())
             && lens (im->getLens())
             && path (filename)
-            && imagetype(im->getImageType(0)));
+            && imagetype(im->getImageType()));
 }
 
 namespace
diff --git a/rtengine/ffmanager.cc b/rtengine/ffmanager.cc
index c55bc5108..bd6428127 100644
--- a/rtengine/ffmanager.cc
+++ b/rtengine/ffmanager.cc
@@ -342,7 +342,7 @@ ffInfo* FFManager::addFileInfo (const Glib::ustring& filename, bool pool)
             return &(iter->second);
         }
 
-        FramesData idata(filename, std::unique_ptr<RawMetaDataLocation>(new RawMetaDataLocation(ri.get_exifBase(), ri.get_ciffBase(), ri.get_ciffLen())), true);
+        FramesData idata(filename);
         /* Files are added in the map, divided by same maker/model,lens and aperture*/
         std::string key(ffInfo::key(idata.getMake(), idata.getModel(), idata.getLens(), idata.getFocalLen(), idata.getFNumber()));
         iter = ffList.find(key);
diff --git a/rtengine/hilite_recon.cc b/rtengine/hilite_recon.cc
index f573ff015..653ce80a2 100644
--- a/rtengine/hilite_recon.cc
+++ b/rtengine/hilite_recon.cc
@@ -1176,27 +1176,27 @@ void RawImageSource::HLRecovery_inpaint(float** red, float** green, float** blue
                                       {2.0f, 3.0f, 0.001f}
                                      };
 
-        const float rad1 = vals[blur][0];
-        const float rad2 = vals[blur][1];
+        const float radius1 = vals[blur][0];
+        const float radius2 = vals[blur][1];
         const float th = vals[blur][2];
 
-        guidedFilter(guide, mask, mask, rad1, th, true, 1);
+        guidedFilter(guide, mask, mask, radius1, th, true, 1);
         if (plistener) {
             progress += 0.03;
             plistener->setProgress(progress);
         }
         if (blur > 0) { //no use of 2nd guidedFilter if Blur = 0 (slider to 1)..speed-up and very small differences.
-            guidedFilter(guide, rbuf, rbuf, rad2, 0.01f * 65535.f, true, 1);
+            guidedFilter(guide, rbuf, rbuf, radius2, 0.01f * 65535.f, true, 1);
             if (plistener) {
                 progress += 0.03;
                 plistener->setProgress(progress);
             }
-            guidedFilter(guide, gbuf, gbuf, rad2, 0.01f * 65535.f, true, 1);
+            guidedFilter(guide, gbuf, gbuf, radius2, 0.01f * 65535.f, true, 1);
             if (plistener) {
                 progress += 0.03;
                 plistener->setProgress(progress);
             }
-            guidedFilter(guide, bbuf, bbuf, rad2, 0.01f * 65535.f, true, 1);
+            guidedFilter(guide, bbuf, bbuf, radius2, 0.01f * 65535.f, true, 1);
             if (plistener) {
                 progress += 0.03;
                 plistener->setProgress(progress);
diff --git a/rtengine/histmatching.cc b/rtengine/histmatching.cc
index 350dbbfab..c86a9c92c 100644
--- a/rtengine/histmatching.cc
+++ b/rtengine/histmatching.cc
@@ -277,10 +277,9 @@ void RawImageSource::getAutoMatchedToneCurve(const ColorManagementParams &cp, St
 
     std::unique_ptr<IImage8> source;
     {
-        RawMetaDataLocation rml;
         eSensorType sensor_type;
         int w = 0, h = 0;
-        std::unique_ptr<Thumbnail> thumb(Thumbnail::loadQuickFromRaw(getFileName(), rml, sensor_type, w, h, 1, false, true, true));
+        const std::unique_ptr<Thumbnail> thumb(Thumbnail::loadQuickFromRaw(getFileName(), sensor_type, w, h, 1, false, true, true));
         if (!thumb) {
             if (settings->verbose) {
                 std::cout << "histogram matching: no thumbnail found, generating a neutral curve" << std::endl;
@@ -309,11 +308,10 @@ void RawImageSource::getAutoMatchedToneCurve(const ColorManagementParams &cp, St
 
     std::unique_ptr<IImage8> target;
     {
-        RawMetaDataLocation rml;
         eSensorType sensor_type;
         double scale;
         int w = fw / skip, h = fh / skip;
-        std::unique_ptr<Thumbnail> thumb(Thumbnail::loadFromRaw(getFileName(), rml, sensor_type, w, h, 1, false, observer, false, true));
+        const std::unique_ptr<Thumbnail> thumb(Thumbnail::loadFromRaw(getFileName(), sensor_type, w, h, 1, false, observer, false, true));
         if (!thumb) {
             if (settings->verbose) {
                 std::cout << "histogram matching: raw decoding failed, generating a neutral curve" << std::endl;
diff --git a/rtengine/imagedata.cc b/rtengine/imagedata.cc
index fb2fcaf3a..430559f3d 100644
--- a/rtengine/imagedata.cc
+++ b/rtengine/imagedata.cc
@@ -17,60 +17,30 @@
  *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
  */
 #include <functional>
+#include <iostream>
+#include <regex>
+#include <sstream>
 
 #include <strings.h>
 #include <time.h>
-
 #include <tiff.h>
-
 #include <glib/gstdio.h>
-
 #include <glibmm/convert.h>
 
 #include "imagedata.h"
 #include "imagesource.h"
-#include "iptcpairs.h"
-#include "procparams.h"
+#include "metadata.h"
 #include "rt_math.h"
 #include "utils.h"
-#include "../rtexif/rtexif.h"
 
 #pragma GCC diagnostic warning "-Wextra"
 #define PRINT_HDR_PS_DETECTION 0
 
 using namespace rtengine;
 
-extern "C" IptcData *iptc_data_new_from_jpeg_file(FILE* infile);
-
 namespace
 {
 
-Glib::ustring to_utf8(const std::string& str)
-{
-    try {
-        return Glib::locale_to_utf8(str);
-    } catch (Glib::Error&) {
-        return Glib::convert_with_fallback(str, "UTF-8", "ISO-8859-1", "?");
-    }
-}
-
-template<typename T>
-T getFromFrame(
-    const std::vector<std::unique_ptr<FrameData>>& frames,
-    std::size_t frame,
-    const std::function<T (const FrameData&)>& function,
-    T defval = {}
-)
-{
-    if (frame < frames.size()) {
-        return function(*frames[frame]);
-    }
-    if (!frames.empty()) {
-        return function(*frames[0]);
-    }
-    return defval;
-}
-
 const std::string& validateUft8(const std::string& str, const std::string& on_error = "???")
 {
     if (Glib::ustring(str).validate()) {
@@ -80,11 +50,30 @@ const std::string& validateUft8(const std::string& str, const std::string& on_er
     return on_error;
 }
 
+template <typename Iterator, typename Integer = std::size_t>
+auto to_long(const Iterator &iter, Integer n = Integer{0}) -> decltype(
+#if EXIV2_TEST_VERSION(0,28,0)
+    iter->toInt64()
+) {
+    return iter->toInt64(n);
+#else
+    iter->toLong()
+) {
+    return iter->toLong(n);
+#endif
+}
+
 }
 
-FramesMetaData* FramesMetaData::fromFile(const Glib::ustring& fname, std::unique_ptr<RawMetaDataLocation> rml, bool firstFrameOnly)
+namespace rtengine {
+
+extern const Settings *settings;
+
+} // namespace rtengine
+
+FramesMetaData* FramesMetaData::fromFile(const Glib::ustring& fname)
 {
-    return new FramesData(fname, std::move(rml), firstFrameOnly);
+    return new FramesData(fname);
 }
 
 static struct tm timeFromTS(const time_t ts)
@@ -97,11 +86,12 @@ static struct tm timeFromTS(const time_t ts)
 #endif
 }
 
-FrameData::FrameData(rtexif::TagDirectory* frameRootDir_, rtexif::TagDirectory* rootDir, rtexif::TagDirectory* firstRootDir, time_t ts) :
-    frameRootDir(frameRootDir_),
-    iptc(nullptr),
-    time(timeFromTS(ts)),
-    timeStamp(ts),
+FramesData::FramesData(const Glib::ustring &fname, time_t ts) :
+    ok_(false),
+    fname_(fname),
+    dcrawFrameCount(0),
+    time{timeFromTS(ts)},
+    timeStamp{ts},
     iso_speed(0),
     aperture(0.),
     focal_len(0.),
@@ -116,11 +106,14 @@ FrameData::FrameData(rtexif::TagDirectory* frameRootDir_, rtexif::TagDirectory*
     lens("Unknown"),
     sampleFormat(IIOSF_UNKNOWN),
     isPixelShift(false),
-    isHDR(false)
+    isHDR(false),
+    w_(-1),
+    h_(-1)
 {
-    if (!frameRootDir) {
-        return;
-    }
+    GStatBuf statbuf = {};
+    g_stat(fname.c_str(), &statbuf);
+    modTimeStamp = statbuf.st_mtime;
+    modTime = timeFromTS(modTimeStamp);
 
     make.clear();
     model.clear();
@@ -128,1137 +121,698 @@ FrameData::FrameData(rtexif::TagDirectory* frameRootDir_, rtexif::TagDirectory*
     orientation.clear();
     lens.clear();
 
-    rtexif::TagDirectory* newFrameRootDir = frameRootDir;
-
-    rtexif::Tag* tag = newFrameRootDir->findTag("Make");
-    if (!tag) {
-        newFrameRootDir = rootDir;
-        tag = newFrameRootDir->findTag("Make");
+    try {
+        Exiv2Metadata meta(fname);
+        meta.load();
+        const auto& exif = meta.exifData();
+        ok_ = true;
 
-        if (!tag) {
-            // For some raw files (like Canon's CR2 files), the metadata are contained in the first root directory
-            newFrameRootDir = firstRootDir;
-            tag = newFrameRootDir->findTag("Make");
-        }
-    }
+        // taken and adapted from darktable (src/common/exif.cc)
+/*
+   This file is part of darktable,
+   copyright (c) 2009--2013 johannes hanika.
+   copyright (c) 2011 henrik andersson.
+   copyright (c) 2012-2017 tobias ellinghaus.
+
+   darktable is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   darktable is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with darktable.  If not, see <http://www.gnu.org/licenses/>.
+ */
 
-    if (tag) {
-        make = validateUft8(tag->valueToString());
-
-        // Same dcraw treatment
-        for (const auto& corp : {
-        "Canon",
-        "NIKON",
-        "EPSON",
-        "KODAK",
-        "Kodak",
-        "OLYMPUS",
-        "PENTAX",
-        "RICOH",
-        "MINOLTA",
-        "Minolta",
-        "Konica",
-        "CASIO",
-        "Sinar",
-        "Phase One",
-        "SAMSUNG",
-        "Mamiya",
-        "MOTOROLA",
-        "Leaf",
-        "Panasonic"
-    }) {
-            if (make.find(corp) != std::string::npos) { // Simplify company names
-                make = corp;
-                break;
+        Exiv2::ExifData::const_iterator pos;
+
+        const auto find_exif_tag =
+            [&exif, &pos](const std::string &name) -> bool
+            {
+                try {
+                    pos = exif.findKey(Exiv2::ExifKey(name));
+                    return pos != exif.end() && pos->size();
+                } catch (std::exception &e) {
+                    if (settings->verbose) {
+                        std::cerr << "Exiv2 WARNING -- error finding tag " << name << ": " << e.what() << std::endl;
+                    }
+                    return false;
+                }
+            };
+
+        const auto find_tag =
+            [&exif, &pos](decltype(Exiv2::make) func) -> bool
+            {
+                pos = func(exif);
+                return pos != exif.end() && pos->size();
+            };
+
+        // List of tag names taken from exiv2's printSummary() in actions.cpp
+
+        if (find_tag(Exiv2::make)) {
+            make = validateUft8(pos->print(&exif));
+        }
+
+        if (find_tag(Exiv2::model)) {
+            model = validateUft8(pos->print(&exif));
+        }
+
+        if (make.size() > 0) {
+            for (const auto& corp : {
+                "Canon",
+                "NIKON",
+                "EPSON",
+                "KODAK",
+                "Kodak",
+                "OLYMPUS",
+                "PENTAX",
+                "RICOH",
+                "MINOLTA",
+                "Minolta",
+                "Konica",
+                "CASIO",
+                "Sinar",
+                "Phase One",
+                "SAMSUNG",
+                "Mamiya",
+                "MOTOROLA",
+                "Leaf",
+                "Panasonic"
+            }) {
+                if (make.find(corp) != std::string::npos) { // Simplify company names
+                    make = corp;
+                    break;
+                }
             }
         }
 
-        make.erase(make.find_last_not_of(' ') + 1);
-    }
-
-    tag = newFrameRootDir->findTagUpward("Model");
-
-    if (tag) {
-        model = validateUft8(tag->valueToString());
-    }
-
-    if (!model.empty()) {
-        std::string::size_type i = 0;
-
-        if (
-            make.find("KODAK") != std::string::npos
-            && (
-                (i = model.find(" DIGITAL CAMERA")) != std::string::npos
-                || (i = model.find(" Digital Camera")) !=  std::string::npos
-                || (i = model.find("FILE VERSION")) !=  std::string::npos
-            )
-        ) {
-            model.resize(i);
+        std::string::size_type nonspace_pos = make.find_last_not_of(' ');
+        if (nonspace_pos != std::string::npos && nonspace_pos + 1 < make.size()) {
+            make.erase(nonspace_pos + 1);
         }
-
-        model.erase(model.find_last_not_of(' ') + 1);
-
-        if (!strncasecmp(model.c_str(), make.c_str(), make.size())) {
-            if (model.size() >= make.size() && model[make.size()] == ' ') {
-                model.erase(0, make.size() + 1);
-            }
+        nonspace_pos = model.find_last_not_of(' ');
+        if (nonspace_pos != std::string::npos && nonspace_pos + 1 < model.size()) {
+            model.erase(nonspace_pos + 1);
         }
 
-        if (model.find("Digital Camera ") != std::string::npos) {
-            model.erase(0, 15);
+        if (!make.empty() && model.find(make + ' ') == 0) {
+            model.erase(0, make.size() + 1);
         }
-    } else {
-        model = "Unknown";
-    }
 
-    if (model == "Unknown") {
-        tag = newFrameRootDir->findTag("UniqueCameraModel");
-        if (tag) {
-            model = validateUft8(tag->valueToString());
+        if (find_tag(Exiv2::exposureTime)) {
+            shutter = pos->toFloat();
         }
-    }
-
-    tag = newFrameRootDir->findTagUpward("Orientation");
-
-    if (tag) {
-        orientation = validateUft8(tag->valueToString());
-    }
-
-    // Look for Rating metadata in the following order:
-    // 1. EXIF
-    // 2. XMP
-    // 3. pp3 sidecar file
-    tag = newFrameRootDir->findTagUpward("Rating");
-    if (tag && tag->toInt() != 0) {
-        rating = tag->toInt();
-    }
-    char sXMPRating[64];
-    if (newFrameRootDir->getXMPTagValue("xmp:Rating", sXMPRating)) {
-        // Guard against out-of-range values (<0, >5)
-        rating = rtengine::max(0, rtengine::min(5, atoi(sXMPRating)));
-        // Currently, Rating=-1 is not supported. A value of -1 should mean
-        // "Rejected" according to the specification. Maybe in the future, Rating=-1
-        // sets InTrash=true?
-    }
-
-    tag = newFrameRootDir->findTagUpward("MakerNote");
-    rtexif::TagDirectory* mnote = nullptr;
 
-    if (tag) {
-        mnote = tag->getDirectory();
-    }
-
-    rtexif::TagDirectory* exif = nullptr;
-    tag = newFrameRootDir->findTagUpward("Exif");
-
-    if (tag) {
-        exif = tag->getDirectory();
-    }
-
-    if (exif) {
-
-        // standard exif tags
-        if ((tag = exif->getTag("ShutterSpeedValue"))) {
-            shutter = tag->toDouble();
-        }
-
-        if ((tag = exif->getTag("ExposureTime"))) {
-            shutter = tag->toDouble();
+        if (find_tag(Exiv2::fNumber)) {
+            aperture = pos->toFloat();
         }
 
-        if ((tag = exif->getTag("ApertureValue"))) {
-            aperture = tag->toDouble();
-        }
-
-        if ((tag = exif->getTag("FNumber"))) {
-            aperture = tag->toDouble();
-        }
-
-        if ((tag = exif->getTag("ExposureBiasValue"))) {
-            expcomp = tag->toDouble();
-        }
-
-        if ((tag = exif->getTag("FocalLength"))) {
-            focal_len = tag->toDouble();
+        // Read ISO speed - Nikon happens to return a pair for Lo and Hi modes
+        if (find_tag(Exiv2::isoSpeed)) {
+            // If standard exif iso tag, use the old way of interpreting the return value to be more regression-save
+            if (pos->key() == "Exif.Photo.ISOSpeedRatings") {
+                const long isofield = pos->count() > 1 ? 1 : 0;
+                iso_speed = pos->toFloat(isofield);
+            } else {
+                iso_speed = std::atof(pos->print().c_str());
+            }
         }
-
-        if ((tag = exif->getTag("FocalLengthIn35mmFilm"))) {
-            focal_len35mm = tag->toDouble();
+        // Some newer cameras support iso settings that exceed the 16 bit of exif's ISOSpeedRatings
+        if (iso_speed == 65535 || iso_speed == 0) {
+            if (find_exif_tag("Exif.PentaxDng.ISO") || find_exif_tag("Exif.Pentax.ISO")) {
+                iso_speed = std::atof(pos->print().c_str());
+            }
+            else if (
+                (
+                    make == "SONY"
+                    || make == "Canon"
+                )
+                && find_exif_tag("Exif.Photo.RecommendedExposureIndex")
+            ) {
+                iso_speed = pos->toFloat();
+            }
         }
 
-        // Focus distance from EXIF or XMP. MakerNote ones are scattered and partly encrypted
-        int num = -3, denom = -3;
-
-        // First try, official EXIF. Set by Adobe on some DNGs
-        tag = exif->getTag("SubjectDistance");
-
-        if (tag) {
-            tag->toRational(num, denom);
+        if (find_tag(Exiv2::serialNumber)) {
+            serial = validateUft8(pos->toString());
         } else {
-            // Second try, XMP data
-            char sXMPVal[64];
-
-            if (newFrameRootDir->getXMPTagValue("aux:ApproximateFocusDistance", sXMPVal)) {
-                sscanf(sXMPVal, "%d/%d", &num, &denom);
+            const std::vector<std::string> serial_number_tags{
+                "Exif.Photo.BodySerialNumber",
+                "Exif.Canon.SerialNumber",
+                "Exif.Fujifilm.SerialNumber",
+                "Exif.Nikon3.SerialNumber",
+                "Exif.Nikon3.SerialNO",
+                "Exif.Olympus.SerialNumber2",
+                "Exif.OlympusEq.SerialNumber",
+                "Exif.Pentax.SerialNumber",
+                "Exif.PentaxDng.SerialNumber",
+                "Exif.Sigma.SerialNumber",
+                "Exif.Canon.InternalSerialNumber",
+                "Exif.OlympusEq.InternalSerialNumber",
+                "Exif.Panasonic.InternalSerialNumber",
+            };
+            if (serial_number_tags.cend() != std::find_if(serial_number_tags.cbegin(), serial_number_tags.cend(), find_exif_tag)) {
+                serial = validateUft8(pos->toString());
+            } else if (find_exif_tag("Exif.Minolta.WBInfoA100") || find_exif_tag("Exif.SonyMinolta.WBInfoA100")) {
+                const long index = 18908;
+                const int length = 12;
+                if (pos->count() >= index + length) {
+                    for (int i = 0; i < length; ++i) {
+                        serial += static_cast<char>(to_long(pos, index + i));
+                    }
+                    serial = validateUft8(serial);
+                }
+            } else if (find_exif_tag("Exif.Pentax.CameraInfo") || find_exif_tag("Exif.PentaxDng.CameraInfo")) {
+                const long index = 4;
+                if (pos->count() >= index) {
+                    serial = validateUft8(pos->toString(index));
+                }
             }
+            // TODO: Serial number from tags not supported by Exiv2.
         }
 
-        if (num != -3) {
-            if ((denom == 1 && num >= 10000) || num < 0 || denom < 0) {
-                focus_dist = 10000;    // infinity
-            } else if (denom > 0) {
-                focus_dist = (float)num / denom;
+        if (find_tag(Exiv2::focalLength)) {
+            // This works around a bug in exiv2 the developers refuse to fix
+            // For details see http://dev.exiv2.org/issues/1083
+            if (pos->key() == "Exif.Canon.FocalLength" && pos->count() == 4) {
+                focal_len = pos->toFloat(1);
+            } else {
+                focal_len = pos->toFloat();
             }
         }
 
-        if ((tag = exif->getTag("ISOSpeedRatings"))) {
-            iso_speed = tag->toDouble();
+        if (find_exif_tag("Exif.Photo.FocalLengthIn35mmFilm")) {
+            focal_len35mm = pos->toFloat();
         }
 
-        if ((tag = exif->findTag("DateTimeOriginal", true))) {
-            if (sscanf((const char*)tag->getValue(), "%d:%d:%d %d:%d:%d", &time.tm_year, &time.tm_mon, &time.tm_mday, &time.tm_hour, &time.tm_min, &time.tm_sec) == 6) {
-                time.tm_year -= 1900;
-                time.tm_mon -= 1;
-                time.tm_isdst = -1;
-                timeStamp = mktime(&time);
-            }
+        if (find_tag(Exiv2::subjectDistance)) {
+            focus_dist = (0.01 * std::pow(10, pos->toFloat() / 40));
         }
 
-        tag = exif->findTag("SerialNumber");
-
-        if (!tag) {
-            tag = exif->findTag("InternalSerialNumber");
-        }
-
-        if (tag) {
-            serial = validateUft8(tag->valueToString());
+        if (find_tag(Exiv2::orientation)) {
+            static const std::vector<std::string> ormap = {
+                "Unknown",
+                "Horizontal (normal)",
+                "Mirror horizontal",
+                "Rotate 180",
+                "Mirror vertical",
+                "Mirror horizontal and rotate 270 CW",
+                "Rotate 90 CW",
+                "Mirror horizontal and rotate 90 CW",
+                "Rotate 270 CW",
+                "Unknown"
+            };
+            auto idx = to_long(pos);
+            if (idx >= 0 && idx < long(ormap.size())) {
+                orientation = ormap[idx];
+            }
+            //orientation = pos->print(&exif);
         }
 
-        // guess lens...
-        lens = "Unknown";
-
-        // Sometimes (e.g. DNG) EXIF already contains lens data
-
-        if (!make.compare(0, 8, "FUJIFILM")) {
-            if (exif->getTag("LensModel")) {
-                lens = validateUft8(exif->getTag("LensModel")->valueToString());
+        if (!make.compare(0, 5, "NIKON")) {
+            if (find_exif_tag("Exif.NikonLd4.LensID")) {
+                if (!to_long(pos)) { // No data, look in LensIDNumber.
+                    const auto p = pos;
+                    if (!find_exif_tag("Exif.NikonLd4.LensIDNumber")) {
+                        pos = p; // Tag not found, so reset pos.
+                    }
+                }
+                lens = pos->print(&exif);
+                if (lens == std::to_string(to_long(pos))) { // Not known to Exiv2.
+                    lens.clear();
+                } else {
+                    lens = validateUft8(lens);
+                }
             }
         } else if (!make.compare(0, 4, "SONY")) {
-            if (iso_speed == 65535 || iso_speed == 0) {
-                rtexif::Tag* isoTag = exif->getTag("RecommendedExposureIndex");
-
-                if (isoTag) {
-                    iso_speed = isoTag->toDouble();
+            // ExifTool prefers LensType2 over LensType (called
+            // Exif.Sony2.LensID by Exiv2). Exiv2 doesn't support LensType2 yet,
+            // so we let Exiv2 try it's best. For non ILCE/NEX cameras which
+            // likely don't have LensType2, we use Exif.Sony2.LensID because
+            // Exif.Photo.LensModel may be incorrect (see
+            // https://discuss.pixls.us/t/call-for-testing-rawtherapee-metadata-handling-with-exiv2-includes-cr3-support/36240/36).
+            if (
+                // Camera model is neither a ILCE, ILME, nor NEX.
+                (!find_exif_tag("Exif.Image.Model") ||
+                    (pos->toString().compare(0, 4, "ILCE") && pos->toString().compare(0, 4, "ILME") && pos->toString().compare(0, 3, "NEX"))) &&
+                // LensID exists. 0xFFFF could be one of many lenses.
+                find_exif_tag("Exif.Sony2.LensID") && to_long(pos) && to_long(pos) != 0xFFFF) {
+                lens = pos->print(&exif);
+                if (lens == std::to_string(to_long(pos))) { // Not known to Exiv2.
+                    lens.clear();
+                } else {
+                    lens = validateUft8(lens);
                 }
             }
         }
-
-        if (lens == "Unknown") {
-            const auto lens_from_make_and_model =
-                [this, exif]() -> bool
+        if (!lens.empty()) {
+            // Already found the lens name.
+        } else if (find_tag(Exiv2::lensName)) {
+            lens = validateUft8(pos->print(&exif));
+            auto p = pos;
+            if (find_exif_tag("Exif.CanonFi.RFLensType") && find_exif_tag("Exif.Canon.LensModel")) {
+                lens = validateUft8(pos->print(&exif));
+            } else if (p->count() == 1 && lens == std::to_string(to_long(p))) {
+                if (find_exif_tag("Exif.Canon.LensModel")) {
+                    lens = validateUft8(pos->print(&exif));
+                } else if (find_exif_tag("Exif.Photo.LensModel")) {
+                    lens = validateUft8(p->print(&exif));
+                }
+            }
+        } else if (find_exif_tag("Exif.Photo.LensSpecification") && pos->count() == 4) {
+            const auto round =
+                [](float f) -> float
                 {
-                    if (!exif) {
-                        return false;
-                    }
-
-                    const rtexif::Tag* const lens_model = exif->getTag(0xA434);
-
-                    if (lens_model) {
-                        const rtexif::Tag* const lens_make = exif->getTag(0xA433);
-                        const std::string make =
-                            lens_make
-                                ? validateUft8(lens_make->valueToString())
-                                : std::string();
-                        const std::string model = validateUft8(lens_model->valueToString());
-
-                        if (!model.empty()) {
-                            lens = make;
-
-                            if (!lens.empty()) {
-                                lens += ' ';
-                            }
-
-                            lens += model;
-
-                            return true;
-                        }
-                    }
-
-                    return false;
+                    return int(f * 10.f + 0.5f) / 10.f;
                 };
+            float fl_lo = round(pos->toFloat(0));
+            float fl_hi = round(pos->toFloat(1));
+            float fn_lo = round(pos->toFloat(2));
+            float fn_hi = round(pos->toFloat(3));
+            std::ostringstream buf;
+            buf << fl_lo;
+            if (fl_lo < fl_hi) {
+                buf << "-" << fl_hi;
+            }
+            buf << "mm F" << fn_lo;
+            if (fn_lo < fn_hi) {
+                buf << "-" << fn_hi;
+            }
+            lens = validateUft8(buf.str());
+        }
+        if (lens.empty() || lens.find_first_not_of('-') == std::string::npos) {
+            lens = "Unknown";
+        }
 
-            if (mnote) {
-
-                if (!make.compare(0, 5, "NIKON")) {
-                    // ISO at max value supported, check manufacturer specific
-                    if (iso_speed == 65535 || iso_speed == 0) {
-                        rtexif::Tag* isoTag = mnote->getTagP("ISOInfo/ISO");
-
-                        if (isoTag) {
-                            iso_speed = isoTag->toInt();
-                        }
-                    }
-
-                    bool lensOk = false;
-
-                    if (mnote->getTag("LensData")) {
-                        std::string ldata = validateUft8(mnote->getTag("LensData")->valueToString());
-                        size_t pos;
-
-                        if (ldata.size() > 10 && (pos = ldata.find("Lens = ")) != Glib::ustring::npos) {
-                            lens = ldata.substr(pos + 7);
-
-                            if (lens.compare(0, 7, "Unknown")) {
-                                lensOk = true;
-                            } else {
-                                size_t pos = lens.find("$FL$");        // is there a placeholder for focallength?
-
-                                if (pos != Glib::ustring::npos) {               // then fill in focallength
-                                    lens = lens.replace(pos, 4, validateUft8(exif->getTag("FocalLength")->valueToString()));
-
-                                    if (mnote->getTag("LensType")) {
-                                        const std::string ltype = validateUft8(mnote->getTag("LensType")->valueToString());
-
-                                        if (ltype.find("MF = Yes") != Glib::ustring::npos) { // check, whether it's a MF lens, should be always
-                                            lens = lens.replace(0, 7, "MF");
-                                        }
-
-                                        lensOk = true;
-                                    }
-                                }
-                            }
-                            // If MakeNotes are vague, fall back to Exif LensMake and LensModel if set
-                            // https://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Nikon.html#LensType
-                            if (lens == "Manual Lens No CPU") {
-                                lens_from_make_and_model();
-                            }
-                        }
-                    }
-
-                    if (!lensOk && mnote->getTag("Lens")) {
-                        const std::string ldata = validateUft8(mnote->getTag("Lens")->valueToString());
-                        size_t i = 0, j = 0;
-                        double n[4] = {0.0};
-
-                        for (int m = 0; m < 4; m++) {
-                            while (i < ldata.size() && ldata[i] != '/') {
-                                i++;
-                            }
-
-                            int nom = atoi(ldata.substr(j, i).c_str());
-                            j = i + 1;
-                            i++;
-
-                            while (i < ldata.size() && ldata[i] != ',') {
-                                i++;
-                            }
-
-                            int den = atoi(ldata.substr(j, i).c_str());
-                            j = i + 2;
-                            i += 2;
-                            n[m] = (double) nom / std::max(den, 1);
-                        }
-
-                        std::ostringstream str;
-
-                        if (n[0] == n[1]) {
-                            str << "Unknown " << n[0] << "mm F/" << n[2];
-                        } else if (n[2] == n[3]) {
-                            str << "Unknown " << n[0] << "-" << n[1] << "mm F/" << n[2];
-                        } else {
-                            str << "Unknown " << n[0] << "-" << n[1] << "mm F/" << n[2] << "-" << n[3];
-                        }
-
-                        lens = str.str();
-
-                        // Look whether it's MF or AF
-                        if (mnote->getTag("LensType")) {
-                            const std::string ltype = validateUft8(mnote->getTag("LensType")->valueToString());
-
-                            if (ltype.find("MF = Yes") != Glib::ustring::npos) { // check, whether it's a MF lens
-                                lens = lens.replace(0, 7, "MF");    // replace 'Unknwon' with 'MF'
-                            } else {
-                                lens = lens.replace(0, 7, "AF");    // replace 'Unknwon' with 'AF'
-                            }
-                        }
-                    }
-                } else if (!make.compare(0, 5, "Canon")) {
-                    // ISO at max value supported, check manufacturer specific
-                    if (iso_speed == 65535 || iso_speed == 0) {
-                        rtexif::Tag* baseIsoTag = mnote->getTagP("CanonShotInfo/BaseISO");
-
-                        if (baseIsoTag) {
-                            iso_speed = baseIsoTag->toInt();
-                        }
-                    }
-
-                    int found = false;
-                    // canon EXIF have a string for lens model
-                    rtexif::Tag *lt = mnote->getTag("LensType");
-
-                    if (lt) {
-                        if (lt->toInt()) {
-                            const std::string ldata = validateUft8(lt->valueToString());
-
-                            if (ldata.size() > 1) {
-                                found = true;
-                                lens = "Canon " + ldata;
-                            }
-                        } else {
-                            found = lens_from_make_and_model();
-                        }
-                    }
-
-                    const std::string::size_type first_space_pos = lens.find(' ');
-                    const std::string::size_type remaining_size =
-                        first_space_pos != std::string::npos
-                            ? lens.size() - first_space_pos
-                            : 0;
-
-                    if( !found || remaining_size < 7U ) {
-                        lt = mnote->findTag("LensID");
-
-                        if (lt) {
-                            const std::string ldata = validateUft8(lt->valueToString());
-
-                            if (ldata.size() > 1) {
-                                lens = ldata;
-                            }
-                        }
-                    }
-                } else if (!make.compare (0, 6, "PENTAX") || (!make.compare (0, 5, "RICOH") && !model.compare (0, 6, "PENTAX"))) {
-                    // ISO at max value supported, check manufacturer specific
-                    if (iso_speed == 65535 || iso_speed == 0) {
-                        const rtexif::Tag* const baseIsoTag = mnote->getTag("ISO");
-
-                        if (baseIsoTag) {
-                            const std::string isoData = baseIsoTag->valueToString();
-
-                            if (isoData.size() > 1) {
-                                iso_speed = std::stoi(isoData);
-                            }
-                        }
-                    }
-
-                    if (mnote->getTag("LensType")) {
-                        lens = validateUft8(mnote->getTag("LensType")->valueToString());
-                        // If MakeNotes are vague, fall back to Exif LensMake and LensModel if set
-                        // https://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Pentax.html#LensType
-                        if (lens == "M-42 or No Lens" || lens == "K or M Lens" || lens == "A Series Lens" || lens == "Sigma") {
-                            lens_from_make_and_model();
-                        }
-                    } else {
-                        lens_from_make_and_model();
-                    }
-
-                    // Try to get the FocalLength from the LensInfo structure, where length below 10mm will be correctly set
-                    rtexif::Tag* flt = mnote->getTagP("LensInfo/FocalLength");
+        std::string datetime_taken;
+        if (find_exif_tag("Exif.Image.DateTimeOriginal")) {
+            datetime_taken = pos->print(&exif);
+        }
+        else if (find_exif_tag("Exif.Photo.DateTimeOriginal")) {
+            datetime_taken = pos->print(&exif);
+        }
+        else if (find_exif_tag("Exif.Photo.DateTimeDigitized")) {
+            datetime_taken = pos->print(&exif);
+        } else if (find_exif_tag("Exif.Image.DateTime")) {
+            datetime_taken = validateUft8(pos->print(&exif));
+        }
+        if (sscanf(datetime_taken.c_str(), "%d:%d:%d %d:%d:%d", &time.tm_year, &time.tm_mon, &time.tm_mday, &time.tm_hour, &time.tm_min, &time.tm_sec) == 6) {
+            time.tm_year -= 1900;
+            time.tm_mon -= 1;
+            time.tm_isdst = -1;
+            timeStamp = mktime(&time);
+        }
 
-                    if (flt) {
-                        // Don't replace Exif focal_len if Makernotes focal_len is 0
-                        if (flt->toDouble() > 0) {
-                            focal_len = flt->toDouble();
-                        }
-                    } else if ((flt = mnote->getTagP ("FocalLength"))) {
-                        focal_len = mnote->getTag("FocalLength")->toDouble ();
-                    }
+        if (find_exif_tag("Exif.Image.ExposureBiasValue")) {
+            expcomp = pos->toFloat();
+        } else if (find_exif_tag("Exif.Photo.ExposureBiasValue")) {
+            expcomp = pos->toFloat();
+        }
 
-                    if (mnote->getTag("FocalLengthIn35mmFilm")) {
-                        focal_len35mm = mnote->getTag("FocalLengthIn35mmFilm")->toDouble();
-                    }
-                } else if (!make.compare (0, 4, "SONY") || !make.compare (0, 6, "KONICA")) {
-                    if (mnote->getTag ("LensID")) {
-                        lens = validateUft8(mnote->getTag("LensID")->valueToString());
-                        if (!lens.compare (0, 7, "Unknown")) {
-                            lens_from_make_and_model();
-                        }
-                    }
-                } else if (!make.compare(0, 7, "OLYMPUS")) {
-                    if (mnote->getTag("Equipment"))  {
-                        rtexif::TagDirectory* eq = mnote->getTag("Equipment")->getDirectory();
+        if (find_exif_tag("Exif.Image.Rating")) {
+            rating = to_long(pos);
+        } else {
+            auto it = meta.xmpData().findKey(Exiv2::XmpKey("Xmp.xmp.Rating"));
+            if (it != meta.xmpData().end() && it->size()) {
+                rating = to_long(it);
+            }
+        }
 
-                        if (eq->getTag("LensType")) {
-                            lens = validateUft8(eq->getTag("LensType")->valueToString());
-                        }
-                    }
-                    if (lens == "Unknown") {
-                        lens_from_make_and_model();
-                    }
-                } else if (!make.compare (0, 9, "Panasonic")) {
-                    if (mnote->getTag ("LensType")) {
-                        const std::string panalens = validateUft8(mnote->getTag("LensType")->valueToString());
-
-                        if (panalens.find("LUMIX") != Glib::ustring::npos) {
-                            lens = "Panasonic " + panalens;
-                        } else {
-                            lens = panalens;
-                        }
+        // try getting some metadata from ImageDescription
+        if (!make.compare(0, 5, "KODAK") && !getISOSpeed() && !getFNumber() && !getFocalLen() && !getShutterSpeed() &&
+            find_exif_tag("Exif.Image.ImageDescription")) {
+            std::string s = pos->toString();
+            std::string line;
+            std::smatch m;
+            const auto d =
+                [&m]() -> double {
+                    std::string s = m[1];
+                    return atof(s.c_str());
+                };
+            while (true) {
+                auto p = s.find('\r');
+                if (p == std::string::npos) {
+                    break;
+                }
+                auto line = s.substr(0, p);
+                s = s.substr(p+1);
+
+                if (std::regex_match(line, m, std::regex("ISO: +([0-9]+) *"))) {
+                    iso_speed = d();
+                } else if (std::regex_match(line, m, std::regex("Aperture: +F([0-9.]+) *"))) {
+                    aperture = d();
+                } else if (std::regex_match(line, m, std::regex("Shutter: +([0-9.]+) *"))) {
+                    shutter = d();
+                    if (shutter) {
+                        shutter = 1.0/shutter;
                     }
+                } else if (std::regex_match(line, m, std::regex("Lens \\(mm\\): +([0-9.]+) *"))) {
+                    focal_len = d();
+                } else if (std::regex_match(line, m, std::regex("Exp Comp: +([0-9.]+) *"))) {
+                    expcomp = d();
                 }
-            } else if (exif->getTag("DNGLensInfo")) {
-                lens = validateUft8(exif->getTag("DNGLensInfo")->valueToString());
-            } else if (!lens_from_make_and_model() && exif->getTag ("LensInfo")) {
-                lens = validateUft8(exif->getTag("LensInfo")->valueToString());
             }
         }
-    }
 
-    rtexif::Tag* t = newFrameRootDir->getTag(0x83BB);
-
-    if (t) {
-        iptc = iptc_data_new_from_data((unsigned char*)t->getValue(), (unsigned)t->getValueSize());
-    }
-
-
-    // -----------------------  Special file type detection (HDR, PixelShift) ------------------------
-
-
-    uint16 bitspersample = 0, samplesperpixel = 0, sampleformat = 0, photometric = 0, compression = 0;
-    const rtexif::Tag* const bps = frameRootDir->findTag("BitsPerSample");
-    const rtexif::Tag* const spp = frameRootDir->findTag("SamplesPerPixel");
-    const rtexif::Tag* const sf = frameRootDir->findTag("SampleFormat");
-    const rtexif::Tag* const pi = frameRootDir->findTag("PhotometricInterpretation");
-    const rtexif::Tag* const c = frameRootDir->findTag("Compression");
-
-    if (mnote && (!make.compare(0, 6, "PENTAX") || (!make.compare(0, 5, "RICOH") && !model.compare(0, 6, "PENTAX")))) {
-        const rtexif::Tag* const hdr = mnote->findTag("HDR");
-
-        if (hdr) {
-            if (hdr->toInt() > 0) {
-                isHDR = true;
-#if PRINT_HDR_PS_DETECTION
-                printf("HDR detected ! -> \"HDR\" tag found\n");
-#endif
-            }
-        } else {
-            const rtexif::Tag* const dm = mnote->findTag("DriveMode");
+        meta.getDimensions(w_, h_);
 
-            if (dm) {
-                char buffer[60];
-                dm->toString(buffer, 3);
-                buffer[3] = 0;
+        // -----------------------
+        // Special file type detection (HDR, PixelShift)
+        // ------------------------
+        uint16 bitspersample = 0, samplesperpixel = 0, sampleformat = 0, photometric = 0, compression = 0;
+        const auto bps = exif.findKey(Exiv2::ExifKey("Exif.Image.BitsPerSample"));
+        const auto spp = exif.findKey(Exiv2::ExifKey("Exif.Image.SamplesPerPixel"));
+        const auto sf = exif.findKey(Exiv2::ExifKey("Exif.Image.SampleFormat"));
+        const auto pi = exif.findKey(Exiv2::ExifKey("Exif.Image.PhotometricInterpretation"));
+        const auto c = exif.findKey(Exiv2::ExifKey("Exif.Image.Compression"));
 
-                if (!strcmp(buffer, "HDR")) {
+        if (
+            !make.compare(0, 6, "PENTAX")
+            || (
+                !make.compare(0, 5, "RICOH")
+                && !model.compare (0, 6, "PENTAX")
+            )
+        ) {
+            if (find_exif_tag("Exif.Pentax.DriveMode")) {
+                std::string buf = pos->toString(3);
+                if (buf == "HDR") {
                     isHDR = true;
 #if PRINT_HDR_PS_DETECTION
                     printf("HDR detected ! -> DriveMode = \"HDR\"\n");
 #endif
                 }
             }
-        }
 
-        if (!isHDR) {
-            const rtexif::Tag* const q = mnote->findTag("Quality");
-            if (q && (q->toInt() == 7 || q->toInt() == 8)) {
+            if (
+                !isHDR
+                && (
+                    find_exif_tag("Exif.Pentax.Quality")
+                    || find_exif_tag("Exif.PentaxDng.Quality")
+                )
+                && (
+                    to_long(pos) == 7
+                    || to_long(pos) == 8
+                )
+            ) {
                 isPixelShift = true;
 #if PRINT_HDR_PS_DETECTION
                 printf("PixelShift detected ! -> \"Quality\" = 7\n");
 #endif
             }
         }
-    }
-
-    sampleFormat = IIOSF_UNKNOWN;
-
-    if (!sf)
-        /*
-         * WARNING: This is a dirty hack!
-         * We assume that files which doesn't contain the TIFFTAG_SAMPLEFORMAT tag
-         * (which is the case with uncompressed TIFFs produced by RT!) are RGB files,
-         * but that may be not true.   --- Hombre
-         */
-    {
-        sampleformat = SAMPLEFORMAT_UINT;
-    } else {
-        sampleformat = sf->toInt();
-    }
-
-    if (
-        !bps
-        || !spp
-        || !pi
-    ) {
-        return;
-    }
 
-    bitspersample = bps->toInt();
-    samplesperpixel = spp->toInt();
+        if (make == "SONY") {
+            if (find_exif_tag("Exif.SubImage1.BitsPerSample") && to_long(pos) == 14) {
+                if (find_exif_tag("Exif.SubImage1.SamplesPerPixel") && to_long(pos) == 4 &&
+                    find_exif_tag("Exif.SubImage1.PhotometricInterpretation") && to_long(pos) == 32892 &&
+                    find_exif_tag("Exif.SubImage1.Compression") && to_long(pos) == 1) {
+                    isPixelShift = true;
+                }
+            } else if (bps != exif.end() && to_long(bps) == 14 &&
+                       spp != exif.end() && to_long(spp) == 4 &&
+                       c != exif.end() && to_long(c) == 1 &&
+                       find_exif_tag("Exif.Image.Software") &&
+                       pos->toString() == "make_arq") {
+                isPixelShift = true;
+            }
+        } else if (make == "FUJIFILM") {
+            if (bps != exif.end() && to_long(bps) == 16 &&
+                spp != exif.end() && to_long(spp) == 4 &&
+                c != exif.end() && to_long(c) == 1 &&
+                find_exif_tag("Exif.Image.Software") &&
+                pos->toString() == "make_arq") {
+                isPixelShift = true;
+            }
+        }
 
-    photometric = pi->toInt();
+        sampleFormat = IIOSF_UNKNOWN;
 
-    if (photometric == PHOTOMETRIC_LOGLUV) {
-        if (!c) {
-            compression = COMPRESSION_NONE;
+        if (sf == exif.end())
+            /*
+             * WARNING: This is a dirty hack!
+             * We assume that files which doesn't contain the TIFFTAG_SAMPLEFORMAT tag
+             * (which is the case with uncompressed TIFFs produced by RT!) are RGB files,
+             * but that may be not true.   --- Hombre
+             */
+        {
+            sampleformat = SAMPLEFORMAT_UINT;
         } else {
-            compression = c->toInt();
+            sampleformat = to_long(sf);
+        }
+
+        if (bps == exif.end() || spp == exif.end() || pi == exif.end()) {
+            return;
         }
-    }
 
-    if (photometric == PHOTOMETRIC_RGB || photometric == PHOTOMETRIC_MINISBLACK) {
-        if (sampleformat == SAMPLEFORMAT_INT || sampleformat == SAMPLEFORMAT_UINT) {
-            if (bitspersample == 8) {
-                sampleFormat = IIOSF_UNSIGNED_CHAR;
-            } else if (bitspersample <= 16) {
-                sampleFormat = IIOSF_UNSIGNED_SHORT;
+        bitspersample = to_long(bps);
+        samplesperpixel = to_long(spp);
+
+        photometric = to_long(pi);
+        if (photometric == PHOTOMETRIC_LOGLUV) {
+            if (c == exif.end()) {
+                compression = COMPRESSION_NONE;
+            } else {
+                compression = to_long(c);
             }
-        } else if (sampleformat == SAMPLEFORMAT_IEEEFP) {
-            if (bitspersample==16) {
-                sampleFormat = IIOSF_FLOAT16;
-                isHDR = true;
+        }
+
+        if (photometric == PHOTOMETRIC_RGB || photometric == PHOTOMETRIC_MINISBLACK) {
+            if (sampleformat == SAMPLEFORMAT_INT || sampleformat == SAMPLEFORMAT_UINT) {
+                if (bitspersample == 8) {
+                    sampleFormat = IIOSF_UNSIGNED_CHAR;
+                } else if (bitspersample <= 16) {
+                    sampleFormat = IIOSF_UNSIGNED_SHORT;
+                }
+            } else if (sampleformat == SAMPLEFORMAT_IEEEFP) {
+                if (bitspersample==16) {
+                    sampleFormat = IIOSF_FLOAT16;
+                    isHDR = true;
 #if PRINT_HDR_PS_DETECTION
-                printf("HDR detected ! -> sampleFormat = %d   (16-bit)\n", sampleFormat);
+                    printf("HDR detected ! -> sampleFormat = %d   (16-bit)\n", sampleFormat);
 #endif
-            }
-            else if (bitspersample == 24) {
-                sampleFormat = IIOSF_FLOAT24;
-                isHDR = true;
+                }
+                else if (bitspersample == 24) {
+                    sampleFormat = IIOSF_FLOAT24;
+                    isHDR = true;
 #if PRINT_HDR_PS_DETECTION
-                printf("HDR detected ! -> sampleFormat = %d   (24-bit)\n", sampleFormat);
+                    printf("HDR detected ! -> sampleFormat = %d   (24-bit)\n", sampleFormat);
 #endif
-            }
-            else if (bitspersample == 32) {
-                sampleFormat = IIOSF_FLOAT32;
-                isHDR = true;
+                }
+                else if (bitspersample == 32) {
+                    sampleFormat = IIOSF_FLOAT32;
+                    isHDR = true;
 #if PRINT_HDR_PS_DETECTION
-                printf("HDR detected ! -> sampleFormat = %d   (32-bit)\n", sampleFormat);
+                    printf("HDR detected ! -> sampleFormat = %d   (32-bit)\n", sampleFormat);
 #endif
+                }
             }
-        }
-    } else if (photometric == PHOTOMETRIC_CFA) {
-        if (sampleformat == SAMPLEFORMAT_IEEEFP) {
-            if (bitspersample == 16) {
-                sampleFormat = IIOSF_FLOAT16;
-                isHDR = true;
+        } else if (photometric == PHOTOMETRIC_CFA) {
+            if (sampleformat == SAMPLEFORMAT_IEEEFP) {
+                if (bitspersample == 16) {
+                    sampleFormat = IIOSF_FLOAT16;
+                    isHDR = true;
 #if PRINT_HDR_PS_DETECTION
-                printf("HDR detected ! -> sampleFormat = %d   (16-bit)\n", sampleFormat);
+                    printf("HDR detected ! -> sampleFormat = %d   (16-bit)\n", sampleFormat);
 #endif
-            }
-            else if (bitspersample == 24) {
-                sampleFormat = IIOSF_FLOAT24;
-                isHDR = true;
+                }
+                else if (bitspersample == 24) {
+                    sampleFormat = IIOSF_FLOAT24;
+                    isHDR = true;
 #if PRINT_HDR_PS_DETECTION
-                printf("HDR detected ! -> sampleFormat = %d   (24-bit)\n", sampleFormat);
+                    printf("HDR detected ! -> sampleFormat = %d   (24-bit)\n", sampleFormat);
 #endif
-            }
-            else if (bitspersample == 32) {
-                sampleFormat = IIOSF_FLOAT32;
-                isHDR = true;
+                }
+                else if (bitspersample == 32) {
+                    sampleFormat = IIOSF_FLOAT32;
+                    isHDR = true;
 #if PRINT_HDR_PS_DETECTION
-                printf("HDR detected ! -> sampleFormat = %d   (32-bit)\n", sampleFormat);
+                    printf("HDR detected ! -> sampleFormat = %d   (32-bit)\n", sampleFormat);
 #endif
+                }
+            } else if (sampleformat == SAMPLEFORMAT_INT || sampleformat == SAMPLEFORMAT_UINT) {
+                if (bitspersample == 8) {   // shouldn't occur...
+                    sampleFormat = IIOSF_UNSIGNED_CHAR;
+                } else if (bitspersample <= 16) {
+                    sampleFormat = IIOSF_UNSIGNED_SHORT;
+                }
             }
-        } else if (sampleformat == SAMPLEFORMAT_INT || sampleformat == SAMPLEFORMAT_UINT) {
-            if (bitspersample == 8) {   // shouldn't occur...
-                sampleFormat = IIOSF_UNSIGNED_CHAR;
-            } else if (bitspersample <= 16) {
-                sampleFormat = IIOSF_UNSIGNED_SHORT;
-            }
-        }
-    } else if (photometric == 34892 || photometric == 32892  /* Linear RAW (see DNG spec ; 32892 seem to be a flaw from Sony's ARQ files) */) {
-        if (sampleformat == SAMPLEFORMAT_IEEEFP) {
-            sampleFormat = IIOSF_FLOAT32;
-            isHDR = true;
+        } else if (photometric == 34892 || photometric == 32892  /* Linear RAW (see DNG spec ; 32892 seem to be a flaw from Sony's ARQ files) */) {
+            if (sampleformat == SAMPLEFORMAT_IEEEFP) {
+                sampleFormat = IIOSF_FLOAT32;
+                isHDR = true;
 #if PRINT_HDR_PS_DETECTION
-            printf("HDR detected ! -> sampleFormat = %d\n", sampleFormat);
+                printf("HDR detected ! -> sampleFormat = %d\n", sampleFormat);
 #endif
-        } else if (sampleformat == SAMPLEFORMAT_INT || sampleformat == SAMPLEFORMAT_UINT) {
-            if (bitspersample == 8) {   // shouldn't occur...
-                sampleFormat = IIOSF_UNSIGNED_CHAR;
-            } else if (bitspersample <= 16) {
-                sampleFormat = IIOSF_UNSIGNED_SHORT;
-
-                if (mnote && (!make.compare(0, 4, "SONY")) && bitspersample >= 12 && samplesperpixel == 4) {
-                    isPixelShift = true;
+            } else if (sampleformat == SAMPLEFORMAT_INT || sampleformat == SAMPLEFORMAT_UINT) {
+                if (bitspersample == 8) {   // shouldn't occur...
+                    sampleFormat = IIOSF_UNSIGNED_CHAR;
+                } else if (bitspersample <= 16) {
+                    sampleFormat = IIOSF_UNSIGNED_SHORT;
+                    if (find_exif_tag("Exif.Photo.MakerNote") && (!make.compare (0, 4, "SONY")) && bitspersample >= 12 && samplesperpixel == 4) {
+                        isPixelShift = true;
 #if PRINT_HDR_PS_DETECTION
-                    printf("PixelShift detected ! -> \"Make\" = SONY, bitsPerPixel > 8, samplesPerPixel == 4\n");
+                        printf("PixelShift detected ! -> \"Make\" = SONY, bitsPerPixel > 8, samplesPerPixel == 4\n");
 #endif
+                    }
                 }
             }
-        }
-    } else if (photometric == PHOTOMETRIC_LOGLUV) {
-        if (compression == COMPRESSION_SGILOG24) {
-            sampleFormat = IIOSF_LOGLUV24;
-            isHDR = true;
+        } else if (photometric == PHOTOMETRIC_LOGLUV) {
+            if (compression == COMPRESSION_SGILOG24) {
+                sampleFormat = IIOSF_LOGLUV24;
+                isHDR = true;
 #if PRINT_HDR_PS_DETECTION
-            printf("HDR detected ! -> sampleFormat = %d\n", sampleFormat);
+                printf("HDR detected ! -> sampleFormat = %d\n", sampleFormat);
 #endif
-        } else if (compression == COMPRESSION_SGILOG) {
-            sampleFormat = IIOSF_LOGLUV32;
-            isHDR = true;
+            } else if (compression == COMPRESSION_SGILOG) {
+                sampleFormat = IIOSF_LOGLUV32;
+                isHDR = true;
 #if PRINT_HDR_PS_DETECTION
-            printf("HDR detected ! -> sampleFormat = %d\n", sampleFormat);
+                printf("HDR detected ! -> sampleFormat = %d\n", sampleFormat);
 #endif
+            }
         }
-    }
-}
-
-FrameData::~FrameData()
-{
-
-    if (iptc) {
-        iptc_data_free(iptc);
-    }
-}
-
-procparams::IPTCPairs FrameData::getIPTCData() const
-{
-    return getIPTCData(iptc);
-}
-
-procparams::IPTCPairs FrameData::getIPTCData(IptcData* iptc_)
-{
-
-    procparams::IPTCPairs iptcc;
-
-    if (!iptc_) {
-        return iptcc;
-    }
-
-    unsigned char buffer[2100];
-
-    for (int i = 0; i < 16; i++) {
-        IptcDataSet* ds = iptc_data_get_next_dataset(iptc_, nullptr, IPTC_RECORD_APP_2, strTags[i].tag);
-
-        if (ds) {
-            iptc_dataset_get_data(ds, buffer, 2100);
-            std::vector<Glib::ustring> icValues;
-            icValues.push_back(to_utf8((char*)buffer));
-
-            iptcc[strTags[i].field] = icValues;
-            iptc_dataset_unref(ds);
+    } catch (const std::exception& e) {
+        if (settings->verbose) {
+            std::cerr << "EXIV2 ERROR: " << e.what() << std::endl;
         }
+        ok_ = false;
     }
-
-    IptcDataSet* ds = nullptr;
-    std::vector<Glib::ustring> keywords;
-
-    while ((ds = iptc_data_get_next_dataset(iptc_, ds, IPTC_RECORD_APP_2, IPTC_TAG_KEYWORDS))) {
-        iptc_dataset_get_data(ds, buffer, 2100);
-        keywords.push_back(to_utf8((char*)buffer));
-    }
-
-    iptcc["Keywords"] = keywords;
-    ds = nullptr;
-    std::vector<Glib::ustring> suppCategories;
-
-    while ((ds = iptc_data_get_next_dataset(iptc_, ds, IPTC_RECORD_APP_2, IPTC_TAG_SUPPL_CATEGORY))) {
-        iptc_dataset_get_data(ds, buffer, 2100);
-        suppCategories.push_back(to_utf8((char*)buffer));
-        iptc_dataset_unref(ds);
-    }
-
-    iptcc["SupplementalCategories"] = suppCategories;
-    return iptcc;
 }
 
-
-bool FrameData::getPixelShift() const
+bool FramesData::getPixelShift() const
 {
     return isPixelShift;
 }
-bool FrameData::getHDR() const
+
+bool FramesData::getHDR() const
 {
     return isHDR;
 }
-std::string FrameData::getImageType () const
+
+std::string FramesData::getImageType() const
 {
     return isPixelShift ? "PS" : isHDR ? "HDR" : "STD";
 }
-IIOSampleFormat FrameData::getSampleFormat() const
+
+IIOSampleFormat FramesData::getSampleFormat() const
 {
     return sampleFormat;
 }
-rtexif::TagDirectory* FrameData::getExifData() const
-{
-    return frameRootDir;
-}
-bool FrameData::hasExif() const
-{
-    return frameRootDir && frameRootDir->getCount();
-}
-bool FrameData::hasIPTC() const
-{
-    return iptc;
-}
-tm FrameData::getDateTime() const
-{
-    return time;
-}
-time_t FrameData::getDateTimeAsTS() const
-{
-    return timeStamp;
-}
-int FrameData::getISOSpeed() const
-{
-    return iso_speed;
-}
-double FrameData::getFNumber() const
-{
-    return aperture;
-}
-double FrameData::getFocalLen() const
-{
-    return focal_len;
-}
-double FrameData::getFocalLen35mm() const
-{
-    return focal_len35mm;
-}
-float FrameData::getFocusDist() const
-{
-    return focus_dist;
-}
-double FrameData::getShutterSpeed() const
-{
-    return shutter;
-}
-double FrameData::getExpComp() const
-{
-    return expcomp;
-}
-std::string FrameData::getMake() const
-{
-    return make;
-}
-std::string FrameData::getModel() const
-{
-    return model;
-}
-std::string FrameData::getLens() const
-{
-    return lens;
-}
-std::string FrameData::getSerialNumber() const
-{
-    return serial;
-}
-std::string FrameData::getOrientation() const
-{
-    return orientation;
-}
 
-int FrameData::getRating () const
+bool FramesData::hasExif() const
 {
-    return rating;
+    return ok_;
 }
 
-
-
-void FramesData::setDCRawFrameCount(unsigned int frameCount)
+tm FramesData::getDateTime() const
 {
-    dcrawFrameCount = frameCount;
+    return time;
 }
 
-unsigned int FramesData::getRootCount() const
+time_t FramesData::getDateTimeAsTS() const
 {
-    return roots.size();
+    return timeStamp;
 }
 
-unsigned int FramesData::getFrameCount() const
+int FramesData::getISOSpeed() const
 {
-    return dcrawFrameCount ? dcrawFrameCount : frames.size();
+    return iso_speed;
 }
 
-bool FramesData::getPixelShift () const
+double FramesData::getFNumber() const
 {
-    // So far only Pentax and Sony provide multi-frame Pixel Shift files.
-    // Only the first frame contains the Pixel Shift tag
-    // If more brand have to be supported, this rule may need
-    // to evolve
-
-    return frames.empty() ? false : frames.at(0)->getPixelShift ();
-}
-bool FramesData::getHDR(unsigned int frame) const
-{
-    // So far only Pentax provides multi-frame HDR file.
-    // Only the first frame contains the HDR tag
-    // If more brand have to be supported, this rule may need
-    // to evolve
-
-    return frames.empty() || frame >= frames.size()  ? false : frames.at(0)->getHDR();
+    return aperture;
 }
 
-std::string FramesData::getImageType (unsigned int frame) const
+double FramesData::getFocalLen() const
 {
-    return frames.empty() || frame >= frames.size() ? "STD" : frames.at(0)->getImageType();
+    return focal_len;
 }
 
-IIOSampleFormat FramesData::getSampleFormat(unsigned int frame) const
+double FramesData::getFocalLen35mm() const
 {
-    return frames.empty() || frame >= frames.size()  ? IIOSF_UNKNOWN : frames.at(frame)->getSampleFormat();
+    return focal_len35mm;
 }
 
-rtexif::TagDirectory* FramesData::getFrameExifData(unsigned int frame) const
+float FramesData::getFocusDist() const
 {
-    return frames.empty() || frame >= frames.size()  ? nullptr : frames.at(frame)->getExifData();
+    return focus_dist;
 }
 
-rtexif::TagDirectory* FramesData::getBestExifData(ImageSource *imgSource, procparams::RAWParams *rawParams) const
-{
-    rtexif::TagDirectory *td = nullptr;
 
-    if (frames.empty()) {
-        return nullptr;
-    }
-
-    if (imgSource && rawParams) {
-        eSensorType sensorType = imgSource->getSensorType();
-        unsigned int imgNum = 0;
-
-        if (sensorType == ST_BAYER) {
-            imgNum = rtengine::LIM<unsigned int>(rawParams->bayersensor.imageNum, 0, frames.size() - 1);
-            /*
-            // might exist someday ?
-            } else if (sensorType == ST_FUJI_XTRANS) {
-                imgNum = rtengine::LIM<unsigned int>(rawParams->xtranssensor.imageNum, 0, frames.size() - 1);
-            } else if (sensorType == ST_NONE && !imgSource->isRAW()) {
-                // standard image multiframe support should come here (when implemented in GUI)
-            */
-        }
-
-        td = getFrameExifData(imgNum);
-        rtexif::Tag* makeTag;
-
-        if (td && (makeTag = td->findTag("Make", true))) {
-            td = makeTag->getParent();
-        } else {
-            td = getRootExifData(0);
-        }
-    }
-
-    return td;
-}
-
-rtexif::TagDirectory* FramesData::getRootExifData(unsigned int root) const
+double FramesData::getShutterSpeed() const
 {
-    return roots.empty() || root >= roots.size()  ? nullptr : roots.at(root);
+    return shutter;
 }
 
-procparams::IPTCPairs FramesData::getIPTCData(unsigned int frame) const
-{
-    if (frame < frames.size() && frames.at(frame)->hasIPTC()) {
-        return frames.at(frame)->getIPTCData();
-    } else {
-        if (iptc) {
-            return FrameData::getIPTCData(iptc);
-        } else {
-            procparams::IPTCPairs emptyPairs;
-            return emptyPairs;
-        }
-    }
-}
 
-bool FramesData::hasExif(unsigned int frame) const
+double FramesData::getExpComp() const
 {
-    return getFromFrame<bool>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.hasExif();
-        }
-    );
+    return expcomp;
 }
 
-bool FramesData::hasIPTC(unsigned int frame) const
-{
-    return getFromFrame<bool>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.hasIPTC();
-        }
-    );
-}
 
-tm FramesData::getDateTime(unsigned int frame) const
+std::string FramesData::getMake() const
 {
-    return getFromFrame<tm>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.getDateTime();
-        },
-        modTime
-    );
+    return make;
 }
 
-time_t FramesData::getDateTimeAsTS(unsigned int frame) const
-{
-    return getFromFrame<time_t>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.getDateTimeAsTS();
-        },
-        modTimeStamp
-    );
-}
 
-int FramesData::getISOSpeed(unsigned int frame) const
+std::string FramesData::getModel() const
 {
-    return getFromFrame<int>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.getISOSpeed();
-        }
-    );
+    return model;
 }
 
-double FramesData::getFNumber(unsigned int frame) const
-{
-    return getFromFrame<double>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.getFNumber();
-        }
-    );
-}
 
-double FramesData::getFocalLen(unsigned int frame) const
+std::string FramesData::getLens() const
 {
-    return getFromFrame<double>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.getFocalLen();
-        }
-    );
+    return lens;
 }
 
-double FramesData::getFocalLen35mm(unsigned int frame) const
-{
-    return getFromFrame<double>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.getFocalLen35mm();
-        }
-    );
-}
 
-float FramesData::getFocusDist(unsigned int frame) const
+std::string FramesData::getSerialNumber() const
 {
-    return getFromFrame<float>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.getFocusDist();
-        }
-    );
+    return serial;
 }
 
-double FramesData::getShutterSpeed(unsigned int frame) const
-{
-    return getFromFrame<double>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.getShutterSpeed();
-        }
-    );
-}
 
-double FramesData::getExpComp(unsigned int frame) const
+std::string FramesData::getOrientation() const
 {
-    return getFromFrame<double>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.getExpComp();
-        }
-    );
+    return orientation;
 }
 
-std::string FramesData::getMake(unsigned int frame) const
-{
-    return getFromFrame<std::string>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.getMake();
-        }
-    );
-}
 
-std::string FramesData::getModel(unsigned int frame) const
+void FramesData::setDCRawFrameCount(unsigned int frameCount)
 {
-    return getFromFrame<std::string>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.getModel();
-        }
-    );
+    dcrawFrameCount = frameCount;
 }
 
-std::string FramesData::getLens(unsigned int frame) const
+unsigned int FramesData::getFrameCount() const
 {
-    return getFromFrame<std::string>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.getLens();
-        }
-    );
+    return std::max(1U, dcrawFrameCount);
 }
 
-std::string FramesData::getSerialNumber(unsigned int frame) const
-{
-    return getFromFrame<std::string>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.getSerialNumber();
-        }
-    );
-}
 
-std::string FramesData::getOrientation(unsigned int frame) const
+Glib::ustring FramesData::getFileName() const
 {
-    return getFromFrame<std::string>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.getOrientation();
-        }
-    );
+    return fname_;
 }
 
-int FramesData::getRating(unsigned int frame) const
+
+int FramesData::getRating() const
 {
-    return getFromFrame<int>(
-        frames,
-        frame,
-        [](const FrameData& frame_data)
-        {
-            return frame_data.getRating();
-        }
-    );
+    return rating;
 }
 
 //------inherited functions--------------//
 
 std::string FramesMetaData::apertureToString(double aperture)
 {
-
+	// TODO: Replace sprintf()
     char buffer[256];
     snprintf(buffer, sizeof(buffer), "%0.1f", aperture);
     return buffer;
@@ -1266,11 +820,12 @@ std::string FramesMetaData::apertureToString(double aperture)
 
 std::string FramesMetaData::shutterToString(double shutter)
 {
-
     char buffer[256];
 
     if (shutter > 0.0 && shutter <= 0.5) {
         snprintf(buffer, sizeof(buffer), "1/%0.0f", 1.0 / shutter);
+    } else if (int(shutter) == shutter) {
+        snprintf(buffer, sizeof(buffer), "%d", int(shutter));
     } else {
         snprintf(buffer, sizeof(buffer), "%0.1f", shutter);
     }
@@ -1298,181 +853,79 @@ std::string FramesMetaData::expcompToString(double expcomp, bool maskZeroexpcomp
 
 double FramesMetaData::shutterFromString(std::string s)
 {
-
-    size_t i = s.find_first_of('/');
+    const std::string::size_type i = s.find_first_of('/');
 
     if (i == std::string::npos) {
-        return atof(s.c_str());
+        return std::atof(s.c_str());
     } else {
-        return atof(s.substr(0, i).c_str()) / atof(s.substr(i + 1).c_str());
+        const double denominator = std::atof(s.substr(i + 1).c_str());
+        return
+            denominator
+                ? std::atof(s.substr(0, i).c_str()) / denominator
+                : 0.0;
     }
 }
 
 double FramesMetaData::apertureFromString(std::string s)
 {
 
-    return atof(s.c_str());
+    return std::atof(s.c_str());
 }
 
-extern "C" {
-
-#include <libiptcdata/iptc-data.h>
-#include <libiptcdata/iptc-jpeg.h>
-
-    struct _IptcDataPrivate {
-        unsigned int ref_count;
-
-        IptcLog *log;
-        IptcMem *mem;
-    };
-
-    IptcData *
-    iptc_data_new_from_jpeg_file(FILE *infile)
-    {
-        IptcData *d;
-        unsigned char * buf;
-        int buf_len = 256 * 256;
-        int len, offset;
-        unsigned int iptc_len;
-
-        if (!infile) {
-            return nullptr;
-        }
-
-        d = iptc_data_new();
-
-        if (!d) {
-            return nullptr;
-        }
 
-        buf = (unsigned char*)iptc_mem_alloc(d->priv->mem, buf_len);
+namespace {
 
-        if (!buf) {
-            iptc_data_unref(d);
-            return nullptr;
-        }
-
-        len = iptc_jpeg_read_ps3(infile, buf, buf_len);
-
-        if (len <= 0) {
-            goto failure;
-        }
-
-        offset = iptc_jpeg_ps3_find_iptc(buf, len, &iptc_len);
-
-        if (offset <= 0) {
-            goto failure;
+template<class T>
+void set_exif(Exiv2::ExifData &exif, const std::string &key, T val)
+{
+    try {
+        exif[key] = val;
+    } catch (std::exception &exc) {
+        if (settings->verbose) {
+            std::cout << "Exif -- error setting " << key << " to " << val << ": " << exc.what() << std::endl;
         }
-
-        iptc_data_load(d, buf + offset, iptc_len);
-
-        iptc_mem_free(d->priv->mem, buf);
-        return d;
-
-failure:
-        iptc_mem_free(d->priv->mem, buf);
-        iptc_data_unref(d);
-        return nullptr;
     }
-
 }
 
-FramesData::FramesData(const Glib::ustring& fname, std::unique_ptr<RawMetaDataLocation> rml, bool firstFrameOnly) :
-    iptc(nullptr), dcrawFrameCount(0)
-{
-    GStatBuf statbuf = {};
-    g_stat(fname.c_str(), &statbuf);
-    modTimeStamp = statbuf.st_mtime;
-    modTime = timeFromTS(modTimeStamp);
-
-    if (rml && (rml->exifBase >= 0 || rml->ciffBase >= 0)) {
-        FILE* f = g_fopen(fname.c_str(), "rb");
-
-        if (f) {
-            rtexif::ExifManager exifManager(f, std::move(rml), firstFrameOnly);
-            if (exifManager.f && exifManager.rml) {
-                if (exifManager.rml->exifBase >= 0) {
-                    exifManager.parseRaw ();
-                } else if (exifManager.rml->ciffBase >= 0) {
-                    exifManager.parseCIFF ();
-                }
-            }
-
-            // copying roots
-            roots = exifManager.roots;
-
-            // creating FrameData
-            for (auto currFrame : exifManager.frames) {
-                frames.push_back(std::unique_ptr<FrameData>(new FrameData(currFrame, currFrame->getRoot(), roots.at(0), modTimeStamp)));
-            }
-
-            for (auto currRoot : roots) {
-                rtexif::Tag* t = currRoot->getTag(0x83BB);
-
-                if (t && !iptc) {
-                    iptc = iptc_data_new_from_data ((unsigned char*)t->getValue (), (unsigned)t->getValueSize ());
-                    break;
-                }
-            }
-
+} // namespace
 
-            fclose(f);
-        }
-    } else if (hasJpegExtension(fname)) {
-        FILE* f = g_fopen(fname.c_str(), "rb");
-
-        if (f) {
-            rtexif::ExifManager exifManager(f, std::move(rml), true);
-
-            if (exifManager.f) {
-                exifManager.parseJPEG();
-                roots = exifManager.roots;
-
-                for (auto currFrame : exifManager.frames) {
-                    frames.push_back(std::unique_ptr<FrameData>(new FrameData(currFrame, currFrame->getRoot(), roots.at(0), modTimeStamp)));
-                }
-
-                rewind(exifManager.f);  // Not sure this is necessary
-                iptc = iptc_data_new_from_jpeg_file(exifManager.f);
-            }
-
-            fclose(f);
-        }
-    } else if (hasTiffExtension(fname)) {
-        FILE* f = g_fopen(fname.c_str(), "rb");
-
-        if (f) {
-            rtexif::ExifManager exifManager(f, std::move(rml), firstFrameOnly);
-
-            exifManager.parseTIFF();
-            roots = exifManager.roots;
-
-            // creating FrameData
-            for (auto currFrame : exifManager.frames) {
-                frames.push_back(std::unique_ptr<FrameData>(new FrameData(currFrame, currFrame->getRoot(), roots.at(0), modTimeStamp)));
-            }
-
-            for (auto currRoot : roots) {
-                rtexif::Tag* t = currRoot->getTag(0x83BB);
-
-                if (t && !iptc) {
-                    iptc = iptc_data_new_from_data((unsigned char*)t->getValue(), (unsigned)t->getValueSize());
-                    break;
-                }
-            }
-
-            fclose(f);
-        }
+void FramesData::fillBasicTags(Exiv2::ExifData &exif) const
+{
+    if (!hasExif()) {
+        return;
     }
+    set_exif(exif, "Exif.Photo.ISOSpeedRatings", getISOSpeed());
+    set_exif(exif, "Exif.Photo.FNumber", Exiv2::URationalValue(Exiv2::URational(round(getFNumber() * 10), 10)));
+    auto s = shutterToString(getShutterSpeed());
+    auto p = s.find('.');
+    if (p != std::string::npos) {
+        assert(p == s.length()-2);
+        s = s.substr(0, p) + s.substr(p+1) + "/10";
+    } else if (s.find('/') == std::string::npos) {
+        s += "/1";
+    }
+    set_exif(exif, "Exif.Photo.ExposureTime", s);
+    set_exif(exif, "Exif.Photo.FocalLength", Exiv2::URationalValue(Exiv2::URational(getFocalLen() * 10, 10)));
+    set_exif(exif, "Exif.Photo.ExposureBiasValue", Exiv2::RationalValue(Exiv2::Rational(round(getExpComp() * 100), 100)));
+    set_exif(exif, "Exif.Image.Make", getMake());
+    set_exif(exif, "Exif.Image.Model", getModel());
+    set_exif(exif, "Exif.Photo.LensModel", getLens());
+    char buf[256];
+    auto t = getDateTime();
+    strftime(buf, 256, "%Y:%m:%d %H:%M:%S", &t);
+    set_exif(exif, "Exif.Photo.DateTimeOriginal", buf);
 }
 
-FramesData::~FramesData()
+
+void FramesData::getDimensions(int &w, int &h) const
 {
-    for (auto currRoot : roots) {
-        delete currRoot;
-    }
+    w = w_;
+    h = h_;
+}
 
-    if (iptc) {
-        iptc_data_free(iptc);
-    }
+
+void FramesData::setDimensions(int w, int h)
+{
+    w_ = w;
+    h_ = h;
 }
diff --git a/rtengine/imagedata.h b/rtengine/imagedata.h
index 752fafab3..08f55bd62 100644
--- a/rtengine/imagedata.h
+++ b/rtengine/imagedata.h
@@ -21,12 +21,9 @@
 #include <cstdio>
 #include <memory>
 #include <string>
-#include <vector>
-
-
-#include <libiptcdata/iptc-data.h>
 
 #include "imageio.h"
+#include "metadata.h"
 
 namespace Glib
 {
@@ -35,22 +32,16 @@ class ustring;
 
 }
 
-namespace rtexif
-{
-
-class TagDirectory;
-}
-
 namespace rtengine
 {
 
-class FrameData final
+class FramesData final :
+    public FramesMetaData
 {
-
-protected:
-    rtexif::TagDirectory* frameRootDir;
-    IptcData* iptc;
-
+private:
+    bool ok_;
+    Glib::ustring fname_;
+    unsigned int dcrawFrameCount;
     struct tm time;
     time_t timeStamp;
     int iso_speed;
@@ -64,87 +55,44 @@ protected:
     int rating;
     std::string lens;
     IIOSampleFormat sampleFormat;
-
-    // each frame has the knowledge of "being an"
-    // or "being part of an" HDR or PS image
-    bool isPixelShift;
-    bool isHDR;
-
-public:
-
-    FrameData (rtexif::TagDirectory* frameRootDir, rtexif::TagDirectory* rootDir, rtexif::TagDirectory* firstRootDir, time_t ts = 0);
-    virtual ~FrameData ();
-
-    bool getPixelShift () const;
-    bool getHDR () const;
-    std::string getImageType () const;
-    IIOSampleFormat getSampleFormat () const;
-    rtexif::TagDirectory* getExifData () const;
-    procparams::IPTCPairs getIPTCData () const;
-    static procparams::IPTCPairs getIPTCData (IptcData* iptc_);
-    bool hasExif () const;
-    bool hasIPTC () const;
-    tm getDateTime () const;
-    time_t getDateTimeAsTS () const;
-    int getISOSpeed () const;
-    double getFNumber () const;
-    double getFocalLen () const;
-    double getFocalLen35mm () const;
-    float getFocusDist () const;
-    double getShutterSpeed () const;
-    double getExpComp  () const;
-    std::string getMake () const;
-    std::string getModel () const;
-    std::string getLens () const;
-    std::string getSerialNumber () const;
-    std::string getOrientation () const;
-    int getRating () const;
-};
-
-class FramesData final : public FramesMetaData {
-private:
-    // frame's root IFD, can be a file root IFD or a SUB-IFD
-    std::vector<std::unique_ptr<FrameData>> frames;
-    // root IFD in the file
-    std::vector<rtexif::TagDirectory*> roots;
-    IptcData* iptc;
-    unsigned int dcrawFrameCount;
     struct tm modTime;
     time_t modTimeStamp;
+    bool isPixelShift;
+    bool isHDR;
+    int w_;
+    int h_;
 
 public:
-    explicit FramesData (const Glib::ustring& fname, std::unique_ptr<RawMetaDataLocation> rml = nullptr, bool firstFrameOnly = false);
-    ~FramesData () override;
-
-    void setDCRawFrameCount (unsigned int frameCount);
-    unsigned int getRootCount () const override;
-    unsigned int getFrameCount () const override;
-    bool getPixelShift () const override;
-    bool getHDR (unsigned int frame = 0) const override;
-    std::string getImageType (unsigned int frame) const override;
-    IIOSampleFormat getSampleFormat (unsigned int frame = 0) const override;
-    rtexif::TagDirectory* getFrameExifData (unsigned int frame = 0) const override;
-    rtexif::TagDirectory* getRootExifData (unsigned int root = 0) const override;
-    rtexif::TagDirectory* getBestExifData (ImageSource *imgSource, procparams::RAWParams *rawParams) const override;
-    procparams::IPTCPairs getIPTCData (unsigned int frame = 0) const override;
-    bool hasExif (unsigned int frame = 0) const override;
-    bool hasIPTC (unsigned int frame = 0) const override;
-    tm getDateTime (unsigned int frame = 0) const override;
-    time_t getDateTimeAsTS (unsigned int frame = 0) const override;
-    int getISOSpeed (unsigned int frame = 0) const override;
-    double getFNumber (unsigned int frame = 0) const override;
-    double getFocalLen (unsigned int frame = 0) const override;
-    double getFocalLen35mm (unsigned int frame = 0) const override;
-    float getFocusDist (unsigned int frame = 0) const override;
-    double getShutterSpeed (unsigned int frame = 0) const override;
-    double getExpComp (unsigned int frame = 0) const override;
-    std::string getMake (unsigned int frame = 0) const override;
-    std::string getModel (unsigned int frame = 0) const override;
-    std::string getLens (unsigned int frame = 0) const override;
-    std::string getSerialNumber (unsigned int frame = 0) const;
-    std::string getOrientation (unsigned int frame = 0) const override;
-    int getRating (unsigned int frame = 0) const override;
+    explicit FramesData(const Glib::ustring& fname, time_t ts = 0);
+
+    void setDCRawFrameCount(unsigned int frameCount);
+    unsigned int getFrameCount() const override;
+    bool getPixelShift() const override;
+    bool getHDR() const override;
+    std::string getImageType() const override;
+    IIOSampleFormat getSampleFormat() const override;
+    bool hasExif() const override;
+    tm getDateTime() const override;
+    time_t getDateTimeAsTS() const override;
+    int getISOSpeed() const override;
+    double getFNumber() const override;
+    double getFocalLen() const override;
+    double getFocalLen35mm() const override;
+    float getFocusDist() const override;
+    double getShutterSpeed() const override;
+    double getExpComp() const override;
+    std::string getMake() const override;
+    std::string getModel() const override;
+    std::string getLens() const override;
+    std::string getSerialNumber() const;
+    std::string getOrientation() const override;
+    Glib::ustring getFileName() const override;
+    int getRating() const override;
+    void getDimensions(int &w, int &h) const override;
+
+    void fillBasicTags(Exiv2::ExifData &exif) const;
+
+    void setDimensions(int w, int h);
 };
 
-
 }
diff --git a/rtengine/imageio.cc b/rtengine/imageio.cc
index ad230bb7d..1c8e9016d 100644
--- a/rtengine/imageio.cc
+++ b/rtengine/imageio.cc
@@ -19,6 +19,7 @@
  */
 #include <cstdio>
 #include <cstring>
+#include <iostream>
 #include <memory>
 #include <string>
 #include <utility>
@@ -26,7 +27,6 @@
 
 #include <fcntl.h>
 #include <glib/gstdio.h>
-#include <libiptcdata/iptc-jpeg.h>
 #include <png.h>
 #include <tiff.h>
 #include <tiffio.h>
@@ -39,23 +39,24 @@
 
 #include "color.h"
 #include "iccjpeg.h"
+#include "imagedata.h"
 #include "imageio.h"
-#include "iptcpairs.h"
 #include "jpeg.h"
 #include "procparams.h"
 #include "rt_math.h"
+#include "settings.h"
 #include "utils.h"
 
 #include "../rtgui/options.h"
 #include "../rtgui/version.h"
 
-#include "../rtexif/rtexif.h"
-
 
 using namespace std;
 using namespace rtengine;
 using namespace rtengine::procparams;
 
+namespace rtengine { extern const Settings *settings; }
+
 namespace
 {
 
@@ -85,126 +86,37 @@ FILE* g_fopen_withBinaryAndLock(const Glib::ustring& fname)
     return f;
 }
 
+template <typename Iterator, typename Integer = std::size_t>
+auto to_long(const Iterator &iter, Integer n = Integer{0}) -> decltype(
+#if EXIV2_TEST_VERSION(0,28,0)
+    iter->toInt64()
+) {
+    return iter->toInt64(n);
+#else
+    iter->toLong()
+) {
+    return iter->toLong(n);
+#endif
 }
 
-Glib::ustring ImageIO::errorMsg[6] = {"Success", "Cannot read file.", "Invalid header.", "Error while reading header.", "File reading error", "Image format not supported."};
-
-// For only copying the raw input data
-void ImageIO::setMetadata (const rtexif::TagDirectory* eroot)
-{
-    if (exifRoot != nullptr) {
-        delete exifRoot;
-        exifRoot = nullptr;
-    }
-
-    if (eroot) {
-        rtexif::TagDirectory* td = eroot->clone (nullptr);
-
-        // make IPTC and XMP pass through
-        td->keepTag(0x83bb);  // IPTC
-        td->keepTag(0x02bc);  // XMP
-
-        exifRoot = td;
-    }
 }
 
-// For merging with RT specific data
-void ImageIO::setMetadata (const rtexif::TagDirectory* eroot, const rtengine::procparams::ExifPairs& exif, const rtengine::procparams::IPTCPairs& iptcc)
+void ImageIO::setMetadata(Exiv2Metadata info)
 {
-
-    // store exif info
-    exifChange->clear();
-    *exifChange = exif;
-
-    if (exifRoot != nullptr) {
-        delete exifRoot;
-        exifRoot = nullptr;
-    }
-
-    if (eroot) {
-        exifRoot = eroot->clone (nullptr);
-    }
-
-    if (iptc != nullptr) {
-        iptc_data_free (iptc);
-        iptc = nullptr;
-    }
-
-    // build iptc structures for libiptcdata
-    if (iptcc.empty()) {
-        return;
-    }
-
-    iptc = iptc_data_new ();
-
-    const unsigned char utf8Esc[] = {0x1B, '%', 'G'};
-    IptcDataSet * ds = iptc_dataset_new ();
-    iptc_dataset_set_tag (ds, IPTC_RECORD_OBJECT_ENV, IPTC_TAG_CHARACTER_SET);
-    iptc_dataset_set_data (ds, utf8Esc, 3, IPTC_DONT_VALIDATE);
-    iptc_data_add_dataset (iptc, ds);
-    iptc_dataset_unref (ds);
-
-    for (rtengine::procparams::IPTCPairs::const_iterator i = iptcc.begin(); i != iptcc.end(); ++i) {
-        if (i->first == "Keywords" && !(i->second.empty())) {
-            for (unsigned int j = 0; j < i->second.size(); j++) {
-                IptcDataSet * ds = iptc_dataset_new ();
-                iptc_dataset_set_tag (ds, IPTC_RECORD_APP_2, IPTC_TAG_KEYWORDS);
-                iptc_dataset_set_data (ds, (const unsigned char*)i->second.at(j).c_str(), min(static_cast<size_t>(64), i->second.at(j).bytes()), IPTC_DONT_VALIDATE);
-                iptc_data_add_dataset (iptc, ds);
-                iptc_dataset_unref (ds);
-            }
-
-            continue;
-        } else if (i->first == "SupplementalCategories" && !(i->second.empty())) {
-            for (unsigned int j = 0; j < i->second.size(); j++) {
-                IptcDataSet * ds = iptc_dataset_new ();
-                iptc_dataset_set_tag (ds, IPTC_RECORD_APP_2, IPTC_TAG_SUPPL_CATEGORY);
-                iptc_dataset_set_data (ds, (const unsigned char*)i->second.at(j).c_str(), min(static_cast<size_t>(32), i->second.at(j).bytes()), IPTC_DONT_VALIDATE);
-                iptc_data_add_dataset (iptc, ds);
-                iptc_dataset_unref (ds);
-            }
-
-            continue;
-        }
-
-        for (int j = 0; j < 16; j++)
-            if (i->first == strTags[j].field && !(i->second.empty())) {
-                IptcDataSet * ds = iptc_dataset_new ();
-                iptc_dataset_set_tag (ds, IPTC_RECORD_APP_2, strTags[j].tag);
-                iptc_dataset_set_data (ds, (const unsigned char*)i->second.at(0).c_str(), min(strTags[j].size, i->second.at(0).bytes()), IPTC_DONT_VALIDATE);
-                iptc_data_add_dataset (iptc, ds);
-                iptc_dataset_unref (ds);
-            }
-    }
-
-    iptc_data_sort (iptc);
+    metadataInfo = std::move(info);
 }
 
-void ImageIO::setOutputProfile  (const char* pdata, int plen)
+void ImageIO::setOutputProfile(const std::string& pdata)
 {
-
-    delete [] profileData;
-
-    if (pdata) {
-        profileData = new char [plen];
-        memcpy (profileData, pdata, plen);
-    } else {
-        profileData = nullptr;
-    }
-
-    profileLength = plen;
+    profileData = pdata;
 }
 
 ImageIO::ImageIO() :
     pl(nullptr),
     embProfile(nullptr),
-    profileData(nullptr),
     profileLength(0),
     loadedProfileData(nullptr),
     loadedProfileLength(0),
-    exifChange(new procparams::ExifPairs),
-    iptc(nullptr),
-    exifRoot(nullptr),
     sampleFormat(IIOSF_UNKNOWN),
     sampleArrangement(IIOSA_UNKNOWN)
 {
@@ -218,8 +130,6 @@ ImageIO::~ImageIO ()
     }
 
     deleteLoadedProfileData();
-    delete exifRoot;
-    delete [] profileData;
 }
 
 void png_read_data(png_struct_def  *png_ptr, unsigned char *data, size_t length);
@@ -935,76 +845,6 @@ int ImageIO::loadPPMFromMemory(const char* buffer, int width, int height, bool s
 }
 
 
-namespace {
-
-// Taken from Darktable -- src/imageio/format/png.c
-//
-/* Write EXIF data to PNG file.
- * Code copied from DigiKam's libs/dimg/loaders/pngloader.cpp.
- * The EXIF embedding is defined by ImageMagicK.
- * It is documented in the ExifTool page:
- * http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/PNG.html
- *
- * ..and in turn copied from ufraw. thanks to udi and colleagues
- * for making useful code much more readable and discoverable ;)
- */
-
-void PNGwriteRawProfile(png_struct *ping, png_info *ping_info, const char *profile_type, guint8 *profile_data, png_uint_32 length)
-{
-    png_textp text;
-    long i;
-    guint8 *sp;
-    png_charp dp;
-    png_uint_32 allocated_length, description_length;
-
-    const guint8 hex[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
-    text = static_cast<png_textp>(png_malloc(ping, sizeof(png_text)));
-    description_length = strlen(profile_type);
-    allocated_length = length * 2 + (length >> 5) + 20 + description_length;
-
-    text[0].text = static_cast<png_charp>(png_malloc(ping, allocated_length));
-    text[0].key = static_cast<png_charp>(png_malloc(ping, 80));
-    text[0].key[0] = '\0';
-
-    g_strlcat(text[0].key, "Raw profile type ", 80);
-    g_strlcat(text[0].key, profile_type, 80);
-
-    sp = profile_data;
-    dp = text[0].text;
-    *dp++ = '\n';
-
-    g_strlcpy(dp, profile_type, allocated_length);
-
-    dp += description_length;
-    *dp++ = '\n';
-    *dp = '\0';
-
-    g_snprintf(dp, allocated_length - strlen(text[0].text), "%8lu ", static_cast<unsigned long int>(length));
-
-    dp += 8;
-
-    for(i = 0; i < long(length); i++)
-    {
-        if(i % 36 == 0) *dp++ = '\n';
-
-        *(dp++) = hex[((*sp >> 4) & 0x0f)];
-        *(dp++) = hex[((*sp++) & 0x0f)];
-    }
-
-    *dp++ = '\n';
-    *dp = '\0';
-    text[0].text_length = (dp - text[0].text);
-    text[0].compression = -1;
-
-    if(text[0].text_length <= allocated_length) png_set_text(ping, ping_info, text, 1);
-
-    png_free(ping, text[0].text);
-    png_free(ping, text[0].key);
-    png_free(ping, text);
-}
-
-} // namespace
-
 int ImageIO::savePNG  (const Glib::ustring &fname, int bps) const
 {
     if (getWidth() < 1 || getHeight() < 1) {
@@ -1033,7 +873,7 @@ int ImageIO::savePNG  (const Glib::ustring &fname, int bps) const
 #if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)
     png_set_option(png, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);
 #endif
-    
+
     png_infop info = png_create_info_struct(png);
 
     if (!info) {
@@ -1067,39 +907,15 @@ int ImageIO::savePNG  (const Glib::ustring &fname, int bps) const
     png_set_IHDR(png, info, width, height, bps, PNG_COLOR_TYPE_RGB,
                  PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_BASE);
 
-    if (profileData) {
+    if (!profileData.empty()) {
 #if PNG_LIBPNG_VER < 10500
-        png_charp profdata = reinterpret_cast<png_charp>(profileData);
+        png_const_charp profdata = reinterpret_cast<png_const_charp>(profileData.data());
 #else
-        png_bytep profdata = reinterpret_cast<png_bytep>(profileData);
+        png_const_bytep profdata = reinterpret_cast<png_const_bytep>(profileData.data());
 #endif
-        png_set_iCCP(png, info, const_cast<png_charp>("icc"), 0, profdata, profileLength);
+        png_set_iCCP(png, info, "icc", 0, profdata, profileData.size());
     }
 
-    {
-        // buffer for the exif and iptc
-        unsigned int bufferSize;
-        unsigned char* buffer = nullptr; // buffer will be allocated in createTIFFHeader
-        unsigned char* iptcdata = nullptr;
-        unsigned int iptclen = 0;
-
-        if (iptc && iptc_data_save (iptc, &iptcdata, &iptclen) && iptcdata) {
-            iptc_data_free_buf (iptc, iptcdata);
-            iptcdata = nullptr;
-        }
-
-        int size = rtexif::ExifManager::createPNGMarker(exifRoot, *exifChange, width, height, bps, (char*)iptcdata, iptclen, buffer, bufferSize);
-
-        if (iptcdata) {
-            iptc_data_free_buf (iptc, iptcdata);
-        }
-        if (buffer && size) {
-            PNGwriteRawProfile(png, info, "exif", buffer, size);
-            delete[] buffer;
-        }
-    }
-
-
     int rowlen = width * 3 * bps / 8;
     unsigned char *row = new unsigned char [rowlen];
 
@@ -1133,6 +949,11 @@ int ImageIO::savePNG  (const Glib::ustring &fname, int bps) const
     delete [] row;
     fclose (file);
 
+    if (!saveMetadata(fname)) {
+        g_remove(fname.c_str());
+        return IMIO_CANNOTWRITEFILE;
+    }
+
     if (pl) {
         pl->setProgressStr ("PROGRESSBAR_READY");
         pl->setProgress (1.0);
@@ -1232,52 +1053,9 @@ int ImageIO::saveJPEG (const Glib::ustring &fname, int quality, int subSamp) con
 
     jpeg_start_compress(&cinfo, TRUE);
 
-    // buffer for exif and iptc markers
-    unsigned char* buffer = new unsigned char[165535]; //FIXME: no buffer size check so it can be overflowed in createJPEGMarker() for large tags, and then software will crash
-    unsigned int size;
-
-    // assemble and write exif marker
-    if (exifRoot) {
-        int size = rtexif::ExifManager::createJPEGMarker (exifRoot, *exifChange, cinfo.image_width, cinfo.image_height, buffer);
-
-        if (size > 0 && size < 65530) {
-            jpeg_write_marker(&cinfo, JPEG_APP0 + 1, buffer, size);
-        }
-    }
-
-    // assemble and write iptc marker
-    if (iptc) {
-        unsigned char* iptcdata;
-        bool error = false;
-
-        if (iptc_data_save (iptc, &iptcdata, &size)) {
-            if (iptcdata) {
-                iptc_data_free_buf (iptc, iptcdata);
-            }
-
-            error = true;
-        }
-
-        int bytes = 0;
-
-        if (!error && (bytes = iptc_jpeg_ps3_save_iptc (nullptr, 0, iptcdata, size, buffer, 65532)) < 0) {
-            error = true;
-        }
-
-        if (iptcdata) {
-            iptc_data_free_buf (iptc, iptcdata);
-        }
-
-        if (!error) {
-            jpeg_write_marker(&cinfo, JPEG_APP0 + 13, buffer, bytes);
-        }
-    }
-
-    delete [] buffer;
-
     // write icc profile to the output
-    if (profileData) {
-        write_icc_profile (&cinfo, (JOCTET*)profileData, profileLength);
+    if (!profileData.empty()) {
+        write_icc_profile (&cinfo, reinterpret_cast<const JOCTET*>(profileData.data()), profileData.size());
     }
 
     // write image data
@@ -1326,6 +1104,11 @@ int ImageIO::saveJPEG (const Glib::ustring &fname, int quality, int subSamp) con
 
     fclose (file);
 
+    if (!saveMetadata(fname)) {
+        g_remove(fname.c_str());
+        return IMIO_CANNOTWRITEFILE;
+    }
+
     if (pl) {
         pl->setProgressStr ("PROGRESSBAR_READY");
         pl->setProgress (1.0);
@@ -1334,6 +1117,7 @@ int ImageIO::saveJPEG (const Glib::ustring &fname, int quality, int subSamp) con
     return IMIO_SUCCESS;
 }
 
+
 int ImageIO::saveTIFF (
     const Glib::ustring &fname,
     int bps,
@@ -1359,15 +1143,6 @@ int ImageIO::saveTIFF (
 
     std::string mode = "w";
 
-    // little hack to get libTiff to use proper byte order (see TIFFClienOpen()):
-    if (exifRoot) {
-        if (exifRoot->getOrder() == rtexif::INTEL) {
-            mode += 'l';
-        } else {
-            mode += 'b';
-        }
-    }
-
     if (big) {
         mode += '8';
     }
@@ -1379,7 +1154,7 @@ int ImageIO::saveTIFF (
     TIFF* out = TIFFFdOpen (osfileno, fname.c_str(), mode.c_str());
 #else
     TIFF* out = TIFFOpen(fname.c_str(), mode.c_str());
-    int fileno = TIFFFileno (out);
+    // int fileno = TIFFFileno (out);
 #endif
 
     if (!out) {
@@ -1391,109 +1166,7 @@ int ImageIO::saveTIFF (
         pl->setProgress (0.0);
     }
 
-    bool applyExifPatch = false;
-
-    if (exifRoot && !big) {
-        rtexif::TagDirectory* cl = (const_cast<rtexif::TagDirectory*> (exifRoot))->clone (nullptr);
-
-        // ------------------ remove some unknown top level tags which produce warnings when opening a tiff (might be useless) -----------------
-
-        rtexif::Tag *removeTag = cl->getTag (0x9003);
-
-        if (removeTag) {
-            removeTag->setKeep (false);
-        }
-
-        removeTag = cl->getTag (0x9211);
-
-        if (removeTag) {
-            removeTag->setKeep (false);
-        }
-
-        // ------------------ Apply list of change -----------------
-
-        for (auto currExifChange : *exifChange) {
-            cl->applyChange (currExifChange.first, currExifChange.second);
-        }
-
-        rtexif::Tag *tag = cl->getTag (TIFFTAG_EXIFIFD);
-
-        if (tag && tag->isDirectory()) {
-            rtexif::TagDirectory *exif = tag->getDirectory();
-
-            if (exif)   {
-                int exif_size = exif->calculateSize();
-                // TIFFOpen writes out the header and sets file pointer at position 8
-                const uint64_t file_offset = 8; // must be 64-bit, because TIFFTAG_EXIFIFD is
-                unsigned char *buffer = new unsigned char[exif_size + file_offset];
-
-                exif->write (file_offset, buffer);
-
-                write (fileno, buffer + file_offset, exif_size);
-
-                delete [] buffer;
-                // let libtiff know that scanlines or any other following stuff should go
-                // at a different offset:
-                TIFFSetWriteOffset (out, exif_size + file_offset);
-                TIFFSetField (out, TIFFTAG_EXIFIFD, file_offset);
-                applyExifPatch = true;
-            }
-        }
-
-        //TODO Even though we are saving EXIF IFD - MakerNote still comes out screwed.
-
-        if ((tag = cl->getTag (TIFFTAG_MODEL)) != nullptr) {
-            TIFFSetField (out, TIFFTAG_MODEL, tag->getValue());
-        }
-
-        if ((tag = cl->getTag (TIFFTAG_MAKE)) != nullptr) {
-            TIFFSetField (out, TIFFTAG_MAKE, tag->getValue());
-        }
-
-        if ((tag = cl->getTag (TIFFTAG_DATETIME)) != nullptr) {
-            TIFFSetField (out, TIFFTAG_DATETIME, tag->getValue());
-        }
-
-        if ((tag = cl->getTag (TIFFTAG_ARTIST)) != nullptr) {
-            TIFFSetField (out, TIFFTAG_ARTIST, tag->getValue());
-        }
-
-        if ((tag = cl->getTag (TIFFTAG_COPYRIGHT)) != nullptr) {
-            TIFFSetField (out, TIFFTAG_COPYRIGHT, tag->getValue());
-        }
-
-        delete cl;
-    }
-
-    unsigned char* iptcdata = nullptr;
-    unsigned int iptclen = 0;
-
-    if (iptc && iptc_data_save (iptc, &iptcdata, &iptclen)) {
-        if (iptcdata) {
-            iptc_data_free_buf (iptc, iptcdata);
-            iptcdata = nullptr;
-        }
-    }
-
-#if __BYTE_ORDER__==__ORDER_LITTLE_ENDIAN__
-    bool needsReverse = exifRoot && exifRoot->getOrder() == rtexif::MOTOROLA;
-#else
-    bool needsReverse = exifRoot && exifRoot->getOrder() == rtexif::INTEL;
-#endif
-
-    if (iptcdata) {
-        rtexif::Tag iptcTag(nullptr, rtexif::lookupAttrib (rtexif::ifdAttribs, "IPTCData"));
-        iptcTag.initLongArray((char*)iptcdata, iptclen);
-        if (needsReverse) {
-            unsigned char *ptr = iptcTag.getValue();
-            for (int a = 0; a < iptcTag.getCount(); ++a, ptr += 4) {
-                std::swap(ptr[0], ptr[3]);
-                std::swap(ptr[1], ptr[2]);
-            }
-        }
-        TIFFSetField (out, TIFFTAG_RICHTIFFIPTC, iptcTag.getCount(), (long*)iptcTag.getValue());
-        iptc_data_free_buf (iptc, iptcdata);
-    }
+    bool needsReverse = false;
 
     TIFFSetField (out, TIFFTAG_SOFTWARE, "RawTherapee " RTVERSION);
     TIFFSetField (out, TIFFTAG_IMAGEWIDTH, width);
@@ -1507,24 +1180,36 @@ int ImageIO::saveTIFF (
     TIFFSetField (out, TIFFTAG_COMPRESSION, uncompressed ? COMPRESSION_NONE : COMPRESSION_ADOBE_DEFLATE);
     TIFFSetField (out, TIFFTAG_SAMPLEFORMAT, (bps == 16 || bps == 32) && isFloat ? SAMPLEFORMAT_IEEEFP : SAMPLEFORMAT_UINT);
 
-    [out]()
-    {
-        const std::vector<rtexif::Tag*> default_tags = rtexif::ExifManager::getDefaultTIFFTags(nullptr);
-
-        TIFFSetField (out, TIFFTAG_XRESOLUTION, default_tags[2]->toDouble());
-        TIFFSetField (out, TIFFTAG_YRESOLUTION, default_tags[3]->toDouble());
-        TIFFSetField (out, TIFFTAG_RESOLUTIONUNIT, default_tags[4]->toInt());
-
-        for (auto default_tag : default_tags) {
-            delete default_tag;
+    // somehow Exiv2 (tested with 0.27.3) doesn't seem to be able to update
+    // XResolution and YResolution, so we do it ourselves here....
+    constexpr float default_resolution = 300.f;
+    float x_res = default_resolution;
+    float y_res = default_resolution;
+    int res_unit = RESUNIT_INCH;
+    if (!metadataInfo.filename().empty()) {
+        auto exif = metadataInfo.getOutputExifData();
+        auto it = exif.findKey(Exiv2::ExifKey("Exif.Image.XResolution"));
+        if (it != exif.end()) {
+            x_res = it->toFloat();
+        }
+        it = exif.findKey(Exiv2::ExifKey("Exif.Image.YResolution"));
+        if (it != exif.end()) {
+            y_res = it->toFloat();
         }
-    }();
+        it = exif.findKey(Exiv2::ExifKey("Exif.Image.ResolutionUnit"));
+        if (it != exif.end()) {
+            res_unit = to_long(it);
+        }
+    }
+    TIFFSetField(out, TIFFTAG_XRESOLUTION, x_res);
+    TIFFSetField(out, TIFFTAG_YRESOLUTION, y_res);
+    TIFFSetField(out, TIFFTAG_RESOLUTIONUNIT, res_unit);
 
     if (!uncompressed) {
         TIFFSetField (out, TIFFTAG_PREDICTOR, (bps == 16 || bps == 32) && isFloat ? PREDICTOR_FLOATINGPOINT : PREDICTOR_HORIZONTAL);
     }
-    if (profileData) {
-        TIFFSetField (out, TIFFTAG_ICCPROFILE, profileLength, profileData);
+    if (!profileData.empty()) {
+        TIFFSetField (out, TIFFTAG_ICCPROFILE, profileData.size(), profileData.data());
     }
 
     for (int row = 0; row < height; row++) {
@@ -1559,43 +1244,15 @@ int ImageIO::saveTIFF (
         writeOk = false;
     }
 
-    /************************************************************************************************************
-     *
-     * Hombre: This is a dirty hack to update the Exif tag data type to 0x0004 so that Windows can understand it.
-     *         libtiff will set this data type to 0x000d and doesn't provide any mechanism to update it before
-     *         dumping to the file.
-     *
-     */
-    if (applyExifPatch) {
-        unsigned char b[10];
-        uint16 tagCount = 0;
-        lseek(fileno, 4, SEEK_SET);
-        read(fileno, b, 4);
-        uint32 ifd0Offset = rtexif::sget4(b, exifRoot->getOrder());
-        lseek(fileno, ifd0Offset, SEEK_SET);
-        read(fileno, b, 2);
-        tagCount = rtexif::sget2(b, exifRoot->getOrder());
-        for (size_t i = 0; i < tagCount ; ++i) {
-            uint16 tagID = 0;
-            read(fileno, b, 2);
-            tagID = rtexif::sget2(b, exifRoot->getOrder());
-            if (tagID == 0x8769) {
-                rtexif::sset2(4, b, exifRoot->getOrder());
-                write(fileno, b, 2);
-                break;
-            } else {
-                read(fileno, b, 10);
-            }
-        }
-    }
-    /************************************************************************************************************/
-
-
     TIFFClose (out);
 #ifdef WIN32
     fclose (file);
 #endif
 
+    if (!saveMetadata(fname)) {
+        writeOk = false;
+    }
+
     if (pl) {
         pl->setProgressStr ("PROGRESSBAR_READY");
         pl->setProgress (1.0);
@@ -1722,3 +1379,57 @@ void ImageIO::deleteLoadedProfileData( )
 
     loadedProfileData = nullptr;
 }
+
+bool ImageIO::saveMetadata(const Glib::ustring &fname) const
+{
+    if (metadataInfo.filename().empty()) {
+        return true;
+    }
+
+    bool has_meta = true;
+    try {
+        metadataInfo.load();
+    } catch (const std::exception& exc) {
+        if (settings->verbose) {
+            std::cout << "EXIF LOAD ERROR: " << exc.what() << std::endl;
+        }
+        has_meta = false;
+    }
+
+    if (has_meta) {
+        try {
+            metadataInfo.saveToImage(fname, false);
+            // auto src = open_exiv2(metadataInfo.filename());
+            // auto dst = open_exiv2(fname);
+            // src->readMetadata();
+            // dst->setMetadata(*src);
+            // dst->exifData()["Exif.Image.Software"] = "RawTherapee " RTVERSION;
+            // for (const auto& p : metadataInfo.exif()) {
+            //     try {
+            //         dst->exifData()[p.first] = p.second;
+            //     } catch (const Exiv2::AnyError& exc) {
+            //     }
+            // }
+            // for (const auto& p : metadataInfo.iptc()) {
+            //     try {
+            //         auto& v = p.second;
+            //         if (!v.empty()) {
+            //             dst->iptcData()[p.first] = v[0];
+            //             for (size_t j = 1; j < v.size(); ++j) {
+            //                 Exiv2::Iptcdatum d(Exiv2::IptcKey(p.first));
+            //                 d.setValue(v[j]);
+            //                 dst->iptcData().add(d);
+            //             }
+            //         }
+            //     } catch (const Exiv2::AnyError& exc) {
+            //     }
+            // }
+            // dst->writeMetadata();
+        } catch (const std::exception& exc) {
+            std::cout << "EXIF ERROR: " << exc.what() << std::endl;
+            //return false;
+        }
+    }
+
+    return true;
+}
diff --git a/rtengine/imageio.h b/rtengine/imageio.h
index e900feccd..813bfcc61 100644
--- a/rtengine/imageio.h
+++ b/rtengine/imageio.h
@@ -19,14 +19,12 @@
 #pragma once
 
 #include <memory>
-
 #include <glibmm/ustring.h>
 
-#include <libiptcdata/iptc-data.h>
-
 #include "iimage.h"
 #include "imagedimensions.h"
 #include "imageformat.h"
+#include "metadata.h"
 #include "rtengine.h"
 
 enum {
@@ -40,50 +38,40 @@ enum {
     IMIO_CANNOTWRITEFILE
 };
 
-namespace rtexif
-{
-
-class TagDirectory;
-
-}
-
 namespace rtengine
 {
 
-class ColorTemp;
-class ProgressListener;
-class Imagefloat;
-
 namespace procparams
 {
 
 class ExifPairs;
+class IPTCPairs;
 
 }
 
+class ColorTemp;
+class ProgressListener;
+class Imagefloat;
+
 class ImageIO : virtual public ImageDatas
 {
 
 protected:
     ProgressListener* pl;
     cmsHPROFILE embProfile;
-    char* profileData;
+    std::string profileData;
     int profileLength;
     char* loadedProfileData;
     int loadedProfileLength;
-    const std::unique_ptr<procparams::ExifPairs> exifChange;
-    IptcData* iptc;
-    const rtexif::TagDirectory* exifRoot;
     MyMutex imutex;
     IIOSampleFormat sampleFormat;
     IIOSampleArrangement sampleArrangement;
+    Exiv2Metadata metadataInfo;
 
 private:
     void deleteLoadedProfileData( );
 
 public:
-    static Glib::ustring errorMsg[6];
-
     ImageIO();
     ~ImageIO() override;
 
@@ -124,9 +112,10 @@ public:
     cmsHPROFILE getEmbeddedProfile () const;
     void getEmbeddedProfileData (int& length, unsigned char*& pdata) const;
 
-    void setMetadata (const rtexif::TagDirectory* eroot);
-    void setMetadata (const rtexif::TagDirectory* eroot, const rtengine::procparams::ExifPairs& exif, const rtengine::procparams::IPTCPairs& iptcc);
-    void setOutputProfile (const char* pdata, int plen);
+    void setMetadata(Exiv2Metadata info);
+    void setOutputProfile(const std::string& pdata);
+
+    bool saveMetadata(const Glib::ustring &fname) const;
 
     MyMutex& mutex ();
 };
diff --git a/rtengine/imagesource.h b/rtengine/imagesource.h
index 1f4c2179a..87b560088 100644
--- a/rtengine/imagesource.h
+++ b/rtengine/imagesource.h
@@ -171,7 +171,7 @@ public:
     {
         outCurve = { 0.0 };
     }
-    
+
     double getDirPyrDenoiseExpComp () const
     {
         return dirpyrdenoiseExpComp;
diff --git a/rtengine/improccoordinator.cc b/rtengine/improccoordinator.cc
index 664029a5e..45f75b0ca 100644
--- a/rtengine/improccoordinator.cc
+++ b/rtengine/improccoordinator.cc
@@ -33,6 +33,7 @@
 #include "image8.h"
 #include "imagefloat.h"
 #include "improcfun.h"
+#include "metadata.h"
 #include "labimage.h"
 #include "lcp.h"
 #include "procparams.h"
@@ -357,7 +358,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
         ColorManagementParams cmp = params->icm;
         LCurveParams  lcur = params->labCurve;
         bool spotsDone = false;
-        
+
         if (!highDetailNeeded) {
             // if below 100% magnification, take a fast path
             if (rp.bayersensor.method != RAWParams::BayerSensor::getMethodString(RAWParams::BayerSensor::Method::NONE) && rp.bayersensor.method != RAWParams::BayerSensor::getMethodString(RAWParams::BayerSensor::Method::MONO)) {
@@ -572,8 +573,8 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                         lastAwbauto = "";
                         autoWB.useDefaults(params->wb.equal, params->wb.observer);
                     }
-                    
-                    
+
+
                 }
 
                 currWB = autoWB;
@@ -728,7 +729,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
         if (spotprev) {
             spotprev->copyData(orig_prev);
         }
-        
+
         if ((todo & M_HDR) && (params->fattal.enabled || params->dehaze.enabled)) {
             if (fattal_11_dcrop_cache) {
                 delete fattal_11_dcrop_cache;
@@ -765,7 +766,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
 			if(params->locallab.spots.at(sp).expsharp  && params->dirpyrequalizer.cbdlMethod == "bef") {
 				if(params->locallab.spots.at(sp).shardamping < 1) {
 					params->locallab.spots.at(sp).shardamping = 1;
-				}				
+				}
 			}
 		}
 
@@ -852,7 +853,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                 centx = new float[sizespot];
                 float *centy = nullptr;
                 centy = new float[sizespot];
-                
+
                 for (int sp = 0; sp < sizespot; sp++) {
                     log[sp] = params->locallab.spots.at(sp).explog;
                     cie[sp] = params->locallab.spots.at(sp).expcie;
@@ -938,7 +939,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
 
 
         if ((todo & (M_AUTOEXP | M_RGBCURVE | M_CROP)) && params->locallab.enabled && !params->locallab.spots.empty()) {
-            
+
             ipf.rgb2lab(*oprevi, *oprevl, params->icm.workingProfile);
 
             nprevl->CopyFrom(oprevl);
@@ -1053,7 +1054,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                 const bool llmascieutili = locllmascieCurve.Set(params->locallab.spots.at(sp).LLmaskciecurve);
                 const bool lcmascieutili = locccmascieCurve.Set(params->locallab.spots.at(sp).CCmaskciecurve);
                 const bool lhmascieutili = lochhmascieCurve.Set(params->locallab.spots.at(sp).HHmaskciecurve);
-                
+
                 const bool lcmas_utili = locccmas_Curve.Set(params->locallab.spots.at(sp).CCmask_curve);
                 const bool llmas_utili = locllmas_Curve.Set(params->locallab.spots.at(sp).LLmask_curve);
                 const bool lhmas_utili = lochhmas_Curve.Set(params->locallab.spots.at(sp).HHmask_curve);
@@ -1149,7 +1150,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                 int xxe = xend * ww;
                 int yys = ysta * hh;
                 int yye = yend * hh;
-                        
+
                 if (istm) { //calculate mean and sigma on full image for RT-spot use by normalize_mean_dt
                     ipf.mean_sig (nprevl->L, meantme, stdtme, xxs, xxe, yys, yye);
                 }
@@ -1173,7 +1174,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                 huerefp[sp] = huer;
                 chromarefp[sp] = chromar;
                 lumarefp[sp] = lumar;
-                
+
                 CurveFactory::complexCurvelocal(ecomp, black / 65535., hlcompr, hlcomprthresh, shcompr, br, cont, lumar,
                                                 hltonecurveloc, shtonecurveloc, tonecurveloc, lightCurveloc, avg,
                                                 sca);
@@ -1236,7 +1237,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                               locccmasblCurve, lcmasblutili, locllmasblCurve, llmasblutili, lochhmasblCurve, lhmasblutili,
                               locccmaslcCurve, lcmaslcutili, locllmaslcCurve, llmaslcutili, lochhmaslcCurve, lhmaslcutili,
                               locccmaslogCurve, lcmaslogutili, locllmaslogCurve, llmaslogutili, lochhmaslogCurve, lhmaslogutili,
-                              
+
                               locccmas_Curve, lcmas_utili, locllmas_Curve, llmas_utili, lochhmas_Curve, lhmas_utili,
                               locccmascieCurve, lcmascieutili, locllmascieCurve, llmascieutili, lochhmascieCurve, lhmascieutili,
 
@@ -1264,8 +1265,8 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                     float meanf = 0.f;
                     float stdf = 0.f;
                     ipf.mean_sig (savenormtm->L, meanf, stdf, xxs, xxe, yys, yye);
-                    
-                    //using 2 unused variables  noiselumc and softradiustm  
+
+                    //using 2 unused variables  noiselumc and softradiustm
                     params->locallab.spots.at(sp).noiselumc = (int) meanf;
                     params->locallab.spots.at(sp).softradiustm = stdf ;
                 }
@@ -1274,7 +1275,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                     float meanf = 0.f;
                     float stdf = 0.f;
                     ipf.mean_sig (savenormreti->L, meanf, stdf,xxs, xxe, yys, yye );
-                    //using 2 unused variables  sensihs and sensiv  
+                    //using 2 unused variables  sensihs and sensiv
                     params->locallab.spots.at(sp).sensihs = (int) meanf;
                     params->locallab.spots.at(sp).sensiv = (int) stdf;
                 }
@@ -1319,7 +1320,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                     chromarefp[sp] = chromar;
                     lumarefp[sp] = lumar;
                     fabrefp[sp] = fab;
-                    
+
                 }
             //    spotref.fab = fab;
             //    locallref.at(sp).fab = fab;
@@ -1347,9 +1348,9 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
             //*************************************************************
             // end locallab
             //*************************************************************
-            
+
         }
-        
+
         if ((todo & M_RGBCURVE) || (todo & M_CROP)) {
             //complexCurve also calculated pre-curves histogram depending on crop
             CurveFactory::complexCurve(params->toneCurve.expcomp, params->toneCurve.black / 65535.0,
@@ -1552,7 +1553,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                 bool proedge = WaveParams.expedge;
                 bool profin = WaveParams.expfinal;
                 bool proton = WaveParams.exptoning;
-                bool pronois = WaveParams.expnoise; 
+                bool pronois = WaveParams.expnoise;
 
                 if (WaveParams.showmask) {
                  //   WaveParams.showmask = false;
@@ -1576,7 +1577,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                     WaveParams.expedge = false;
                     WaveParams.expfinal = false;
                     WaveParams.exptoning = false;
-                    WaveParams.expnoise = false; 
+                    WaveParams.expnoise = false;
                 }
 
                 ipf.ip_wavelet(nprevl, nprevl, kall, WaveParams, wavCLVCurve, wavdenoise, wavdenoiseh, wavblcurve, waOpacityCurveRG, waOpacityCurveSH, waOpacityCurveBY, waOpacityCurveW, waOpacityCurveWL, wavclCurve, scale);
@@ -1589,7 +1590,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                     WaveParams.expfinal = profin;
                     WaveParams.exptoning = proton;
                     WaveParams.expnoise = pronois;
-                    
+
                     if (WaveParams.softrad > 0.f) {
 
                         array2D<float> ble(pW, pH);
@@ -1619,7 +1620,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                                 tmpImage->b(ir, jr) = Z;
                                 ble[ir][jr] = Y / 32768.f;
                             }
-    
+
                         double epsilmax = 0.0001;
                         double epsilmin = 0.00001;
                         double aepsil = (epsilmax - epsilmin) / 100.f;
@@ -1645,11 +1646,11 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                                 Color::XYZ2Lab(X, Y, Z, L, a, b);
                                 nprevl->L[ir][jr] =  L;
                             }
-      
+
                     delete tmpImage;
 
                     }
-                    
+
                 }
 
                 if ((WaveParams.ushamethod == "sharp" || WaveParams.ushamethod == "clari")  && WaveParams.expclari && WaveParams.CLmethod != "all") {
@@ -1658,7 +1659,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                     float mL0;
                     float mC0;
                     float background = 0.f;
-                    int show = 0; 
+                    int show = 0;
 
 
 
@@ -1700,8 +1701,8 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
 
                     delete unshar;
                     unshar    = NULL;
-                    
-                    
+
+
 /*
                     if (WaveParams.softrad > 0.f) {
                         array2D<float> ble(pW, pH);
@@ -1746,7 +1747,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
 
 
                 }
-               
+
             }
 
             ipf.softLight(nprevl, params->softlight);
@@ -1792,7 +1793,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                             nprevl->b[x][y] = 0.f;
                         }
                 }
-                
+
                 tmpImage1.reset();
 
                 if (prim == 12) {//pass red gre blue xy in function of area dats Ciexy
@@ -1902,20 +1903,10 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
                                                     customColCurve1, customColCurve2, customColCurve3, 1);
 
                 const FramesMetaData* metaData = imgsrc->getMetaData();
-                int imgNum = 0;
-
-                if (imgsrc->isRAW()) {
-                    if (imgsrc->getSensorType() == ST_BAYER) {
-                        imgNum = rtengine::LIM<unsigned int>(params->raw.bayersensor.imageNum, 0, metaData->getFrameCount() - 1);
-                    } else if (imgsrc->getSensorType() == ST_FUJI_XTRANS) {
-                        //imgNum = rtengine::LIM<unsigned int>(params->raw.xtranssensor.imageNum, 0, metaData->getFrameCount() - 1);
-                    }
-                }
-
-                float fnum = metaData->getFNumber(imgNum);          // F number
-                float fiso = metaData->getISOSpeed(imgNum) ;        // ISO
-                float fspeed = metaData->getShutterSpeed(imgNum) ;  // Speed
-                double fcomp = metaData->getExpComp(imgNum);        // Compensation +/-
+                float fnum = metaData->getFNumber();          // F number
+                float fiso = metaData->getISOSpeed() ;        // ISO
+                float fspeed = metaData->getShutterSpeed() ;  // Speed
+                double fcomp = metaData->getExpComp();        // Compensation +/-
                 double adap;
 
                 if (fnum < 0.3f || fiso < 5.f || fspeed < 0.00001f) { //if no exif data or wrong
@@ -1981,7 +1972,7 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
 				} else if (params->colorappearance.wbmodel == "free") {
 					wmodel = 2;//force white balance in symmetric
 				}
-				
+
 				if(params->colorappearance.catmethod == "symg" && wmodel == 2) {
 					tempsym = params->wb.temperature;//force white balance in symmetric
 				} else {
@@ -2000,13 +1991,13 @@ void ImProcCoordinator::updatePreviewImage(int todo, bool panningRelatedChange)
 					} else if (params->colorappearance.illum == "i75") {
 						tempsym = 7504.;
 					} else if (params->colorappearance.illum == "ifree") {
-						tempsym = params->wb.temperature;//force white balance in symmetric		
+						tempsym = params->wb.temperature;//force white balance in symmetric
 					}
 				}
                 if (params->colorappearance.enabled  && params->colorappearance.autotempout) {
 						acListener->wbCamChanged(tempsym, 1.f);    //real temp and tint = 1.
                 }
-                
+
             } else {
                 // CIECAM is disabled, we free up its image buffer to save some space
                 if (ncie) {
@@ -2471,7 +2462,7 @@ bool ImProcCoordinator::getAutoWB(double& temp, double& green, double equal, Sta
 // Issue 2500            MyMutex::MyLock lock(minit);  // Also used in crop window
             double rm, gm, bm;
             params->wb.method = "autold";//same result as before multiple Auto WB
-            
+
            // imgsrc->getAutoWBMultipliers(rm, gm, bm);
             double tempitc = 5000.;
             double greenitc = 1.;
@@ -2725,7 +2716,7 @@ void ImProcCoordinator::saveInputICCReference(const Glib::ustring& fname, bool a
         im = tempImage;
     }
 
-    im->setMetadata(imgsrc->getMetaData()->getRootExifData());
+    im->setMetadata(Exiv2Metadata(imgsrc->getFileName(), false));
 
     im->saveTIFF(fname, 16, false, true);
     delete im;
diff --git a/rtengine/improcfun.cc b/rtengine/improcfun.cc
index c3e11c076..f1adbe043 100644
--- a/rtengine/improcfun.cc
+++ b/rtengine/improcfun.cc
@@ -5578,18 +5578,18 @@ void ImProcFunctions::getAutoExp(const LUTu &histogram, int histcompr, double cl
 double ImProcFunctions::getAutoDistor(const Glib::ustring &fname, int thumb_size)
 {
     if (!fname.empty()) {
-        rtengine::RawMetaDataLocation ri;
+    	// TODO: std::unique_ptr<> to the rescue
         int w_raw = -1, h_raw = thumb_size;
         int w_thumb = -1, h_thumb = thumb_size;
 
         eSensorType sensorType = rtengine::ST_NONE;
-        Thumbnail* thumb = rtengine::Thumbnail::loadQuickFromRaw(fname, ri, sensorType, w_thumb, h_thumb, 1, FALSE);
+        Thumbnail* thumb = rtengine::Thumbnail::loadQuickFromRaw(fname, sensorType, w_thumb, h_thumb, 1, FALSE);
 
         if (!thumb) {
             return 0.0;
         }
 
-        Thumbnail* raw =   rtengine::Thumbnail::loadFromRaw(fname, ri, sensorType, w_raw, h_raw, 1, 1.0, ColorTemp::DEFAULT_OBSERVER, FALSE);
+        Thumbnail* raw =   rtengine::Thumbnail::loadFromRaw(fname, sensorType, w_raw, h_raw, 1, 1.0, ColorTemp::DEFAULT_OBSERVER, FALSE);
 
         if (!raw) {
             delete thumb;
diff --git a/rtengine/init.cc b/rtengine/init.cc
index 0c1bd4f6b..04faa98a8 100644
--- a/rtengine/init.cc
+++ b/rtengine/init.cc
@@ -34,6 +34,7 @@
 #include "profilestore.h"
 #include "../rtgui/threadutils.h"
 #include "rtlensfun.h"
+#include "metadata.h"
 #include "procparams.h"
 
 namespace rtengine
@@ -114,6 +115,8 @@ int init (const Settings* s, const Glib::ustring& baseDir, const Glib::ustring&
 }
 
     Color::init ();
+    Exiv2Metadata::init();
+
     delete lcmsMutex;
     lcmsMutex = new MyMutex;
     fftwMutex = new MyMutex;
@@ -122,6 +125,7 @@ int init (const Settings* s, const Glib::ustring& baseDir, const Glib::ustring&
 
 void cleanup ()
 {
+    Exiv2Metadata::cleanup();
     ProcParams::cleanup ();
     Color::cleanup ();
     RawImageSource::cleanup ();
diff --git a/rtengine/iplocallab.cc b/rtengine/iplocallab.cc
index b9e82cc5d..eaa5e857e 100644
--- a/rtengine/iplocallab.cc
+++ b/rtengine/iplocallab.cc
@@ -2235,20 +2235,11 @@ void ImProcFunctions::getAutoLogloc(int sp, ImageSource *imgsrc, float *sourceg,
         //calculate La - Absolute luminance shooting
 
         const FramesMetaData* metaData = imgsrc->getMetaData();
-        int imgNum = 0;
-
-        if (imgsrc->isRAW()) {
-            if (imgsrc->getSensorType() == ST_BAYER) {
-                imgNum = rtengine::LIM<unsigned int>(params->raw.bayersensor.imageNum, 0, metaData->getFrameCount() - 1);
-            } else if (imgsrc->getSensorType() == ST_FUJI_XTRANS) {
-                        //imgNum = rtengine::LIM<unsigned int>(params->raw.xtranssensor.imageNum, 0, metaData->getFrameCount() - 1);
-            }
-        }
         
-        float fnum = metaData->getFNumber(imgNum);          // F number
-        float fiso = metaData->getISOSpeed(imgNum) ;        // ISO
-        float fspeed = metaData->getShutterSpeed(imgNum) ;  // Speed
-        double fcomp = metaData->getExpComp(imgNum);        // Compensation +/-
+        float fnum = metaData->getFNumber();          // F number
+        float fiso = metaData->getISOSpeed() ;        // ISO
+        float fspeed = metaData->getShutterSpeed() ;  // Speed
+        double fcomp = metaData->getExpComp();        // Compensation +/-
         double adap;
 
         if (fnum < 0.3f || fiso < 5.f || fspeed < 0.00001f) { //if no exif data or wrong
diff --git a/rtengine/iptcpairs.h b/rtengine/iptcpairs.h
deleted file mode 100644
index af45d7d38..000000000
--- a/rtengine/iptcpairs.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- *  This file is part of RawTherapee.
- *
- *  Copyright (c) 2004-2010 Gabor Horvath <hgabor@rawtherapee.com>
- *
- *  RawTherapee is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  RawTherapee is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
- */
-#pragma once
-
-struct IptcPair {
-    IptcTag tag;
-    size_t size;
-    Glib::ustring field;
-};
-
-const IptcPair strTags[] = {
-    {IPTC_TAG_CAPTION, 2000, "Caption"},
-    {IPTC_TAG_WRITER_EDITOR, 32, "CaptionWriter"},
-    {IPTC_TAG_HEADLINE, 256, "Headline"},
-    {IPTC_TAG_SPECIAL_INSTRUCTIONS, 256, "Instructions"},
-    {IPTC_TAG_CATEGORY, 3, "Category"},
-    {IPTC_TAG_BYLINE, 32, "Creator"},
-    {IPTC_TAG_BYLINE_TITLE, 32, "CreatorJobTitle"},
-    {IPTC_TAG_CREDIT, 32, "Credit"},
-    {IPTC_TAG_SOURCE, 32, "Source"},
-    {IPTC_TAG_COPYRIGHT_NOTICE, 128, "Copyright"},
-    {IPTC_TAG_CITY, 32, "City"},
-    {IPTC_TAG_STATE, 32, "Province"},
-    {IPTC_TAG_COUNTRY_NAME, 64, "Country"},
-    {IPTC_TAG_OBJECT_NAME, 64, "Title"},
-    {IPTC_TAG_ORIG_TRANS_REF, 32, "TransReference"},
-    {IPTC_TAG_DATE_CREATED, 8, "DateCreated"}
-};
diff --git a/rtengine/metadata.cc b/rtengine/metadata.cc
new file mode 100644
index 000000000..0a55c1424
--- /dev/null
+++ b/rtengine/metadata.cc
@@ -0,0 +1,624 @@
+/* -*- C++ -*-
+ *
+ *  This file is part of RawTherapee.
+ *
+ *  Copyright (c) 2019 Alberto Griggio <alberto.griggio@gmail.com>
+ *
+ *  RawTherapee is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  RawTherapee is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with RawTherapee.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <glib/gstdio.h>
+#include <iostream>
+#include <giomm.h>
+#include <set>
+
+#include "metadata.h"
+#include "settings.h"
+#include "imagedata.h"
+#include "../rtgui/version.h"
+#include "../rtgui/pathutils.h"
+
+
+#if EXIV2_TEST_VERSION(0,28,0)
+using Exiv2Error = Exiv2::Error;
+#else
+using Exiv2Error = Exiv2::AnyError;
+#endif
+
+
+namespace rtengine {
+
+extern const Settings *settings;
+
+std::unique_ptr<Exiv2Metadata::ImageCache> Exiv2Metadata::cache_(nullptr);
+
+namespace {
+
+class Error: public Exiv2Error {
+public:
+    Error(const std::string &msg):
+#if EXIV2_TEST_VERSION(0,28,0)
+        Exiv2Error(Exiv2::ErrorCode::kerGeneralError),
+#endif
+        msg_(msg) {}
+    const char *what() const throw() { return msg_.c_str(); }
+    int code() const throw() { return 0; }
+
+private:
+    std::string msg_;
+};
+
+
+constexpr size_t IMAGE_CACHE_SIZE = 200;
+
+std::unique_ptr<Exiv2::Image> open_exiv2(const Glib::ustring& fname,
+                                         bool check_exif)
+{
+#ifdef EXV_UNICODE_PATH
+    glong ws_size = 0;
+    gunichar2* const ws = g_utf8_to_utf16(fname.c_str(), -1, nullptr, &ws_size, nullptr);
+    std::wstring wfname;
+    wfname.reserve(ws_size);
+    for (glong i = 0; i < ws_size; ++i) {
+        wfname.push_back(ws[i]);
+    }
+    g_free(ws);
+    auto image = Exiv2::ImageFactory::open(wfname);
+#else
+    auto image = Exiv2::ImageFactory::open(Glib::filename_from_utf8(fname));
+#endif
+    image->readMetadata();
+    if (!image->good() || (check_exif && image->exifData().empty())) {
+#if EXIV2_TEST_VERSION(0,27,0)
+        auto error_code = Exiv2::ErrorCode::kerErrorMessage;
+#else
+        auto error_code = 1;
+#endif
+        throw Exiv2::Error(error_code, "exiv2: invalid image");
+    }
+    std::unique_ptr<Exiv2::Image> ret(image.release());
+    return ret;
+}
+
+
+template <class Data, class Key>
+void clear_metadata_key(Data &data, const Key &key)
+{
+    while (true) {
+        auto it = data.findKey(key);
+        if (it == data.end()) {
+            break;
+        } else {
+            data.erase(it);
+        }
+    }
+}
+
+template <typename Iterator, typename Integer = std::size_t>
+auto to_long(const Iterator &iter, Integer n = Integer{0}) -> decltype(
+#if EXIV2_TEST_VERSION(0,28,0)
+    iter->toInt64()
+) {
+    return iter->toInt64(n);
+#else
+    iter->toLong()
+) {
+    return iter->toLong(n);
+#endif
+}
+
+} // namespace
+
+
+Exiv2Metadata::Exiv2Metadata():
+    src_(""),
+    merge_xmp_(false),
+    image_(nullptr),
+    exif_(new rtengine::procparams::ExifPairs),
+    iptc_(new rtengine::procparams::IPTCPairs)
+{
+}
+
+
+Exiv2Metadata::Exiv2Metadata(const Glib::ustring &path):
+    src_(path),
+    merge_xmp_(settings->metadata_xmp_sync != Settings::MetadataXmpSync::NONE),
+    image_(nullptr),
+    exif_(new rtengine::procparams::ExifPairs),
+    iptc_(new rtengine::procparams::IPTCPairs)
+{
+}
+
+
+Exiv2Metadata::Exiv2Metadata(const Glib::ustring &path, bool merge_xmp_sidecar):
+    src_(path),
+    merge_xmp_(merge_xmp_sidecar),
+    image_(nullptr),
+    exif_(new rtengine::procparams::ExifPairs),
+    iptc_(new rtengine::procparams::IPTCPairs)
+{
+}
+
+
+void Exiv2Metadata::load() const
+{
+    if (!src_.empty() && !image_.get() && Glib::file_test(src_.c_str(), Glib::FILE_TEST_EXISTS)) {
+        CacheVal val;
+        auto finfo = Gio::File::create_for_path(src_)->query_info(G_FILE_ATTRIBUTE_TIME_MODIFIED);
+        Glib::TimeVal xmp_mtime(0, 0);
+        if (merge_xmp_) {
+            auto xmpname = xmpSidecarPath(src_);
+            if (Glib::file_test(xmpname.c_str(), Glib::FILE_TEST_EXISTS)) {
+                xmp_mtime = Gio::File::create_for_path(xmpname)->query_info(G_FILE_ATTRIBUTE_TIME_MODIFIED)->modification_time();
+            }
+        }
+
+        if (cache_ && cache_->get(src_, val) && val.image_mtime >= finfo->modification_time() && val.use_xmp == merge_xmp_ && val.xmp_mtime >= xmp_mtime) {
+            image_ = val.image;
+        } else {
+            auto img = open_exiv2(src_, true);
+            image_.reset(img.release());
+            if (merge_xmp_) {
+                do_merge_xmp(image_.get(), false);
+            }
+            if (cache_) {
+                val.image = image_;
+                val.image_mtime = finfo->modification_time();
+                val.xmp_mtime = xmp_mtime;
+                val.use_xmp = merge_xmp_;
+                cache_->set(src_, val);
+            }
+        }
+    }
+}
+
+Exiv2::ExifData& Exiv2Metadata::exifData()
+{
+    return image_.get() ? image_->exifData() : exif_data_;
+}
+
+const Exiv2::ExifData& Exiv2Metadata::exifData() const
+{
+    return const_cast<Exiv2Metadata *>(this)->exifData();
+}
+
+Exiv2::IptcData& Exiv2Metadata::iptcData()
+{
+    return image_.get() ? image_->iptcData() : iptc_data_;
+}
+
+const Exiv2::IptcData& Exiv2Metadata::iptcData() const
+{
+    return const_cast<Exiv2Metadata *>(this)->iptcData();
+}
+
+Exiv2::XmpData& Exiv2Metadata::xmpData()
+{
+    return image_.get() ? image_->xmpData() : xmp_data_;
+}
+
+const Exiv2::XmpData& Exiv2Metadata::xmpData() const
+{
+    return const_cast<Exiv2Metadata *>(this)->xmpData();
+}
+
+const Glib::ustring& Exiv2Metadata::filename() const
+{
+    return src_;
+}
+
+const rtengine::procparams::ExifPairs& Exiv2Metadata::exif() const
+{
+    return *exif_;
+}
+
+const rtengine::procparams::IPTCPairs& Exiv2Metadata::iptc() const
+{
+    return *iptc_;
+}
+
+void Exiv2Metadata::setExif(const rtengine::procparams::ExifPairs &exif)
+{
+    *exif_ = exif;
+}
+
+void Exiv2Metadata::setIptc(const rtengine::procparams::IPTCPairs &iptc)
+{
+    *iptc_ = iptc;
+}
+
+void Exiv2Metadata::do_merge_xmp(Exiv2::Image *dst, bool keep_all) const
+{
+    try { 
+        auto xmp = getXmpSidecar(src_);
+        Exiv2::ExifData exif;
+        Exiv2::IptcData iptc;
+        Exiv2::copyXmpToIptc(xmp, iptc);
+        Exiv2::moveXmpToExif(xmp, exif);
+        std::unordered_map<std::string, std::unordered_set<std::string>> seen;
+
+        if (!keep_all) {
+            remove_unwanted(exif);
+        }
+        
+        for (auto &datum : exif) {
+            dst->exifData()[datum.key()] = datum;
+        }
+        for (auto &datum : iptc) {
+            auto &s = seen[datum.key()];
+            if (s.empty()) {
+                clear_metadata_key(dst->iptcData(), Exiv2::IptcKey(datum.key()));
+                dst->iptcData()[datum.key()] = datum;
+                s.insert(datum.toString());
+            } else if (s.insert(datum.toString()).second) {
+                dst->iptcData().add(datum);
+            }
+        }
+        seen.clear();
+        for (auto &datum : xmp) {
+            auto &s = seen[datum.key()];
+            if (s.empty()) {
+                clear_metadata_key(dst->xmpData(), Exiv2::XmpKey(datum.key()));
+                dst->xmpData()[datum.key()] = datum;
+                s.insert(datum.toString());
+            } else if (s.insert(datum.toString()).second) {
+                dst->xmpData().add(datum);
+            }
+        }
+    } catch (std::exception &exc) {
+        if (settings->verbose) {
+            std::cerr << "Error loading metadata from XMP sidecar: "
+                      << exc.what() << std::endl;
+        }
+    }
+}
+
+
+void Exiv2Metadata::saveToImage(const Glib::ustring &path, bool preserve_all_tags) const
+{
+    auto dst = open_exiv2(path, false);
+    if (image_.get()) {
+        dst->setIptcData(image_->iptcData());
+        dst->setXmpData(image_->xmpData());
+        if (merge_xmp_) {
+            do_merge_xmp(dst.get(), preserve_all_tags);
+        }
+        auto srcexif = image_->exifData();
+        if (!preserve_all_tags) {
+            remove_unwanted(srcexif);
+        }
+        //dst->setExifData(srcexif);
+        for (auto &tag : srcexif) {
+            if (tag.count() > 0) {
+                dst->exifData()[tag.key()] = tag;
+            }
+        }
+    } else {
+        dst->setExifData(exif_data_);
+        dst->setIptcData(iptc_data_);
+        dst->setXmpData(xmp_data_);
+    }
+
+    dst->exifData()["Exif.Image.Software"] = "RawTherapee " RTVERSION;
+    import_exif_pairs(dst->exifData());
+    import_iptc_pairs(dst->iptcData());
+    bool xmp_tried = false;
+    bool iptc_tried = false;
+    for (int i = 0; i < 3; ++i) {
+        try {
+            dst->writeMetadata();
+            return;
+        } catch (Exiv2::Error &exc) {
+            if (exc.code() == Exiv2::ErrorCode::kerTooLargeJpegSegment) {
+                std::string msg = exc.what();
+                if (msg.find("XMP") != std::string::npos &&
+                    !dst->xmpData().empty()) {
+                    dst->xmpData().clear();
+                    if (!xmp_tried && merge_xmp_) {
+                        do_merge_xmp(dst.get(), preserve_all_tags);
+                        xmp_tried = true;
+                    }
+                } else if (msg.find("IPTC") != std::string::npos &&
+                           !dst->iptcData().empty()) {
+                    dst->iptcData().clear();
+                    if (!iptc_tried) {
+                        import_iptc_pairs(dst->iptcData());
+                        iptc_tried = true;
+                    }
+                }
+            } else {
+                throw exc;
+            }
+        }
+    }
+}
+
+
+void Exiv2Metadata::remove_unwanted(Exiv2::ExifData &dst) const
+{                
+    Exiv2::ExifThumb thumb(dst);
+    thumb.erase();
+
+    static const std::set<std::string> badtags = {
+        "Exif.Image.Orientation",
+        "Exif.Image2.JPEGInterchangeFormat",
+        "Exif.Image2.JPEGInterchangeFormatLength",
+        "Exif.Image.NewSubfileType",
+        "Exif.Image.SubfileType",
+        "Exif.Image.ImageWidth",
+        "Exif.Image.ImageLength",
+        "Exif.Image.BitsPerSample",
+        "Exif.Image.Compression",
+        "Exif.Image.PhotometricInterpretation",
+        "Exif.Image.Thresholding",
+        "Exif.Image.CellWidth",
+        "Exif.Image.CellLength",
+        "Exif.Image.FillOrder",
+        "Exif.Image.StripOffsets",
+        "Exif.Image.Orientation",
+        "Exif.Image.SamplesPerPixel",
+        "Exif.Image.RowsPerStrip",
+        "Exif.Image.StripByteCounts",
+        "Exif.Image.XResolution",
+        "Exif.Image.YResolution",
+        "Exif.Image.PlanarConfiguration",
+        "Exif.Image.GrayResponseUnit",
+        "Exif.Image.GrayResponseCurve",
+        "Exif.Image.T4Options",
+        "Exif.Image.T6Options",
+        "Exif.Image.ResolutionUnit",
+        "Exif.Image.PageNumber",
+        "Exif.Image.Predictor",
+        "Exif.Image.TileWidth",
+        "Exif.Image.TileLength",
+        "Exif.Image.TileOffsets",
+        "Exif.Image.TileByteCounts",
+        "Exif.Image.SubIFDs",
+        "Exif.Image.ExtraSamples",
+        "Exif.Image.SampleFormat",
+        "Exif.Image.SMinSampleValue",
+        "Exif.Image.SMaxSampleValue",
+        "Exif.Image.Indexed",
+        "Exif.Image.JPEGTables",
+        "Exif.Image.OPIProxy",
+        "Exif.Image.JPEGProc",
+        "Exif.Image.JPEGInterchangeFormat",
+        "Exif.Image.JPEGInterchangeFormatLength",
+        "Exif.Image.JPEGRestartInterval",
+        "Exif.Image.JPEGLosslessPredictors",
+        "Exif.Image.JPEGPointTransforms",
+        "Exif.Image.JPEGQTables",
+        "Exif.Image.JPEGDCTables",
+        "Exif.Image.JPEGACTables",
+        "Exif.Image.TIFFEPStandardID",
+        "Exif.Image.DNGVersion",
+        "Exif.Image.DNGBackwardVersion",
+        "Exif.Image.DNGPrivateData",
+        "Exif.Image.OriginalRawFileData",
+        "Exif.Image.SubTileBlockSize",
+        "Exif.Image.RowInterleaveFactor",
+        "Exif.Photo.ComponentsConfiguration",
+        "Exif.Photo.CompressedBitsPerPixel"
+    };
+
+    static const std::vector<std::string> badpatterns = {
+        "Exif.SubImage"
+    };
+
+    if (exif_keys_ && !src_.empty()) {
+        try {
+            FramesData fd(src_);
+            fd.fillBasicTags(dst);
+        } catch (std::exception &exc) {
+            std::cout << "Error reading metadata from " << src_
+                      << std::endl;
+        }
+    }
+    
+    for (auto it = dst.begin(); it != dst.end(); ) {
+        int relevant = exif_keys_ ? (exif_keys_->find(it->key()) != exif_keys_->end() ? 1 : 0) : -1;
+        if (badtags.find(it->key()) != badtags.end() && relevant != 1) {
+            it = dst.erase(it);
+        } else if (relevant == 0) {
+            it = dst.erase(it);
+        } else {
+            bool found = false;
+            for (auto &p : badpatterns) {
+                if (it->key().find(p) == 0) {
+                    it = dst.erase(it);
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                ++it;
+            }
+        }
+    }    
+}
+
+
+void Exiv2Metadata::import_exif_pairs(Exiv2::ExifData &out) const
+{
+    for (auto &p : *exif_) {
+        try {
+            out[p.first] = p.second;
+        } catch (std::exception &exc) {
+            if (settings->verbose) {
+                std::cout << "Error setting " << p.first << " to " << p.second
+                          << ": " << exc.what() << std::endl;
+            }
+        }
+    }
+}
+
+
+void Exiv2Metadata::import_iptc_pairs(Exiv2::IptcData &out) const
+{
+    for (auto &p : *iptc_) {
+        try {
+            auto &v = p.second;
+            if (v.size() >= 1) {
+                clear_metadata_key(out, Exiv2::IptcKey(p.first));
+                Exiv2::Iptcdatum d(Exiv2::IptcKey(p.first));
+                d.setValue(v[0]);
+                out[p.first] = d;
+                for (size_t j = 1; j < v.size(); ++j) {
+                    d.setValue(v[j]);
+                    out.add(d);
+                }
+            }
+        } catch (std::exception &exc) {
+            if (settings->verbose) {
+                std::cout << "Error setting " << p.first
+                          << ": " << exc.what() << std::endl;
+            }
+        }
+    }
+}
+
+
+void Exiv2Metadata::saveToXmp(const Glib::ustring &path) const
+{
+    Exiv2::XmpData xmp;
+    Exiv2::copyExifToXmp(exifData(), xmp);
+    Exiv2::copyIptcToXmp(iptcData(), xmp);
+    for (auto &datum : xmpData()) {
+        xmp[datum.key()] = datum;
+    }
+    Exiv2::ExifData exif;
+    Exiv2::IptcData iptc;
+    import_exif_pairs(exif);
+    import_iptc_pairs(iptc);
+    Exiv2::copyExifToXmp(exif, xmp);
+    Exiv2::copyIptcToXmp(iptc, xmp);
+
+    std::string data;
+    bool err = false;
+    if (Exiv2::XmpParser::encode(data, xmp, Exiv2::XmpParser::omitPacketWrapper|Exiv2::XmpParser::useCompactFormat) != 0) {
+        err = true;
+    } else {
+        FILE *out = g_fopen(path.c_str(), "wb");
+        if (!out || fputs(data.c_str(), out) == EOF) {
+            err = true;
+        }
+        if (out) {
+            fclose(out);
+        }
+    }
+
+    if (err) {
+        throw Error("error saving XMP sidecar " + path);
+    }
+}
+
+
+void Exiv2Metadata::setExifKeys(const std::vector<std::string> *keys)
+{
+    exif_keys_.reset();
+    if (keys) {
+        exif_keys_ = std::make_shared<std::unordered_set<std::string>>();
+        exif_keys_->insert(keys->begin(), keys->end());
+    }
+}
+
+
+void Exiv2Metadata::getDimensions(int &w, int &h) const
+{
+    if (image_) {
+        if (dynamic_cast<const Exiv2::XmpSidecar *>(image_.get())) {
+            auto &exif = image_->exifData();
+            auto itw = exif.findKey(Exiv2::ExifKey("Exif.Image.ImageWidth"));
+            auto ith = exif.findKey(Exiv2::ExifKey("Exif.Image.ImageLength"));
+            if (itw != exif.end() && ith != exif.end()) {
+                w = to_long(itw);
+                h = to_long(ith);
+            } else {
+                w = h = -1;
+            }
+        } else {
+            w = image_->pixelWidth();
+            h = image_->pixelHeight();
+        }
+    } else {
+        w = h = -1;
+    }
+}
+
+
+Glib::ustring Exiv2Metadata::xmpSidecarPath(const Glib::ustring &path)
+{
+    Glib::ustring fn = path;
+    if (settings->xmp_sidecar_style == Settings::XmpSidecarStyle::STD) {
+        fn = removeExtension(fn);
+    }
+    return fn + ".xmp";
+}
+
+
+Exiv2::XmpData Exiv2Metadata::getXmpSidecar(const Glib::ustring &path)
+{
+    Exiv2::XmpData ret;
+    auto fname = xmpSidecarPath(path);
+    if (Glib::file_test(fname, Glib::FILE_TEST_EXISTS)) {
+        auto image = open_exiv2(fname, false);
+        ret = image->xmpData();
+    }
+    return ret;
+}
+
+
+void Exiv2Metadata::init()
+{
+    cache_.reset(new ImageCache(IMAGE_CACHE_SIZE));
+    Exiv2::XmpParser::initialize();
+#ifdef EXV_ENABLE_BMFF
+    Exiv2::enableBMFF(true);
+#endif
+}
+
+
+void Exiv2Metadata::cleanup()
+{
+    Exiv2::XmpParser::terminate();
+}
+
+
+Exiv2::ExifData Exiv2Metadata::getOutputExifData() const
+{
+    Exiv2::ExifData exif = exifData();
+    try {
+        auto xmp = getXmpSidecar(src_);
+        Exiv2::moveXmpToExif(xmp, exif);
+    } catch (std::exception &exc) {
+        if (settings->verbose) {
+            std::cerr << "Error loading metadata from XMP sidecar: "
+                      << exc.what() << std::endl;
+        }
+    }
+    remove_unwanted(exif);
+    import_exif_pairs(exif);
+    for (auto it = exif.begin(); it != exif.end(); ) {
+        if (it->count() > 0) {
+            ++it;
+        } else {
+            it = exif.erase(it);
+        }
+    }
+    return exif;
+}
+
+
+} // namespace rtengine
diff --git a/rtengine/metadata.h b/rtengine/metadata.h
new file mode 100644
index 000000000..7424b2720
--- /dev/null
+++ b/rtengine/metadata.h
@@ -0,0 +1,100 @@
+/* -*- C++ -*-
+ *
+ *  This file is part of RawTherapee.
+ *
+ *  Copyright (c) 2019 Alberto Griggio <alberto.griggio@gmail.com>
+ *
+ *  RawTherapee is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  RawTherapee is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with RawTherapee.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#pragma once
+
+#include <glibmm.h>
+#include <exiv2/exiv2.hpp>
+#include <memory>
+#include <unordered_set>
+#include "procparams.h"
+#include "cache.h"
+
+namespace rtengine {
+
+class Exiv2Metadata final
+{
+public:
+    Exiv2Metadata();
+    explicit Exiv2Metadata(const Glib::ustring& path);
+    Exiv2Metadata(const Glib::ustring& path, bool merge_xmp_sidecar);
+
+    void load() const;
+    
+    Exiv2::ExifData& exifData();
+    const Exiv2::ExifData& exifData() const;
+    
+    Exiv2::IptcData& iptcData();
+    const Exiv2::IptcData& iptcData() const;
+    
+    Exiv2::XmpData& xmpData();
+    const Exiv2::XmpData& xmpData() const;
+
+    const Glib::ustring& filename() const;
+    const rtengine::procparams::ExifPairs& exif() const;
+    const rtengine::procparams::IPTCPairs& iptc() const;
+    void setExif(const rtengine::procparams::ExifPairs& exif);
+    void setIptc(const rtengine::procparams::IPTCPairs& iptc);
+    
+    void saveToImage(const Glib::ustring& path, bool preserve_all_tags) const;
+    void saveToXmp(const Glib::ustring& path) const;
+
+    void setExifKeys(const std::vector<std::string> *keys);
+
+    void getDimensions(int &w, int &h) const;
+
+    Exiv2::ExifData getOutputExifData() const;
+
+    static Glib::ustring xmpSidecarPath(const Glib::ustring& path);
+    static Exiv2::XmpData getXmpSidecar(const Glib::ustring& path);
+
+    static void init();
+    static void cleanup();
+   
+private:
+    void do_merge_xmp(Exiv2::Image* dst, bool keep_all) const;
+    void import_exif_pairs(Exiv2::ExifData& out) const;
+    void import_iptc_pairs(Exiv2::IptcData& out) const;
+    void remove_unwanted(Exiv2::ExifData& dst) const;
+    
+    Glib::ustring src_;
+    bool merge_xmp_;
+    mutable std::shared_ptr<Exiv2::Image> image_;
+    std::unique_ptr<rtengine::procparams::ExifPairs> exif_;
+    std::unique_ptr<rtengine::procparams::IPTCPairs> iptc_;
+    Exiv2::ExifData exif_data_;
+    Exiv2::IptcData iptc_data_;
+    Exiv2::XmpData xmp_data_;
+
+    std::shared_ptr<std::unordered_set<std::string>> exif_keys_;
+
+    struct CacheVal {
+        std::shared_ptr<Exiv2::Image> image;
+        Glib::TimeVal image_mtime;
+        Glib::TimeVal xmp_mtime;
+        bool use_xmp;
+        CacheVal(): image(nullptr), image_mtime(), xmp_mtime(), use_xmp(false) {}
+    };
+    //typedef std::pair<std::shared_ptr<Exiv2::Image>, Glib::TimeVal> CacheVal;
+    typedef Cache<Glib::ustring, CacheVal> ImageCache;
+    static std::unique_ptr<ImageCache> cache_;
+};
+
+} // namespace rtengine
diff --git a/rtengine/previewimage.cc b/rtengine/previewimage.cc
index afaf0cbca..e131211ce 100644
--- a/rtengine/previewimage.cc
+++ b/rtengine/previewimage.cc
@@ -61,9 +61,8 @@ PreviewImage::PreviewImage (const Glib::ustring &fname, const Glib::ustring &ext
                 data = tpp->getImage8Data();
             }
         } else {
-            rtengine::RawMetaDataLocation ri;
             eSensorType sensorType = rtengine::ST_NONE;
-            tpp = rtengine::Thumbnail::loadQuickFromRaw (fname, ri, sensorType, width, height, 1, true, true);
+            tpp = rtengine::Thumbnail::loadQuickFromRaw (fname, sensorType, width, height, 1, true, true);
 
             if (tpp) {
                 data = tpp->getImage8Data();
diff --git a/rtengine/procparams.cc b/rtengine/procparams.cc
index 8b1dbaefd..f6831a6bf 100644
--- a/rtengine/procparams.cc
+++ b/rtengine/procparams.cc
@@ -232,6 +232,17 @@ void getFromKeyfile(
     }
 }
 
+void getFromKeyfile(
+    const Glib::KeyFile& keyfile,
+    const Glib::ustring& group_name,
+    const Glib::ustring& key,
+    std::vector<std::string>& value
+)
+{
+    auto tmpval = keyfile.get_string_list(group_name, key);
+    value.assign(tmpval.begin(), tmpval.end());
+}
+
 template<typename T>
 bool assignFromKeyfile(
     const Glib::KeyFile& keyfile,
@@ -360,6 +371,17 @@ void putToKeyfile(
     keyfile.set_double_list(group_name, key, list);
 }
 
+void putToKeyfile(
+    const Glib::ustring& group_name,
+    const Glib::ustring& key,
+    const std::vector<std::string>& value,
+    Glib::KeyFile& keyfile
+)
+{
+    const Glib::ArrayHandle<Glib::ustring> list = value;
+    keyfile.set_string_list(group_name, key, list);
+}
+
 void putToKeyfile(
     const Glib::ustring& group_name,
     const Glib::ustring& key,
@@ -411,7 +433,8 @@ bool saveToKeyfile(
     return false;
 }
 
-}
+
+} // namespace
 
 namespace rtengine
 {
@@ -1408,7 +1431,7 @@ bool WBParams::isPanningRelatedChange(const WBParams& other) const
             enabled == other.enabled
             && (
                 (
-                    method == "Camera" 
+                    method == "Camera"
                     && other.method == "Camera"
                 )
             || (
@@ -2469,25 +2492,25 @@ WaveletParams::WaveletParams() :
     },
     blcurve{
         static_cast<double>(FCT_MinMaxCPoints),
-        0.0, 
-        0.0, 
-        0.0, 
-        0.35, 
-        0.5, 
-        0., 
+        0.0,
+        0.0,
+        0.0,
+        0.35,
+        0.5,
+        0.,
         0.35,
         0.35,
         1.0,
         0.0,
         0.35,
         0.35
-/*      
+/*
         0.0,
-        0.35, 
-        0.35, 
-        1.0, 
-        0.0, 
-        0.35, 
+        0.35,
+        0.35,
+        1.0,
+        0.0,
+        0.35,
         0.35
 */
     },
@@ -5778,21 +5801,6 @@ Glib::ustring RAWParams::getFlatFieldBlurTypeString(FlatFieldBlurType type)
 }
 
 
-MetaDataParams::MetaDataParams():
-    mode(MetaDataParams::TUNNEL)
-{
-}
-
-bool MetaDataParams::operator==(const MetaDataParams &other) const
-{
-    return mode == other.mode;
-}
-
-bool MetaDataParams::operator!=(const MetaDataParams &other) const
-{
-    return !(*this == other);
-}
-
 FilmNegativeParams::FilmNegativeParams() :
     enabled(false),
     redRatio(1.36),
@@ -5845,6 +5853,96 @@ bool FilmNegativeParams::operator !=(const FilmNegativeParams& other) const
     return !(*this == other);
 }
 
+
+namespace {
+
+const std::map<std::string, std::string> exif_keys = {
+    {"Copyright", "Exif.Image.Copyright"},
+    {"Artist", "Exif.Image.Artist"},
+    {"ImageDescription", "Exif.Image.ImageDescription"},
+    {"Exif.UserComment", "Exif.Photo.UserComment"},
+    {"ISOSpeed", "Exif.Photo.ISOSpeedRatings"},
+    {"FNumber", "Exif.Photo.FNumber"},
+    {"ShutterSpeed", "Exif.Photo.ExposureTime"},
+    {"FocalLength", "Exif.Photo.FocalLength"},
+    {"ExpComp", "Exif.Photo.ExposureBiasValue"},
+    {"Flash", "Exif.Photo.Flash"},
+    {"Make", "Exif.Image.Make"},
+    {"Model", "Exif.Image.Model"},
+    {"Lens", "Exif.Photo.LensModel"},
+    {"DateTime", "Exif.Photo.DateTimeOriginal"},
+    {"XResolution", "Exif.Image.XResolution"},
+    {"YResolution", "Exif.Image.YResolution"}
+};
+
+const std::map<std::string, std::string> iptc_keys = {
+    {"Title", "Iptc.Application2.ObjectName"},
+    {"Category", "Iptc.Application2.Category"},
+    {"SupplementalCategories", "Iptc.Application2.SuppCategory"},
+    {"Keywords", "Iptc.Application2.Keywords"},
+    {"Instructions", "Iptc.Application2.SpecialInstructions"},
+    {"DateCreated", "Iptc.Application2.DateCreated"},
+    {"Creator", "Iptc.Application2.Byline"},
+    {"CreatorJobTitle", "Iptc.Application2.BylineTitle"},
+    {"City", "Iptc.Application2.City"},
+    {"Province", "Iptc.Application2.ProvinceState"},
+    {"Country", "Iptc.Application2.CountryName"},
+    {"TransReference", "Iptc.Application2.TransmissionReference"},
+    {"Headline", "Iptc.Application2.Headline"},
+    {"Credit", "Iptc.Application2.Credit"},
+    {"Source", "Iptc.Application2.Source"},
+    {"Copyright", "Iptc.Application2.Copyright"},
+    {"Caption", "Iptc.Application2.Caption"},
+    {"CaptionWriter", "Iptc.Application2.Writer"}
+};
+
+} // namespace
+
+
+std::vector<std::string> MetaDataParams::basicExifKeys = {
+    "Exif.Image.Copyright",
+    "Exif.Image.Artist",
+    "Exif.Image.ImageDescription",
+    "Exif.Photo.UserComment",
+    "Exif.Image.Make",
+    "Exif.Image.Model",
+    "Exif.Photo.LensModel",
+    "Exif.Photo.FNumber",
+    "Exif.Photo.ExposureTime",
+    "Exif.Photo.FocalLength",
+    "Exif.Photo.ISOSpeedRatings",
+    "Exif.Photo.ExposureBiasValue",
+    "Exif.Photo.Flash",
+    "Exif.Photo.DateTimeOriginal",
+    "Exif.Image.XResolution",
+    "Exif.Image.YResolution"
+};
+
+
+MetaDataParams::MetaDataParams():
+    mode(MetaDataParams::EDIT),
+    exifKeys{},
+    exif{},
+    iptc{}
+{
+    exifKeys = basicExifKeys;
+}
+
+
+bool MetaDataParams::operator==(const MetaDataParams &other) const
+{
+    return mode == other.mode
+        && exifKeys == other.exifKeys
+        && exif == other.exif
+        && iptc == other.iptc;
+}
+
+bool MetaDataParams::operator!=(const MetaDataParams &other) const
+{
+    return !(*this == other);
+}
+
+
 ProcParams::ProcParams()
 {
     setDefaults();
@@ -5943,8 +6041,8 @@ void ProcParams::setDefaults()
     raw = {};
 
     metadata = {};
-    exif.clear();
-    iptc.clear();
+    //exif.clear();
+    //iptc.clear();
 
     // -1 means that there's no pp3 data with rank yet. In this case, the
     // embedded Rating metadata should take precedence. -1 should never be
@@ -5971,7 +6069,9 @@ int ProcParams::save(const Glib::ustring& fname, const Glib::ustring& fname2, bo
         keyFile.set_string("Version", "AppVersion", RTVERSION);
         keyFile.set_integer("Version", "Version", PPVERSION);
 
-        saveToKeyfile(!pedited || pedited->general.rank, "General", "Rank", rank, keyFile);
+        if (rank >= 0) {
+            saveToKeyfile(!pedited || pedited->general.rank, "General", "Rank", rank, keyFile);
+        }
         saveToKeyfile(!pedited || pedited->general.colorlabel, "General", "ColorLabel", colorlabel, keyFile);
         saveToKeyfile(!pedited || pedited->general.intrash, "General", "InTrash", inTrash, keyFile);
 
@@ -6274,9 +6374,9 @@ int ProcParams::save(const Glib::ustring& fname, const Glib::ustring& fname2, bo
 
 // Dehaze
         saveToKeyfile(!pedited || pedited->dehaze.enabled, "Dehaze", "Enabled", dehaze.enabled, keyFile);
-        saveToKeyfile(!pedited || pedited->dehaze.strength, "Dehaze", "Strength", dehaze.strength, keyFile);        
-        saveToKeyfile(!pedited || pedited->dehaze.showDepthMap, "Dehaze", "ShowDepthMap", dehaze.showDepthMap, keyFile);        
-        saveToKeyfile(!pedited || pedited->dehaze.depth, "Dehaze", "Depth", dehaze.depth, keyFile);        
+        saveToKeyfile(!pedited || pedited->dehaze.strength, "Dehaze", "Strength", dehaze.strength, keyFile);
+        saveToKeyfile(!pedited || pedited->dehaze.showDepthMap, "Dehaze", "ShowDepthMap", dehaze.showDepthMap, keyFile);
+        saveToKeyfile(!pedited || pedited->dehaze.depth, "Dehaze", "Depth", dehaze.depth, keyFile);
         saveToKeyfile(!pedited || pedited->dehaze.depth, "Dehaze", "Saturation", dehaze.saturation, keyFile);
 
 // Directional pyramid denoising
@@ -7637,6 +7737,7 @@ int ProcParams::save(const Glib::ustring& fname, const Glib::ustring& fname2, bo
 
 // MetaData
         saveToKeyfile(!pedited || pedited->metadata.mode, "MetaData", "Mode", metadata.mode, keyFile);
+        saveToKeyfile(!pedited || pedited->metadata.exifKeys, "MetaData", "ExifKeys", metadata.exifKeys, keyFile);
 
 // Film negative
         saveToKeyfile(!pedited || pedited->filmNegative.enabled, "Film Negative", "Enabled", filmNegative.enabled, keyFile);
@@ -7650,7 +7751,7 @@ int ProcParams::save(const Glib::ustring& fname, const Glib::ustring& fname2, bo
             saveToKeyfile(!pedited || pedited->filmNegative.refInput, "Film Negative", "GreenBase", filmNegative.refInput.g, keyFile);
             saveToKeyfile(!pedited || pedited->filmNegative.refInput, "Film Negative", "BlueBase", filmNegative.refInput.b, keyFile);
         }
-        
+
         saveToKeyfile(!pedited || pedited->filmNegative.colorSpace, "Film Negative", "ColorSpace", toUnderlying(filmNegative.colorSpace), keyFile);
         saveToKeyfile(!pedited || pedited->filmNegative.refInput, "Film Negative", "RefInput", filmNegative.refInput, keyFile);
         saveToKeyfile(!pedited || pedited->filmNegative.refOutput, "Film Negative", "RefOutput", filmNegative.refOutput, keyFile);
@@ -7664,16 +7765,30 @@ int ProcParams::save(const Glib::ustring& fname, const Glib::ustring& fname2, bo
 
 // EXIF change list
         if (!pedited || pedited->exif) {
-            for (ExifPairs::const_iterator i = exif.begin(); i != exif.end(); ++i) {
-                keyFile.set_string("Exif", i->first, i->second);
+            std::map<Glib::ustring, Glib::ustring> m;
+            for (auto &p : exif_keys) {
+                m[p.second] = p.first;
+            }
+            for (auto &p : metadata.exif) {
+                auto it = m.find(p.first);
+                if (it != m.end()) {
+                    keyFile.set_string("Exif", it->second, p.second);
+                }
             }
         }
 
 // IPTC change list
         if (!pedited || pedited->iptc) {
-            for (IPTCPairs::const_iterator i = iptc.begin(); i != iptc.end(); ++i) {
-                Glib::ArrayHandle<Glib::ustring> values = i->second;
-                keyFile.set_string_list("IPTC", i->first, values);
+            std::map<std::string, std::string> m;
+            for (auto &p : iptc_keys) {
+                m[p.second] = p.first;
+            }
+            for (auto &p : metadata.iptc) {
+                auto it = m.find(p.first);
+                if (it != m.end()) {
+                    Glib::ArrayHandle<Glib::ustring> values = p.second;
+                    keyFile.set_string_list("IPTC", it->second, values);
+                }
             }
         }
 
@@ -8210,7 +8325,7 @@ int ProcParams::load(const Glib::ustring& fname, ParamsEdited* pedited)
                     pedited->colorappearance.complexmethod = true;
                 }
             }
-            
+
             if (keyFile.has_key("Color appearance", "ModelCat")) {
                 assignFromKeyfile(keyFile, "Color appearance", "ModelCat", pedited, colorappearance.modelmethod, pedited->colorappearance.modelmethod);
             } else if (colorappearance.enabled) {
@@ -8220,7 +8335,7 @@ int ProcParams::load(const Glib::ustring& fname, ParamsEdited* pedited)
                 }
             }
             assignFromKeyfile(keyFile, "Color appearance", "CatCat", pedited, colorappearance.catmethod, pedited->colorappearance.catmethod);
-            
+
             assignFromKeyfile(keyFile, "Color appearance", "Surround", pedited, colorappearance.surround, pedited->colorappearance.surround);
             assignFromKeyfile(keyFile, "Color appearance", "Surrsrc", pedited, colorappearance.surrsrc, pedited->colorappearance.surrsrc);
             assignFromKeyfile(keyFile, "Color appearance", "AdaptLum", pedited, colorappearance.adaplum, pedited->colorappearance.adaplum);
@@ -10088,7 +10203,7 @@ int ProcParams::load(const Glib::ustring& fname, ParamsEdited* pedited)
                 assignFromKeyfile(keyFile, "Dehaze", "Saturation", pedited, dehaze.saturation, pedited->dehaze.saturation);
             }
         }
-        
+
         if (keyFile.has_group("Film Simulation")) {
             assignFromKeyfile(keyFile, "Film Simulation", "Enabled", pedited, filmSimulation.enabled, pedited->filmSimulation.enabled);
 			assignFromKeyfile(keyFile, "Film Simulation", "ClutFilename", pedited, filmSimulation.clutFilename, pedited->filmSimulation.clutFilename);
@@ -10520,20 +10635,25 @@ int ProcParams::load(const Glib::ustring& fname, ParamsEdited* pedited)
         }
 
         if (keyFile.has_group("MetaData")) {
-            int mode = int(MetaDataParams::TUNNEL);
+            int mode = int(MetaDataParams::EDIT);
             assignFromKeyfile(keyFile, "MetaData", "Mode", pedited, mode, pedited->metadata.mode);
 
             if (mode >= int(MetaDataParams::TUNNEL) && mode <= int(MetaDataParams::STRIP)) {
                 metadata.mode = static_cast<MetaDataParams::Mode>(mode);
             }
+
+            assignFromKeyfile(keyFile, "MetaData", "ExifKeys", pedited, metadata.exifKeys, pedited->metadata.exifKeys);
         }
 
         if (keyFile.has_group("Exif")) {
             for (const auto& key : keyFile.get_keys("Exif")) {
-                exif[key] = keyFile.get_string("Exif", key);
+                auto it = exif_keys.find(key);
+                if (it != exif_keys.end()) {
+                    metadata.exif[it->second] = keyFile.get_string("Exif", key);
 
-                if (pedited) {
-                    pedited->exif = true;
+                    if (pedited) {
+                        pedited->exif = true;
+                    }
                 }
             }
         }
@@ -10553,16 +10673,22 @@ int ProcParams::load(const Glib::ustring& fname, ParamsEdited* pedited)
         if (keyFile.has_group("IPTC")) {
             for (const auto& key : keyFile.get_keys("IPTC")) {
                 // does this key already exist?
-                const IPTCPairs::iterator element = iptc.find(key);
+                auto it = iptc_keys.find(key);
+                if (it == iptc_keys.end()) {
+                    continue;
+                }
 
-                if (element != iptc.end()) {
+                auto kk = it->second;
+                const IPTCPairs::iterator element = metadata.iptc.find(kk);
+
+                if (element != metadata.iptc.end()) {
                     // it already exist so we cleanup the values
                     element->second.clear();
                 }
 
                 // TODO: look out if merging Keywords and SupplementalCategories from the procparams chain would be interesting
                 for (const auto& currLoadedTagValue : keyFile.get_string_list("IPTC", key)) {
-                    iptc[key].push_back(currLoadedTagValue);
+                    metadata.iptc[kk].push_back(currLoadedTagValue);
                 }
 
                 if (pedited) {
@@ -10641,8 +10767,6 @@ bool ProcParams::operator ==(const ProcParams& other) const
         && rgbCurves == other.rgbCurves
         && colorToning == other.colorToning
         && metadata == other.metadata
-        && exif == other.exif
-        && iptc == other.iptc
         && dehaze == other.dehaze
         && filmNegative == other.filmNegative;
 }
diff --git a/rtengine/procparams.h b/rtengine/procparams.h
index 48b68f598..22ec54856 100644
--- a/rtengine/procparams.h
+++ b/rtengine/procparams.h
@@ -1974,31 +1974,22 @@ struct ColorManagementParams {
     bool operator !=(const ColorManagementParams& other) const;
 };
 
-/**
-  * Parameters for metadata handling
-  */
-struct MetaDataParams {
-    enum Mode {
-        TUNNEL,
-        EDIT,
-        STRIP
-    };
-    Mode mode;
-
-    MetaDataParams();
-
-    bool operator ==(const MetaDataParams &other) const;
-    bool operator !=(const MetaDataParams &other) const;
-};
-
-
 /**
   * Minimal wrapper allowing forward declaration for representing a key/value for the exif metadata information
   */
 class ExifPairs final
 {
+private:
+    using Pairs = std::map<Glib::ustring, Glib::ustring>;
+
 public:
-    using const_iterator = std::map<Glib::ustring, Glib::ustring>::const_iterator;
+    using const_iterator = Pairs::const_iterator;
+    using size_type = Pairs::size_type;
+
+    const_iterator find(const Glib::ustring& key) const
+    {
+        return pairs.find(key);
+    }
 
     const_iterator begin() const
     {
@@ -2015,6 +2006,16 @@ public:
         pairs.clear();
     }
 
+    size_type erase(const Glib::ustring& key)
+    {
+        return pairs.erase(key);
+    }
+
+    bool empty() const
+    {
+        return pairs.empty();
+    }
+
     Glib::ustring& operator[](const Glib::ustring& key)
     {
         return pairs[key];
@@ -2026,7 +2027,7 @@ public:
     }
 
 private:
-    std::map<Glib::ustring, Glib::ustring> pairs;
+    Pairs pairs;
 };
 
 /**
@@ -2058,6 +2059,11 @@ public:
         return pairs.empty();
     }
 
+    iterator erase(const const_iterator& key)
+    {
+        return pairs.erase(key);
+    }
+
     void clear()
     {
         pairs.clear();
@@ -2077,6 +2083,29 @@ private:
     std::map<Glib::ustring, std::vector<Glib::ustring>> pairs;
 };
 
+/**
+  * Parameters for metadata handling
+  */
+struct MetaDataParams {
+    enum Mode {
+        TUNNEL,
+        EDIT,
+        STRIP
+    };
+    Mode mode;
+    std::vector<std::string> exifKeys;
+    ExifPairs exif;
+    IPTCPairs iptc;
+
+    MetaDataParams();
+
+    bool operator ==(const MetaDataParams &other) const;
+    bool operator !=(const MetaDataParams &other) const;
+
+    static std::vector<std::string> basicExifKeys;
+};
+
+
 struct WaveletParams {
     std::vector<double> ccwcurve;
     std::vector<double> wavdenoise;
@@ -2594,8 +2623,8 @@ public:
     int                     ppVersion;       ///< Version of the PP file from which the parameters have been read
 
     MetaDataParams          metadata;        ///< Metadata parameters
-    ExifPairs               exif;            ///< List of modifications appplied on the exif tags of the input image
-    IPTCPairs               iptc;            ///< The IPTC tags and values to be saved to the output image
+    // ExifPairs               exif;            ///< List of modifications appplied on the exif tags of the input image
+    // IPTCPairs               iptc;            ///< The IPTC tags and values to be saved to the output image
 
     /**
       * The constructor only sets the hand-wired defaults.
diff --git a/rtengine/rawimagesource.cc b/rtengine/rawimagesource.cc
index 06aa701e8..06bebafa6 100644
--- a/rtengine/rawimagesource.cc
+++ b/rtengine/rawimagesource.cc
@@ -744,7 +744,8 @@ void RawImageSource::getWBMults (const ColorTemp &ctemp, const RAWParams &raw, s
 void RawImageSource::getImage (const ColorTemp &ctemp, int tran, Imagefloat* image, const PreviewProps &pp, const ToneCurveParams &hrp, const RAWParams &raw, int opposed)
 {// added int opposed to force getimage to use inpaint-opposed if enable, only once
     MyMutex::MyLock lock(getImageMutex);
-    tran = defTransform (tran);
+
+    tran = defTransform(ri, tran);
 
     // compute channel multipliers
     double r, g, b;
@@ -1092,10 +1093,24 @@ void RawImageSource::convertColorSpace(Imagefloat* image, const ColorManagementP
     colorSpaceConversion (image, cmp, wb, pre_mul, embProfile, camProfile, imatrices.xyz_cam, (static_cast<const FramesData*>(getMetaData()))->getCamera());
 }
 
-void RawImageSource::getFullSize (int& w, int& h, int tr)
+void RawImageSource::getFullSize(int& w, int& h, int tr)
 {
+    computeFullSize(ri, tr, w, h, border);
+}
 
-    tr = defTransform (tr);
+
+void RawImageSource::computeFullSize(const RawImage *ri, int tr, int &w, int &h, int border)
+{
+    tr = defTransform(ri, tr);
+
+    const int W = ri->get_width();
+    const int H = ri->get_height();
+    const bool fuji = ri->get_FujiWidth() != 0;
+    const bool d1x = !ri->get_model().compare("D1X");
+    const int b =
+        border >= 0 ? border :
+        (ri->getSensorType() == ST_BAYER ? 4 :
+         (ri->getSensorType() == ST_FUJI_XTRANS ? 7 : 0));
 
     if (fuji) {
         w = ri->get_FujiWidth() * 2 + 1;
@@ -1114,8 +1129,8 @@ void RawImageSource::getFullSize (int& w, int& h, int tr)
         h = tmp;
     }
 
-    w -= 2 * border;
-    h -= 2 * border;
+    w -= 2 * b;
+    h -= 2 * b;
 }
 
 //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@@ -1338,9 +1353,13 @@ int RawImageSource::load (const Glib::ustring &fname, bool firstFrameOnly)
 
 
     // Load complete Exif information
-    std::unique_ptr<RawMetaDataLocation> rml(new RawMetaDataLocation (ri->get_exifBase(), ri->get_ciffBase(), ri->get_ciffLen()));
-    idata = new FramesData (fname, std::move(rml));
+    idata = new FramesData(fname); // TODO: std::unique_ptr<>
     idata->setDCRawFrameCount (numFrames);
+    {
+        int ww, hh;
+        getFullSize(ww, hh);
+        idata->setDimensions(ww, hh);
+    }
 
     green(W, H);
     red(W, H);
@@ -2810,7 +2829,7 @@ void RawImageSource::scaleColors(int winx, int winy, int winw, int winh, const R
 
 //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
-int RawImageSource::defTransform (int tran)
+int RawImageSource::defTransform(const RawImage *ri, int tran)
 {
 
     int deg = ri->get_rotateDegree();
@@ -6820,7 +6839,7 @@ ColorTemp RawImageSource::getSpotWB (std::vector<Coord2D> &red, std::vector<Coor
 void RawImageSource::transformPosition (int x, int y, int tran, int& ttx, int& tty)
 {
 
-    tran = defTransform (tran);
+    tran = defTransform(ri, tran);
 
     x += border;
     y += border;
diff --git a/rtengine/rawimagesource.h b/rtengine/rawimagesource.h
index b19c6f5c0..3f39f3a36 100644
--- a/rtengine/rawimagesource.h
+++ b/rtengine/rawimagesource.h
@@ -47,7 +47,7 @@ private:
     static LUTf invGrad;  // for fast_demosaic
     static LUTf initInvGrad ();
     static void colorSpaceConversion_ (Imagefloat* im, const procparams::ColorManagementParams& cmp, const ColorTemp &wb, double pre_mul[3], cmsHPROFILE embedded, cmsHPROFILE camprofile, double cam[3][3], const std::string &camName);
-    int  defTransform (int tran);
+    static int  defTransform (const RawImage *ri, int tran);
 
 protected:
     MyMutex getImageMutex;  // locks getImage
@@ -232,6 +232,8 @@ public:
         virtual float operator()(int row) const { return 1.f; }
     };
     
+    static void computeFullSize(const RawImage *ri, int tr, int &w, int &h, int border=-1);
+
 protected:
     typedef unsigned short ushort;
     void processFalseColorCorrection(Imagefloat* i, const int steps);
diff --git a/rtengine/rawmetadatalocation.h b/rtengine/rawmetadatalocation.h
deleted file mode 100644
index 894bc6bd2..000000000
--- a/rtengine/rawmetadatalocation.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- *  This file is part of RawTherapee.
- *
- *  Copyright (c) 2004-2010 Gabor Horvath <hgabor@rawtherapee.com>
- *
- *  RawTherapee is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  RawTherapee is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
- */
-#pragma once
-
-namespace rtengine
-{
-
-class RawMetaDataLocation {
-
-public:
-    int exifBase;
-    int ciffBase;
-    int ciffLength;
-
-    RawMetaDataLocation () : exifBase(-1), ciffBase(-1), ciffLength(-1) {}
-    explicit RawMetaDataLocation (int exifBase) : exifBase(exifBase), ciffBase(-1), ciffLength(-1) {}
-    RawMetaDataLocation (int ciffBase, int ciffLength) : exifBase(-1), ciffBase(ciffBase), ciffLength(ciffLength) {}
-    RawMetaDataLocation (int exifBase, int ciffBase, int ciffLength) : exifBase(exifBase), ciffBase(ciffBase), ciffLength(ciffLength) {}
-};
-
-}
diff --git a/rtengine/rtengine.h b/rtengine/rtengine.h
index f86950457..f7a998a71 100644
--- a/rtengine/rtengine.h
+++ b/rtengine/rtengine.h
@@ -1,4 +1,5 @@
-/*
+/* -*- C++ -*-
+ *  
  *  This file is part of RawTherapee.
  *
  *  Copyright (c) 2004-2010 Gabor Horvath <hgabor@rawtherapee.com>
@@ -30,7 +31,6 @@
 #include "iimage.h"
 #include "imageformat.h"
 #include "procevents.h"
-#include "rawmetadatalocation.h"
 #include "settings.h"
 
 #include "../rtgui/threadutils.h"
@@ -51,12 +51,6 @@ class LUT;
 using LUTu = LUT<uint32_t>;
 
 class EditDataProvider;
-namespace rtexif
-{
-
-class TagDirectory;
-
-}
 
 namespace rtengine
 {
@@ -91,78 +85,56 @@ class FramesMetaData
 {
 
 public:
-    /** @return Returns the number of root Metadata */
-    virtual unsigned int getRootCount () const = 0;
     /** @return Returns the number of frame contained in the file based on Metadata */
-    virtual unsigned int getFrameCount () const = 0;
+    virtual unsigned int getFrameCount() const = 0;
 
     /** Checks the availability of exif metadata tags.
       * @return Returns true if image contains exif metadata tags */
-    virtual bool hasExif (unsigned int frame = 0) const = 0;
-    /** Returns the directory of exif metadata tags.
-      * @param root root number in the metadata tree
-      * @return The directory of exif metadata tags */
-    virtual rtexif::TagDirectory* getRootExifData (unsigned int root = 0) const = 0;
-    /** Returns the directory of exif metadata tags.
-      * @param frame frame number in the metadata tree
-      * @return The directory of exif metadata tags */
-    virtual rtexif::TagDirectory* getFrameExifData (unsigned int frame = 0) const = 0;
-    /** Returns the directory of exif metadata tags containing at least the 'Make' tag for the requested frame.
-      * If no usable metadata exist in the frame, send back the best TagDirectory describing the frame content.
-      * @param imgSource rawimage that we want the metadata from
-      * @param rawParams RawParams to select the frame number
-      * @return The directory of exif metadata tags containing at least the 'Make' tag */
-    virtual rtexif::TagDirectory* getBestExifData (ImageSource *imgSource, procparams::RAWParams *rawParams) const = 0;
-    /** Checks the availability of IPTC tags.
-      * @return Returns true if image contains IPTC tags */
-    virtual bool hasIPTC (unsigned int frame = 0) const = 0;
-    /** Returns the directory of IPTC tags.
-      * @return The directory of IPTC tags */
-    virtual procparams::IPTCPairs getIPTCData (unsigned int frame = 0) const = 0;
+    virtual bool hasExif() const = 0;
     /** @return a struct containing the date and time of the image */
-    virtual tm getDateTime (unsigned int frame = 0) const = 0;
+    virtual tm getDateTime() const = 0;
     /** @return a timestamp containing the date and time of the image */
-    virtual time_t getDateTimeAsTS(unsigned int frame = 0) const = 0;
+    virtual time_t getDateTimeAsTS() const = 0;
     /** @return the ISO of the image */
-    virtual int getISOSpeed (unsigned int frame = 0) const = 0;
+    virtual int getISOSpeed() const = 0;
     /** @return the F number of the image */
-    virtual double getFNumber  (unsigned int frame = 0) const = 0;
+    virtual double getFNumber() const = 0;
     /** @return the focal length used at the exposure */
-    virtual double getFocalLen (unsigned int frame = 0) const = 0;
+    virtual double getFocalLen() const = 0;
     /** @return the focal length in 35mm used at the exposure */
-    virtual double getFocalLen35mm (unsigned int frame = 0) const = 0;
+    virtual double getFocalLen35mm() const = 0;
     /** @return the focus distance in meters, 0=unknown, 10000=infinity */
-    virtual float getFocusDist (unsigned int frame = 0) const = 0;
+    virtual float getFocusDist() const = 0;
     /** @return the shutter speed */
-    virtual double getShutterSpeed (unsigned int frame = 0) const = 0;
+    virtual double getShutterSpeed() const = 0;
     /** @return the exposure compensation */
-    virtual double getExpComp (unsigned int frame = 0) const = 0;
+    virtual double getExpComp() const = 0;
     /** @return the maker of the camera */
-    virtual std::string getMake     (unsigned int frame = 0) const = 0;
+    virtual std::string getMake() const = 0;
     /** @return the model of the camera */
-    virtual std::string getModel    (unsigned int frame = 0) const = 0;
+    virtual std::string getModel() const = 0;
 
-    std::string getCamera   (unsigned int frame = 0) const
+    std::string getCamera() const
     {
-        return getMake(frame) + " " + getModel(frame);
+        return getMake() + " " + getModel();
     }
 
     /** @return the lens on the camera  */
-    virtual std::string getLens     (unsigned int frame = 0) const = 0;
+    virtual std::string getLens() const = 0;
     /** @return the orientation of the image */
-    virtual std::string getOrientation (unsigned int frame = 0) const = 0;
+    virtual std::string getOrientation() const = 0;
     /** @return the rating of the image */
-    virtual int getRating (unsigned int frame = 0) const = 0;
+    virtual int getRating() const = 0;
 
     /** @return true if the file is a PixelShift shot (Pentax and Sony bodies) */
     virtual bool getPixelShift () const = 0;
     /** @return false: not an HDR file ; true: single or multi-frame HDR file (e.g. Pentax HDR raw file or 32 bit float DNG file or Log compressed) */
-    virtual bool getHDR (unsigned int frame = 0) const = 0;
+    virtual bool getHDR() const = 0;
 
     /** @return false: not an HDR file ; true: single or multi-frame HDR file (e.g. Pentax HDR raw file or 32 bit float DNG file or Log compressed) */
-    virtual std::string getImageType (unsigned int frame) const = 0;
+    virtual std::string getImageType() const = 0;
     /** @return the sample format based on MetaData */
-    virtual IIOSampleFormat getSampleFormat (unsigned int frame = 0) const = 0;
+    virtual IIOSampleFormat getSampleFormat() const = 0;
 
     /** Functions to convert between floating point and string representation of shutter and aperture */
     static std::string apertureToString (double aperture);
@@ -183,7 +155,10 @@ public:
       * Use it only for raw files. In caseof jpgs and tiffs pass a NULL pointer.
       * @param firstFrameOnly must be true to get the MetaData of the first frame only, e.g. for a PixelShift file.
       * @return The metadata */
-    static FramesMetaData* fromFile (const Glib::ustring& fname, std::unique_ptr<RawMetaDataLocation> rml, bool firstFrameOnly = false);
+    static FramesMetaData* fromFile(const Glib::ustring& fname);
+
+    virtual Glib::ustring getFileName() const = 0;
+    virtual void getDimensions(int &w, int &h) const = 0;
 };
 
 /** This listener interface is used to indicate the progress of time consuming operations */
@@ -398,7 +373,7 @@ public :
     virtual void adapCamChanged(double cadap) = 0;
     virtual void ybCamChanged(int yb) = 0;
     virtual void wbCamChanged(double tem, double tin) = 0;
-    
+
 };
 
 class AutoChromaListener
@@ -623,7 +598,7 @@ public:
     virtual void        getCamWB    (double& temp, double& green, StandardObserver observer) = 0;
     virtual void        getSpotWB  (int x, int y, int rectSize, double& temp, double& green) = 0;
     virtual bool        getFilmNegativeSpot(int x, int y, int spotSize, procparams::FilmNegativeParams::RGB &refInput, procparams::FilmNegativeParams::RGB &refOutput) = 0;
-    
+
     virtual void        getAutoCrop (double ratio, int &x, int &y, int &w, int &h) = 0;
 
     virtual void        saveInputICCReference (const Glib::ustring& fname, bool apply_wb) = 0;
diff --git a/rtengine/rtthumbnail.cc b/rtengine/rtthumbnail.cc
index 11dae8018..5894bfa75 100644
--- a/rtengine/rtthumbnail.cc
+++ b/rtengine/rtthumbnail.cc
@@ -324,10 +324,10 @@ Thumbnail* Thumbnail::loadFromImage (const Glib::ustring& fname, int &w, int &h,
 
 namespace {
 
-Image8 *load_inspector_mode(const Glib::ustring &fname, RawMetaDataLocation &rml, eSensorType &sensorType, int &w, int &h)
+Image8 *load_inspector_mode(const Glib::ustring &fname, eSensorType &sensorType, int &w, int &h)
 {
     BENCHFUN
-    
+
     RawImageSource src;
     int err = src.load(fname, true);
     if (err) {
@@ -336,7 +336,7 @@ Image8 *load_inspector_mode(const Glib::ustring &fname, RawMetaDataLocation &rml
 
     src.getFullSize(w, h);
     sensorType = src.getSensorType();
-    
+
     ProcParams neutral;
     neutral.raw.bayersensor.method = RAWParams::BayerSensor::getMethodString(RAWParams::BayerSensor::Method::FAST);
     neutral.raw.xtranssensor.method = RAWParams::XTransSensor::getMethodString(RAWParams::XTransSensor::Method::FAST);
@@ -380,7 +380,7 @@ Image8 *load_inspector_mode(const Glib::ustring &fname, RawMetaDataLocation &rml
 
 } // namespace
 
-Thumbnail* Thumbnail::loadQuickFromRaw (const Glib::ustring& fname, RawMetaDataLocation& rml, eSensorType &sensorType, int &w, int &h, int fixwh, bool rotate, bool inspectorMode, bool forHistogramMatching)
+Thumbnail* Thumbnail::loadQuickFromRaw (const Glib::ustring& fname, eSensorType &sensorType, int &w, int &h, int fixwh, bool rotate, bool inspectorMode, bool forHistogramMatching)
 {
     Thumbnail* tpp = new Thumbnail ();
     tpp->isRaw = 1;
@@ -390,7 +390,7 @@ Thumbnail* Thumbnail::loadQuickFromRaw (const Glib::ustring& fname, RawMetaDataL
     tpp->colorMatrix[2][2] = 1.0;
 
     if (inspectorMode && !forHistogramMatching && settings->thumbnail_inspector_mode == Settings::ThumbnailInspectorMode::RAW) {
-        Image8 *img = load_inspector_mode(fname, rml, sensorType, w, h);
+        Image8 *img = load_inspector_mode(fname, sensorType, w, h);
         if (!img) {
             delete tpp;
             return nullptr;
@@ -401,7 +401,7 @@ Thumbnail* Thumbnail::loadQuickFromRaw (const Glib::ustring& fname, RawMetaDataL
 
         return tpp;
     }
-    
+
     RawImage *ri = new RawImage (fname);
     unsigned int imageNum = 0;
     int r = ri->loadRaw (false, imageNum, false);
@@ -415,10 +415,6 @@ Thumbnail* Thumbnail::loadQuickFromRaw (const Glib::ustring& fname, RawMetaDataL
 
     sensorType = ri->getSensorType();
 
-    rml.exifBase = ri->get_exifBase();
-    rml.ciffBase = ri->get_ciffBase();
-    rml.ciffLength = ri->get_ciffLen();
-
     Image8* img = new Image8 ();
     // No sample format detection occurred earlier, so we set them here,
     // as they are mandatory for the setScanline method
@@ -458,8 +454,8 @@ Thumbnail* Thumbnail::loadQuickFromRaw (const Glib::ustring& fname, RawMetaDataL
         if (!forHistogramMatching && settings->thumbnail_inspector_mode == Settings::ThumbnailInspectorMode::RAW_IF_NOT_JPEG_FULLSIZE && float(std::max(w, h))/float(std::max(ri->get_width(), ri->get_height())) < 0.9f) {
             delete img;
             delete ri;
-            
-            img = load_inspector_mode(fname, rml, sensorType, w, h);
+
+            img = load_inspector_mode(fname, sensorType, w, h);
             if (!img) {
                 delete tpp;
                 return nullptr;
@@ -467,7 +463,7 @@ Thumbnail* Thumbnail::loadQuickFromRaw (const Glib::ustring& fname, RawMetaDataL
 
             tpp->scale = 1.;
             tpp->thumbImg = img;
-            
+
             return tpp;
         }
     } else {
@@ -523,28 +519,7 @@ Thumbnail* Thumbnail::loadQuickFromRaw (const Glib::ustring& fname, RawMetaDataL
 #define FISGREEN(filter,row,col) \
     ((filter >> ((((row) << 1 & 14) + ((col) & 1)) << 1) & 3)==1 || !filter)
 
-RawMetaDataLocation Thumbnail::loadMetaDataFromRaw (const Glib::ustring& fname)
-{
-    RawMetaDataLocation rml;
-    rml.exifBase = -1;
-    rml.ciffBase = -1;
-    rml.ciffLength = -1;
-
-    RawImage ri (fname);
-    unsigned int imageNum = 0;
-
-    int r = ri.loadRaw (false, imageNum);
-
-    if ( !r ) {
-        rml.exifBase = ri.get_exifBase();
-        rml.ciffBase = ri.get_ciffBase();
-        rml.ciffLength = ri.get_ciffLen();
-    }
-
-    return rml;
-}
-
-Thumbnail* Thumbnail::loadFromRaw (const Glib::ustring& fname, RawMetaDataLocation& rml, eSensorType &sensorType, int &w, int &h, int fixwh, double wbEq, StandardObserver wbObserver, bool rotate, bool forHistogramMatching)
+Thumbnail* Thumbnail::loadFromRaw (const Glib::ustring& fname, eSensorType &sensorType, int &w, int &h, int fixwh, double wbEq, StandardObserver wbObserver, bool rotate, bool forHistogramMatching)
 {
     RawImage *ri = new RawImage (fname);
     unsigned int tempImageNum = 0;
@@ -593,10 +568,6 @@ Thumbnail* Thumbnail::loadFromRaw (const Glib::ustring& fname, RawMetaDataLocati
 
     ri->pre_interpolate();
 
-    rml.exifBase = ri->get_exifBase();
-    rml.ciffBase = ri->get_ciffBase();
-    rml.ciffLength = ri->get_ciffLen();
-
     tpp->camwbRed = tpp->redMultiplier / pre_mul[0]; //ri->get_pre_mul(0);
     tpp->camwbGreen = tpp->greenMultiplier / pre_mul[1]; //ri->get_pre_mul(1);
     tpp->camwbBlue = tpp->blueMultiplier / pre_mul[2]; //ri->get_pre_mul(2);
@@ -999,6 +970,9 @@ Thumbnail* Thumbnail::loadFromRaw (const Glib::ustring& fname, RawMetaDataLocati
         }
 
     tpp->init();
+
+    RawImageSource::computeFullSize(ri, TR_NONE, tpp->full_width, tpp->full_height);
+
     delete ri;
     return tpp;
 }
@@ -1056,7 +1030,9 @@ Thumbnail::Thumbnail () :
     gammaCorrected (false),
     colorMatrix{},
     scaleGain (1.0),
-    isRaw (true)
+    isRaw (true),
+    full_width(-1),
+    full_height(-1)
 {
 }
 
@@ -1109,20 +1085,12 @@ IImage8* Thumbnail::quickProcessImage (const procparams::ProcParams& params, int
 // Full thumbnail processing, second stage if complete profile exists
 IImage8* Thumbnail::processImage (const procparams::ProcParams& params, eSensorType sensorType, int rheight, TypeInterpolation interp, const FramesMetaData *metadata, double& myscale, bool forMonitor, bool forHistogramMatching)
 {
-    unsigned int imgNum = 0;
-    if (isRaw) {
-        if (sensorType == ST_BAYER) {
-            imgNum = rtengine::LIM<unsigned int>(params.raw.bayersensor.imageNum, 0, metadata->getFrameCount() - 1);
-        } else if (sensorType == ST_FUJI_XTRANS) {
-            //imgNum = rtengine::LIM<unsigned int>(params.raw.xtranssensor.imageNum, 0, metadata->getFrameCount() - 1)
-        }
-    }
-    std::string camName = metadata->getCamera(imgNum);
-    float shutter = metadata->getShutterSpeed(imgNum);
-    float fnumber = metadata->getFNumber(imgNum);
-    float iso = metadata->getISOSpeed(imgNum);
-    float fcomp = metadata->getExpComp(imgNum);
-    
+    const std::string camName = metadata->getCamera();
+    const float shutter = metadata->getShutterSpeed();
+    const float fnumber = metadata->getFNumber();
+    const float iso = metadata->getISOSpeed();
+    const float fcomp = metadata->getExpComp();
+
     // check if the WB's equalizer, temperature bias, or observer value has changed
     if (wbEqual < (params.wb.equal - 5e-4) || wbEqual > (params.wb.equal + 5e-4) || wbTempBias < (params.wb.tempBias - 5e-4) || wbTempBias > (params.wb.tempBias + 5e-4) || wbObserver != params.wb.observer) {
         wbEqual = params.wb.equal;
@@ -1229,7 +1197,7 @@ IImage8* Thumbnail::processImage (const procparams::ProcParams& params, eSensorT
             float red = baseImg->r (i, j) * rmi;
             float green = baseImg->g (i, j) * gmi;
             float blue = baseImg->b (i, j) * bmi;
-            
+
             // avoid magenta highlights if highlight recovery is enabled
             if (params.toneCurve.hrenabled && red > MAXVALF && blue > MAXVALF) {
                 baseImg->r(i, j) = baseImg->g(i, j) = baseImg->b(i, j) = CLIP((red + green + blue) / 3.f);
@@ -1276,7 +1244,7 @@ IImage8* Thumbnail::processImage (const procparams::ProcParams& params, eSensorT
 
     ipf.dehaze(baseImg, params.dehaze);
     ipf.ToneMapFattal02(baseImg, params.fattal, 3, 0, nullptr, 0, 0, 0);
-    
+
     // perform transform
     int origFW;
     int origFH;
@@ -1427,7 +1395,7 @@ IImage8* Thumbnail::processImage (const procparams::ProcParams& params, eSensorT
             }
     }
 
-    
+
     // luminance processing
 //  ipf.EPDToneMap(labView,0,6);
 
@@ -2171,7 +2139,7 @@ bool Thumbnail::readData  (const Glib::ustring& fname)
                         colorMatrix[i][j] = cm[ix++];
                     }
             }
-            
+
             if (keyFile.has_key ("LiveThumbData", "ScaleGain")) {
                 scaleGain           = keyFile.get_double ("LiveThumbData", "ScaleGain");
             }
diff --git a/rtengine/rtthumbnail.h b/rtengine/rtthumbnail.h
index 535613ca2..7a2b5815b 100644
--- a/rtengine/rtthumbnail.h
+++ b/rtengine/rtthumbnail.h
@@ -24,7 +24,6 @@
 #include "image8.h"
 #include "imagefloat.h"
 #include "LUT.h"
-#include "rawmetadatalocation.h"
 
 #include "../rtgui/threadutils.h"
 
@@ -86,6 +85,8 @@ class Thumbnail
 public:
 
     bool isRaw;
+    int full_width;
+    int full_height;
 
     ~Thumbnail ();
     Thumbnail ();
@@ -97,10 +98,9 @@ public:
     int      getImageWidth  (const procparams::ProcParams& pparams, int rheight, float &ratio);
     void     getDimensions  (int& w, int& h, double& scaleFac);
 
-    static Thumbnail* loadQuickFromRaw (const Glib::ustring& fname, rtengine::RawMetaDataLocation& rml, eSensorType &sensorType, int &w, int &h, int fixwh, bool rotate, bool inspectorMode = false, bool forHistogramMatching = false);
-    static Thumbnail* loadFromRaw (const Glib::ustring& fname, RawMetaDataLocation& rml, eSensorType &sensorType, int &w, int &h, int fixwh, double wbEq, StandardObserver wbObserver, bool rotate, bool forHistogramMatching = false);
+    static Thumbnail* loadQuickFromRaw (const Glib::ustring& fname, eSensorType &sensorType, int &w, int &h, int fixwh, bool rotate, bool inspectorMode = false, bool forHistogramMatching = false);
+    static Thumbnail* loadFromRaw (const Glib::ustring& fname, eSensorType &sensorType, int &w, int &h, int fixwh, double wbEq, StandardObserver wbObserver, bool rotate, bool forHistogramMatching=false);
     static Thumbnail* loadFromImage (const Glib::ustring& fname, int &w, int &h, int fixwh, double wbEq, StandardObserver wbObserver, bool inspectorMode = false);
-    static RawMetaDataLocation loadMetaDataFromRaw (const Glib::ustring& fname);
 
     void getCamWB     (double& temp, double& green, StandardObserver observer);
     void getAutoWB    (double& temp, double& green, double equal, double tempBias, StandardObserver observer);
diff --git a/rtengine/settings.h b/rtengine/settings.h
index c920a355d..30704b947 100644
--- a/rtengine/settings.h
+++ b/rtengine/settings.h
@@ -1,4 +1,5 @@
-/*
+/* -*- C++ -*-
+ *  
  *  This file is part of RawTherapee.
  *
  *  Copyright (c) 2004-2010 Gabor Horvath <hgabor@rawtherapee.com>
@@ -108,6 +109,19 @@ public:
     };
     ThumbnailInspectorMode thumbnail_inspector_mode;
 
+    enum class XmpSidecarStyle {
+        STD, // FILENAME.xmp for FILENAME.ext
+        EXT  // FILENAME.ext.xmp for FILENAME.ext
+    };
+    XmpSidecarStyle xmp_sidecar_style;
+
+    enum class MetadataXmpSync {
+        NONE,
+        READ,
+        READ_WRITE
+    };
+    MetadataXmpSync metadata_xmp_sync;
+
     /** Creates a new instance of Settings.
       * @return a pointer to the new Settings instance. */
     static Settings* create();
diff --git a/rtengine/simpleprocess.cc b/rtengine/simpleprocess.cc
index 78dd84042..dc4f057d0 100644
--- a/rtengine/simpleprocess.cc
+++ b/rtengine/simpleprocess.cc
@@ -32,6 +32,7 @@
 #include "imagesource.h"
 #include "improcfun.h"
 #include "labimage.h"
+#include "metadata.h"
 #include "mytime.h"
 #include "processingjob.h"
 #include "procparams.h"
@@ -928,7 +929,7 @@ private:
 			if(params.locallab.spots.at(sp).expsharp  && params.dirpyrequalizer.cbdlMethod == "bef") {
 				if(params.locallab.spots.at(sp).shardamping < 1) {
 					params.locallab.spots.at(sp).shardamping = 1;
-				}				
+				}
 			}
 		}
 
@@ -947,10 +948,10 @@ private:
 
         if (params.locallab.enabled && params.locallab.spots.size() > 0) {
             ipf.rgb2lab(*baseImg, *labView, params.icm.workingProfile);
-            
+
             MyTime t1, t2;
             t1.set();
-            
+
             const std::unique_ptr<LabImage> reservView(new LabImage(*labView, true));
             const std::unique_ptr<LabImage> lastorigView(new LabImage(*labView, true));
             std::unique_ptr<LabImage> savenormtmView;
@@ -1002,7 +1003,7 @@ private:
             LocLLmaskCurve locllmas_Curve;
             LocHHmaskCurve lochhmas_Curve;
             LocHHmaskCurve lochhhmas_Curve;
-            
+
             LocwavCurve loclmasCurveblwav;
             LocwavCurve loclmasCurvecolwav;
             LocwavCurve loclmasCurve_wav;
@@ -1094,7 +1095,7 @@ private:
                 const bool lcmascieutili = locccmascieCurve.Set(params.locallab.spots.at(sp).CCmaskciecurve);
                 const bool llmascieutili = locllmascieCurve.Set(params.locallab.spots.at(sp).LLmaskciecurve);
                 const bool lhmascieutili = lochhmascieCurve.Set(params.locallab.spots.at(sp).HHmaskciecurve);
-                
+
                 const bool lcmas_utili = locccmas_Curve.Set(params.locallab.spots.at(sp).CCmask_curve);
                 const bool llmas_utili = locllmas_Curve.Set(params.locallab.spots.at(sp).LLmask_curve);
                 const bool lhmas_utili = lochhmas_Curve.Set(params.locallab.spots.at(sp).HHmask_curve);
@@ -1158,7 +1159,7 @@ private:
                 float meanretie;
                 float stdretie;
                 float fab = 1.f;
-                
+
                 if (params.locallab.spots.at(sp).spotMethod == "exc") {
                     ipf.calc_ref(sp, reservView.get(), reservView.get(), 0, 0, fw, fh, 1, huerefblu, chromarefblu, lumarefblu, huere, chromare, lumare, sobelre, avge, locwavCurveden, locwavdenutili);
                 } else {
@@ -1177,8 +1178,8 @@ private:
                 float Tmax;
 
                 // No Locallab mask is shown in exported picture
-                ipf.Lab_Local(2, sp, shbuffer, labView, labView, reservView.get(), savenormtmView.get(), savenormretiView.get(), lastorigView.get(), fw, fh, 0, 0, fw, fh,  1, locRETgainCurve, locRETtransCurve, 
-                        lllocalcurve, locallutili, 
+                ipf.Lab_Local(2, sp, shbuffer, labView, labView, reservView.get(), savenormtmView.get(), savenormretiView.get(), lastorigView.get(), fw, fh, 0, 0, fw, fh,  1, locRETgainCurve, locRETtransCurve,
+                        lllocalcurve, locallutili,
                         cllocalcurve, localclutili,
                         lclocalcurve, locallcutili,
                         loclhCurve, lochhCurve, locchCurve,
@@ -1195,12 +1196,12 @@ private:
                         lmaskloglocalcurve, localmasklogutili,
                         lmasklocal_curve, localmask_utili,
                         lmaskcielocalcurve, localmaskcieutili,
-                        cielocalcurve, localcieutili, 
-                        cielocalcurve2, localcieutili2, 
-                        jzlocalcurve, localjzutili, 
-                        czlocalcurve, localczutili, 
-                        czjzlocalcurve, localczjzutili, 
-                        
+                        cielocalcurve, localcieutili,
+                        cielocalcurve2, localcieutili2,
+                        jzlocalcurve, localjzutili,
+                        czlocalcurve, localczutili,
+                        czjzlocalcurve, localczjzutili,
+
                         locccmasCurve, lcmasutili, locllmasCurve, llmasutili, lochhmasCurve, lhmasutili, lochhhmasCurve, lhhmasutili, locccmasexpCurve, lcmasexputili, locllmasexpCurve, llmasexputili, lochhmasexpCurve, lhmasexputili,
                         locccmasSHCurve, lcmasSHutili, locllmasSHCurve, llmasSHutili, lochhmasSHCurve, lhmasSHutili,
                         locccmasvibCurve, lcmasvibutili, locllmasvibCurve, llmasvibutili, lochhmasvibCurve, lhmasvibutili,
@@ -1467,8 +1468,8 @@ private:
             bool proedge = WaveParams.expedge;
             bool profin = WaveParams.expfinal;
             bool proton = WaveParams.exptoning;
-            bool pronois = WaveParams.expnoise; 
-            
+            bool pronois = WaveParams.expnoise;
+
 /*
             if(WaveParams.showmask) {
                 WaveParams.showmask = false;
@@ -1495,7 +1496,7 @@ private:
                 WaveParams.expedge = false;
                 WaveParams.expfinal = false;
                 WaveParams.exptoning = false;
-                WaveParams.expnoise = false; 
+                WaveParams.expnoise = false;
             }
 
             ipf.ip_wavelet(labView, labView, 2, WaveParams, wavCLVCurve, wavdenoise, wavdenoiseh, wavblcurve, waOpacityCurveRG, waOpacityCurveSH, waOpacityCurveBY, waOpacityCurveW,  waOpacityCurveWL, wavclCurve, 1);
@@ -1507,7 +1508,7 @@ private:
                 WaveParams.expfinal = profin;
                 WaveParams.exptoning = proton;
                 WaveParams.expnoise = pronois;
-                
+
                 if (WaveParams.softrad > 0.f) {
                     array2D<float> ble(fw, fh);
                     array2D<float> guid(fw, fh);
@@ -1562,7 +1563,7 @@ private:
                         }
                 delete tmpImage;
                 }
-                
+
             }
 
             if ((WaveParams.ushamethod == "sharp" || WaveParams.ushamethod == "clari") && WaveParams.expclari && WaveParams.CLmethod != "all") {
@@ -1652,7 +1653,7 @@ private:
                     labView->b[x][y] = 0.f;
                 }
             }
-           
+
         }
 
         //Colorappearance and tone-mapping associated
@@ -1679,18 +1680,11 @@ private:
 
         if (params.colorappearance.enabled) {
             double adap;
-            int imgNum = 0;
-
-            if (imgsrc->getSensorType() == ST_BAYER) {
-                imgNum = params.raw.bayersensor.imageNum;
-            } else if (imgsrc->getSensorType() == ST_FUJI_XTRANS) {
-                //imgNum = params.raw.xtranssensor.imageNum;
-            }
 
-            float fnum = imgsrc->getMetaData()->getFNumber(imgNum);          // F number
-            float fiso = imgsrc->getMetaData()->getISOSpeed(imgNum) ;        // ISO
-            float fspeed = imgsrc->getMetaData()->getShutterSpeed(imgNum) ;  //speed
-            float fcomp = imgsrc->getMetaData()->getExpComp(imgNum);         //compensation + -
+            const float fnum = imgsrc->getMetaData()->getFNumber();         // F number
+            const float fiso = imgsrc->getMetaData()->getISOSpeed() ;       // ISO
+            const float fspeed = imgsrc->getMetaData()->getShutterSpeed() ; // Speed
+            const float fcomp = imgsrc->getMetaData()->getExpComp();        // Compensation + -
 
             if (fnum < 0.3f || fiso < 5.f || fspeed < 0.00001f) {
                 adap = 2000.;
@@ -1823,21 +1817,22 @@ private:
             readyImg = tempImage;
         }
 
+        Exiv2Metadata info(imgsrc->getFileName());
         switch (params.metadata.mode) {
-            case MetaDataParams::TUNNEL:
-                // Sending back the whole first root, which won't necessarily be the selected frame number
-                // and may contain subframe depending on initial raw's hierarchy
-                readyImg->setMetadata(initialImage->getMetaData()->getRootExifData());
-                break;
-
-            case MetaDataParams::EDIT:
-                // ask for the correct frame number, but may contain subframe depending on initial raw's hierarchy
-                readyImg->setMetadata(initialImage->getMetaData()->getBestExifData(imgsrc, &params.raw), params.exif, params.iptc);
-                break;
-
-            default: // case MetaDataParams::STRIP
-                // nothing to do
-                break;
+        case MetaDataParams::TUNNEL:
+            readyImg->setMetadata(std::move(info));
+            break;
+        case MetaDataParams::EDIT:
+            info.setExif(params.metadata.exif);
+            info.setIptc(params.metadata.iptc);
+            if (!(params.metadata.exifKeys.size() == 1 && params.metadata.exifKeys[0] == "*")) {
+                info.setExifKeys(&(params.metadata.exifKeys));
+            }
+            readyImg->setMetadata(std::move(info));
+            break;
+        default: // case MetaDataParams::STRIP
+            // nothing to do
+            break;
         }
 
 
@@ -1859,11 +1854,11 @@ private:
                 }
 
                 ProfileContent pc = ICCStore::getInstance()->getContent(params.icm.outputProfile);
-                readyImg->setOutputProfile(pc.getData().c_str(), pc.getData().size());
+                readyImg->setOutputProfile(pc.getData());
             }
         } else {
             // No ICM
-            readyImg->setOutputProfile(nullptr, 0);
+            readyImg->setOutputProfile({});
         }
 
 //    t2.set();
diff --git a/rtexif/CMakeLists.txt b/rtexif/CMakeLists.txt
deleted file mode 100644
index e7ba81439..000000000
--- a/rtexif/CMakeLists.txt
+++ /dev/null
@@ -1,29 +0,0 @@
-add_library(rtexif STATIC
-    canonattribs.cc
-    fujiattribs.cc
-    kodakattribs.cc
-    nikonattribs.cc
-    olympusattribs.cc
-    panasonicattribs.cc
-    pentaxattribs.cc
-    rtexif.cc
-    sonyminoltaattribs.cc
-    stdattribs.cc
-)
-
-add_dependencies(rtexif UpdateInfo)
-
-if(WIN32)
-    include_directories(${EXTRA_INCDIR} ${GLIB2_INCLUDE_DIRS} ${GLIBMM_INCLUDE_DIRS} ${GTK_INCLUDE_DIRS} ${GTKMM_INCLUDE_DIRS} ${TIFF_INCLUDE_DIRS})
-    link_directories(. "${PROJECT_SOURCE_DIR}/rtexif" ${EXTRA_LIBDIR} ${GLIB2_LIBRARY_DIRS} ${GLIBMM_LIBRARY_DIRS} ${GTK_LIBRARY_DIRS} ${GTKMM_LIBRARY_DIRS} ${LENSFUN_LIBRARY_DIRS} ${TIFF_LIBRARY_DIRS})
-else()
-    set_target_properties(rtexif PROPERTIES COMPILE_FLAGS " -fPIC")
-    include_directories(${EXTRA_INCDIR} ${GLIB2_INCLUDE_DIRS} ${GLIBMM_INCLUDE_DIRS} ${GTK_INCLUDE_DIRS} ${GTKMM_INCLUDE_DIRS} ${TIFF_INCLUDE_DIRS})
-    link_directories(${EXTRA_LIBDIR} ${GLIB2_LIBRARY_DIRS} ${GLIBMM_LIBRARY_DIRS} ${GTK_LIBRARY_DIRS} ${GTKMM_LIBRARY_DIRS} ${LENSFUN_LIBRARY_DIRS} ${TIFF_LIBRARY_DIRS})
-endif()
-
-include_directories(BEFORE "${CMAKE_CURRENT_BINARY_DIR}")
-
-if(BUILD_SHARED_LIBS)
-    install(TARGETS rtexif DESTINATION "${LIBDIR}")
-endif()
diff --git a/rtexif/canonattribs.cc b/rtexif/canonattribs.cc
deleted file mode 100644
index 5300abe02..000000000
--- a/rtexif/canonattribs.cc
+++ /dev/null
@@ -1,2192 +0,0 @@
-/*
- *  This file is part of RawTherapee.
- *
- *  Copyright (c) 2004-2010 Gabor Horvath <hgabor@rawtherapee.com>
- *
- *  RawTherapee is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  RawTherapee is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-#include <cstdio>
-#include <cmath>
-
-#include "rtexif.h"
-
-using namespace std;
-
-namespace rtexif
-{
-
-class CAOnOffInterpreter : public Interpreter
-{
-public:
-    std::string toString (const Tag* t) const override
-    {
-        int n = t->toInt();
-
-        if ( n == 0 ) {
-            return "OFF";
-        } else if ( n == 1) {
-            return "ON";
-        } else {
-            return "undef";
-        }
-    }
-};
-CAOnOffInterpreter caOnOffInterpreter;
-
-class CAIntSerNumInterpreter : public Interpreter
-{
-public:
-    CAIntSerNumInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        return "";
-    }
-};
-
-CAIntSerNumInterpreter caIntSerNumInterpreter;
-
-class CAApertureInterpreter : public Interpreter
-{
-public:
-    CAApertureInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        double v = pow (2.0, t->toDouble() / 64.0);
-
-        if ( v < 0. || v > 1000.) {
-            return "undef";
-        }
-
-        snprintf(buffer, sizeof(buffer), "%.1f", v );
-        return buffer;
-    }
-};
-CAApertureInterpreter caApertureInterpreter;
-
-class CAMacroModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAMacroModeInterpreter()
-    {
-        choices[1] = "Macro";
-        choices[2] = "Normal";
-    }
-};
-CAMacroModeInterpreter caMacroModeInterpreter;
-
-class CASelfTimerInterpreter : public Interpreter
-{
-public:
-    std::string toString (const Tag* t) const override
-    {
-        int sec = t->toInt (0, SHORT);
-
-        if ( !sec ) {
-            return "OFF";
-        }
-
-        char buffer[32];
-        snprintf(buffer, sizeof(buffer), "%.1fs %s", sec / 10., (sec & 0x4000) ? ",Custom" : "");
-        return buffer;
-    }
-};
-CASelfTimerInterpreter caSelfTimerInterpreter;
-
-class CAQualityInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAQualityInterpreter()
-    {
-        choices[1] = "Economy";
-        choices[2] = "Normal";
-        choices[3] = "Fine";
-        choices[4] = "RAW";
-        choices[5] = "Superfine";
-    }
-};
-CAQualityInterpreter caQualityInterpreter;
-
-class CAFlashModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAFlashModeInterpreter()
-    {
-        choices[0] = "Off";
-        choices[1] = "Auto";
-        choices[2] = "On";
-        choices[3] = "Red-eye reduction";
-        choices[4] = "Slow-sync";
-        choices[5] = "Red-eye reduction (Auto)";
-        choices[6] = "Red-eye reduction (On)";
-        choices[16] = "External flash";
-    }
-};
-CAFlashModeInterpreter caFlashModeInterpreter;
-
-class CAContinuousDriveInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAContinuousDriveInterpreter()
-    {
-        choices[0] = "Single";
-        choices[1] = "Continuous";
-        choices[2] = "Movie";
-        choices[3] = "Continuous, Speed Priority";
-        choices[4] = "Continuous, Low";
-        choices[5] = "Continuous, High";
-        choices[6] = "Silent Single";
-        choices[9] = "Single, Silent";
-        choices[10] = "Continuous, Silent";
-    }
-};
-CAContinuousDriveInterpreter caContinuousDriveInterpreter;
-
-class CAFocusModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAFocusModeInterpreter()
-    {
-        choices[0] = "One-shot AF";
-        choices[1] = "AI Servo AF";
-        choices[2] = "AI Focus AF";
-        choices[3] = "Manual Focus (3)";
-        choices[4] = "Single";
-        choices[5] = "Continuous";
-        choices[6] = "Manual Focus (6)";
-        choices[16] = "Pan Focus";
-        choices[256] = "AF + MF";
-        choices[512] = "Movie Snap Focus";
-        choices[519] = "Movie Servo AF";
-    }
-};
-CAFocusModeInterpreter caFocusModeInterpreter;
-
-class CARecordModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CARecordModeInterpreter()
-    {
-        choices[1] = "JPEG";
-        choices[2] = "CRW+THM";
-        choices[3] = "AVI+THM";
-        choices[4] = "TIF";
-        choices[5] = "TIF+JPEG";
-        choices[6] = "CR2";
-        choices[7] = "CR2+JPEG";
-        choices[9] = "MOV";
-        choices[10] = "MP4";
-    }
-};
-CARecordModeInterpreter caRecordModeInterpreter;
-
-class CAImageSizeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAImageSizeInterpreter ()
-    {
-        choices[0] = "Large";
-        choices[1] = "Medium";
-        choices[2] = "Small";
-        choices[5] = "Medium 1";
-        choices[6] = "Medium 2";
-        choices[7] = "Medium 3";
-        choices[8] = "Postcard";
-        choices[9] = "Widescreen";
-        choices[10] = "Medium Widescreen";
-        choices[14] = "Small 1";
-        choices[15] = "Small 2";
-        choices[16] = "Small 3";
-        choices[128] = "640x480 Movie";
-        choices[129] = "Medium Movie";
-        choices[130] = "Small Movie";
-        choices[137] = "1280x720 Movie";
-        choices[142] = "1920x1080 Movie";
-    }
-};
-CAImageSizeInterpreter caImageSizeInterpreter;
-
-class CAEasyModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAEasyModeInterpreter ()
-    {
-        choices[0] = "Full auto";
-        choices[1] = "Manual";
-        choices[2] = "Landscape";
-        choices[3] = "Fast shutter";
-        choices[4] = "Slow shutter";
-        choices[5] = "Night";
-        choices[6] = "Gray Scale";
-        choices[7] = "Sepia";
-        choices[8] = "Portrait";
-        choices[9] = "Sports";
-        choices[10] = "Macro";
-        choices[11] = "Black & White";
-        choices[12] = "Pan focus";
-        choices[13] = "Vivid";
-        choices[14] = "Neutral";
-        choices[15] = "Flash Off";
-        choices[16] = "Long Shutter";
-        choices[17] = "Super Macro";
-        choices[18] = "Foliage";
-        choices[19] = "Indoor";
-        choices[20] = "Fireworks";
-        choices[21] = "Beach";
-        choices[22] = "Underwater";
-        choices[23] = "Snow";
-        choices[24] = "Kids & Pets";
-        choices[25] = "Night Snapshot";
-        choices[26] = "Digital Macro";
-        choices[27] = "My Colors";
-        choices[28] = "Movie Snap";
-        choices[29] = "Super Macro 2";
-        choices[30] = "Color Accent";
-        choices[31] = "Color Swap";
-        choices[32] = "Aquarium";
-        choices[33] = "ISO 3200";
-        choices[34] = "ISO 6400";
-        choices[35] = "Creative Light Effect";
-        choices[36] = "Easy";
-        choices[37] = "Quick Shot";
-        choices[38] = "Creative Auto";
-        choices[39] = "Zoom Blur";
-        choices[40] = "Low Light";
-        choices[41] = "Nostalgic";
-        choices[42] = "Super Vivid";
-        choices[43] = "Poster Effect";
-        choices[44] = "Face Self-timer";
-        choices[45] = "Smile";
-        choices[46] = "Wink Self-timer";
-        choices[47] = "Fisheye Effect";
-        choices[48] = "Miniature Effect";
-        choices[49] = "High-speed Burst";
-        choices[50] = "Best Image Selection";
-        choices[51] = "High Dynamic Range";
-        choices[52] = "Handheld Night Scene";
-        choices[53] = "Movie Digest";
-        choices[54] = "Live View Control";
-        choices[55] = "Discreet";
-        choices[56] = "Blur Reduction";
-        choices[57] = "Monochrome";
-        choices[58] = "Toy Camera Effect";
-        choices[59] = "Scene Intelligent Auto";
-        choices[60] = "High-speed Burst HQ";
-        choices[61] = "Smooth Skin";
-        choices[62] = "Soft Focus";
-        choices[257] = "Spotlight";
-        choices[258] = "Night 2";
-        choices[259] = "Night+";
-        choices[260] = "Super Night";
-        choices[261] = "Sunset";
-        choices[263] = "Night Scene";
-        choices[264] = "Surface";
-        choices[265] = "Low Light 2";
-    }
-};
-CAEasyModeInterpreter caEasyModeInterpreter;
-
-class CADigitalZoomInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CADigitalZoomInterpreter()
-    {
-        choices[0] = "None";
-        choices[1] = "2x";
-        choices[2] = "4x";
-        choices[3] = "Other";
-    }
-};
-CADigitalZoomInterpreter caDigitalZoomInterpreter;
-
-class CAMeteringModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAMeteringModeInterpreter()
-    {
-        choices[0] = "Default";
-        choices[1] = "Spot";
-        choices[2] = "Average";
-        choices[3] = "Evaluative";
-        choices[4] = "Partial";
-        choices[5] = "Center-weighted average";
-    }
-};
-CAMeteringModeInterpreter caMeteringModeInterpreter;
-
-class CAFocusRangeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAFocusRangeInterpreter()
-    {
-        choices[0] = "Manual";
-        choices[1] = "Auto";
-        choices[2] = "Not Known";
-        choices[3] = "Macro";
-        choices[4] = "Very Close";
-        choices[5] = "Close";
-        choices[6] = "Middle Range";
-        choices[7] = "Far Range";
-        choices[8] = "Pan Focus";
-        choices[9] = "Super Macro";
-        choices[10] = "Infinity";
-    }
-};
-CAFocusRangeInterpreter caFocusRangeInterpreter;
-
-class CAAFPointInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAAFPointInterpreter()
-    {
-        choices[0x2005] = "Manual AF point selection ";
-        choices[0x3000] = "None (MF)";
-        choices[0x3001] = "Auto AF point selection ";
-        choices[0x3002] = "Right ";
-        choices[0x3003] = "Center ";
-        choices[0x3004] = "Left ";
-        choices[0x4001] = "Auto AF point selection ";
-        choices[0x4006] = "Face Detect";
-    }
-};
-CAAFPointInterpreter caAFPointInterpreter;
-
-class CAExposureModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAExposureModeInterpreter()
-    {
-        choices[0] = "Easy";
-        choices[1] = "Program AE";
-        choices[2] = "Shutter speed priority AE";
-        choices[3] = "Aperture-priority AE";
-        choices[4] = "Manual";
-        choices[5] = "Depth-of-field AE";
-        choices[6] = "M-Dep";
-        choices[7] = "Bulb";
-    }
-};
-CAExposureModeInterpreter caExposureModeInterpreter;
-
-class CAFlashBitsInterpreter : public Interpreter
-{
-public:
-    std::string toString (const Tag* t) const override
-    {
-        std::ostringstream s;
-        unsigned bits = t->toInt (0, SHORT);
-
-        if ( bits & 0x0001 ) {
-            s << "Manual ";
-        }
-
-        if ( bits & 0x0002 ) {
-            s << "TTL ";
-        }
-
-        if ( bits & 0x0004 ) {
-            s << "A-TTL ";
-        }
-
-        if ( bits & 0x0008 ) {
-            s << "E-TTL ";
-        }
-
-        if ( bits & 0x0010 ) {
-            s << "FP sync enabled ";
-        }
-
-        if ( bits & 0x0080 ) {
-            s << "2nd curtain ";
-        }
-
-        if ( bits & 0x0800 ) {
-            s << "FP sync used ";
-        }
-
-        if ( bits & 0x2000 ) {
-            s << "Built-in ";
-        }
-
-        if ( bits & 0x4000 ) {
-            s << "External ";
-        }
-
-        return s.str();
-    }
-};
-CAFlashBitsInterpreter caFlashBitsInterpreter;
-
-class CAFocusContinuousInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAFocusContinuousInterpreter()
-    {
-        choices[0] = "Single";
-        choices[1] = "Continuous";
-        choices[8] = "Manual";
-    }
-};
-CAFocusContinuousInterpreter caFocusContinuousInterpreter;
-
-class CAAESettingsInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAAESettingsInterpreter()
-    {
-        choices[0] = "Normal AE";
-        choices[1] = "Exposure Compensation";
-        choices[2] = "AE Lock";
-        choices[3] = "AE Lock + Exposure Comp.";
-        choices[4] = "No AE";
-    }
-};
-CAAESettingsInterpreter caAESettingsInterpreter;
-
-class CAStabilizationInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAStabilizationInterpreter()
-    {
-        choices[0] = "Off";
-        choices[1] = "On";
-        choices[2] = "Shoot Only";
-        choices[3] = "Panning";
-        choices[4] = "Dynamic";
-        choices[256] = "Off (2)";
-        choices[257] = "On (2)";
-        choices[258] = "Shoot Only (2)";
-        choices[259] = "Panning (2)";
-        choices[260] = "Dynamic (2)";
-    }
-};
-CAStabilizationInterpreter caStabilizationInterpreter;
-
-class CASpotMeteringInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CASpotMeteringInterpreter()
-    {
-        choices[0] = "Center";
-        choices[1] = "AF Point";
-    }
-};
-CASpotMeteringInterpreter caSpotMeteringInterpreter;
-
-class CAPhotoEffectInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAPhotoEffectInterpreter()
-    {
-        choices[0] = "Off";
-        choices[1] = "Vivid";
-        choices[2] = "Neutral";
-        choices[3] = "Smooth";
-        choices[4] = "Sepia";
-        choices[5] = "B&W";
-        choices[6] = "Custom";
-        choices[100] = "My Color Data";
-    }
-};
-CAPhotoEffectInterpreter caPhotoEffectInterpreter;
-
-class CAManualFlashInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAManualFlashInterpreter()
-    {
-        choices[0] = "N/A";
-        choices[0x500] = "Full";
-        choices[0x502] = "Medium";
-        choices[0x504] = "Low";
-        choices[0x7fff] = "N/A";
-    }
-};
-CAManualFlashInterpreter caManualFlashInterpreter;
-
-class CARAWQualityInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CARAWQualityInterpreter()
-    {
-        choices[0] = "N/A";
-        choices[1] = "sRAW1 (mRAW)";
-        choices[2] = "sRAW2 (sRAW)";
-    }
-};
-CARAWQualityInterpreter caRAWQualityInterpreter;
-
-class CAFocalInterpreter : public Interpreter
-{
-public:
-    std::string toString (const Tag* t) const override
-    {
-        Tag *unitTag = t->getParent()->getRoot()->findTag ("FocalUnits");
-        double v = unitTag ? unitTag->toDouble() : 1.;
-        v = (v > 0. ? t->toDouble() / v : t->toDouble());
-
-        if ( v < 0. || v > 1000000.) {
-            return "undef";
-        }
-
-        char buffer[32];
-        snprintf(buffer, sizeof(buffer), "%.1f", v );
-        return buffer;
-    }
-};
-CAFocalInterpreter caFocalInterpreter;
-
-class CALensInterpreter : public IntLensInterpreter< int >
-{
-public:
-    CALensInterpreter ()
-    {
-        choices = {
-            {1, "Canon EF 50mm f/1.8"},
-            {2, "Canon EF 28mm f/2.8 or Sigma Lens"},
-            {2, "Sigma 24mm f/2.8 Super Wide II"},
-            {3, "Canon EF 135mm f/2.8 Soft"},
-            {4, "Canon EF 35-105mm f/3.5-4.5 or Sigma Lens"},
-            {4, "Sigma UC Zoom 35-135mm f/4-5.6"},
-            {5, "Canon EF 35-70mm f/3.5-4.5"},
-            {6, "Canon EF 28-70mm f/3.5-4.5 or Sigma or Tokina Lens"},
-            {6, "Sigma 18-50mm f/3.5-5.6 DC"},
-            {6, "Sigma 18-125mm f/3.5-5.6 DC IF ASP"},
-            {6, "Tokina AF 193-2 19-35mm f/3.5-4.5"},
-            {6, "Sigma 28-80mm f/3.5-5.6 II Macro"},
-            {6, "Sigma 28-300mm f/3.5-6.3 DG Macro"},
-            {7, "Canon EF 100-300mm f/5.6L"},
-            {8, "Canon EF 100-300mm f/5.6 or Sigma or Tokina Lens"},
-            {8, "Sigma 70-300mm f/4-5.6 [APO] DG Macro"},
-            {8, "Tokina AT-X 242 AF 24-200mm f/3.5-5.6"},
-            {9, "Canon EF 70-210mm f/4"},
-            {9, "Sigma 55-200mm f/4-5.6 DC"},
-            {10, "Canon EF 50mm f/2.5 Macro or Sigma Lens"},
-            {10, "Sigma 50mm f/2.8 EX"},
-            {10, "Sigma 28mm f/1.8"},
-            {10, "Sigma 105mm f/2.8 Macro EX"},
-            {10, "Sigma 70mm f/2.8 EX DG Macro EF"},
-            {11, "Canon EF 35mm f/2"},
-            {13, "Canon EF 15mm f/2.8 Fisheye"},
-            {14, "Canon EF 50-200mm f/3.5-4.5L"},
-            {15, "Canon EF 50-200mm f/3.5-4.5"},
-            {16, "Canon EF 35-135mm f/3.5-4.5"},
-            {17, "Canon EF 35-70mm f/3.5-4.5A"},
-            {18, "Canon EF 28-70mm f/3.5-4.5"},
-            {20, "Canon EF 100-200mm f/4.5A"},
-            {21, "Canon EF 80-200mm f/2.8L"},
-            {22, "Canon EF 20-35mm f/2.8L or Tokina Lens"},
-            {22, "Tokina AT-X 280 AF Pro 28-80mm f/2.8 Aspherical"},
-            {23, "Canon EF 35-105mm f/3.5-4.5"},
-            {24, "Canon EF 35-80mm f/4-5.6 Power Zoom"},
-            {25, "Canon EF 35-80mm f/4-5.6 Power Zoom"},
-            {26, "Canon EF 100mm f/2.8 Macro or Other Lens"},
-            {26, "Cosina 100mm f/3.5 Macro AF"},
-            {26, "Tamron SP AF 90mm f/2.8 Di Macro"},
-            {26, "Tamron SP AF 180mm f/3.5 Di Macro"},
-            {26, "Carl Zeiss Planar T* 50mm f/1.4"},
-            {26, "Voigtlander APO Lanthar 125mm F2.5 SL Macro"},
-            {26, "Carl Zeiss Planar T 85mm f/1.4 ZE"},
-            {27, "Canon EF 35-80mm f/4-5.6"},
-            {28, "Canon EF 80-200mm f/4.5-5.6 or Tamron Lens"},
-            {28, "Tamron SP AF 28-105mm f/2.8 LD Aspherical IF"},
-            {28, "Tamron SP AF 28-75mm f/2.8 XR Di LD Aspherical [IF] Macro"},
-            {28, "Tamron AF 70-300mm f/4-5.6 Di LD 1:2 Macro"},
-            {28, "Tamron AF Aspherical 28-200mm f/3.8-5.6"},
-            {29, "Canon EF 50mm f/1.8 II"},
-            {30, "Canon EF 35-105mm f/4.5-5.6"},
-            {31, "Canon EF 75-300mm f/4-5.6 or Tamron Lens"},
-            {31, "Tamron SP AF 300mm f/2.8 LD IF"},
-            {32, "Canon EF 24mm f/2.8 or Sigma Lens"},
-            {32, "Sigma 15mm f/2.8 EX Fisheye"},
-            {33, "Voigtlander or Carl Zeiss Lens"},
-            {33, "Voigtlander Ultron 40mm f/2 SLII Aspherical"},
-            {33, "Voigtlander Color Skopar 20mm f/3.5 SLII Aspherical"},
-            {33, "Voigtlander APO-Lanthar 90mm f/3.5 SLII Close Focus"},
-            {33, "Carl Zeiss Distagon T* 15mm f/2.8 ZE"},
-            {33, "Carl Zeiss Distagon T* 18mm f/3.5 ZE"},
-            {33, "Carl Zeiss Distagon T* 21mm f/2.8 ZE"},
-            {33, "Carl Zeiss Distagon T* 25mm f/2 ZE"},
-            {33, "Carl Zeiss Distagon T* 28mm f/2 ZE"},
-            {33, "Carl Zeiss Distagon T* 35mm f/2 ZE"},
-            {33, "Carl Zeiss Distagon T* 35mm f/1.4 ZE"},
-            {33, "Carl Zeiss Planar T* 50mm f/1.4 ZE"},
-            {33, "Carl Zeiss Makro-Planar T* 50mm f/2 ZE"},
-            {33, "Carl Zeiss Makro-Planar T* 100mm f/2 ZE"},
-            {33, "Carl Zeiss Apo-Sonnar T* 135mm f/2 ZE"},
-            {35, "Canon EF 35-80mm f/4-5.6"},
-            {36, "Canon EF 38-76mm f/4.5-5.6"},
-            {37, "Canon EF 35-80mm f/4-5.6 or Tamron Lens"},
-            {37, "Tamron 70-200mm f/2.8 Di LD IF Macro"},
-            {37, "Tamron AF 28-300mm f/3.5-6.3 XR Di VC LD Aspherical [IF] Macro (A20)"},
-            {37, "Tamron SP AF 17-50mm f/2.8 XR Di II VC LD Aspherical [IF]"},
-            {37, "Tamron AF 18-270mm f/3.5-6.3 Di II VC LD Aspherical [IF] Macro"},
-            {38, "Canon EF 80-200mm f/4.5-5.6 II"},
-            {39, "Canon EF 75-300mm f/4-5.6"},
-            {40, "Canon EF 28-80mm f/3.5-5.6"},
-            {41, "Canon EF 28-90mm f/4-5.6"},
-            {42, "Canon EF 28-200mm f/3.5-5.6 or Tamron Lens"},
-            {42, "Tamron AF 28-300mm f/3.5-6.3 XR Di VC LD Aspherical [IF] Macro (A20)"},
-            {43, "Canon EF 28-105mm f/4-5.6"},
-            {44, "Canon EF 90-300mm f/4.5-5.6"},
-            {45, "Canon EF-S 18-55mm f/3.5-5.6 [II]"},
-            {46, "Canon EF 28-90mm f/4-5.6"},
-            {47, "Zeiss Milvus 35mm f/2 or 50mm f/2"},
-            {47, "Zeiss Milvus 50mm f/2 Makro"},
-            {47, "Zeiss Milvus 135mm f/2 ZE"},
-            {48, "Canon EF-S 18-55mm f/3.5-5.6 IS"},
-            {49, "Canon EF-S 55-250mm f/4-5.6 IS"},
-            {50, "Canon EF-S 18-200mm f/3.5-5.6 IS"},
-            {51, "Canon EF-S 18-135mm f/3.5-5.6 IS"},
-            {52, "Canon EF-S 18-55mm f/3.5-5.6 IS II"},
-            {53, "Canon EF-S 18-55mm f/3.5-5.6 III"},
-            {54, "Canon EF-S 55-250mm f/4-5.6 IS II"},
-            {60, "Irix 11mm f/4"},
-            {63, "Irix 30mm F1.4 Dragonfly"},
-            {80, "Canon TS-E 50mm f/2.8L Macro"},
-            {81, "Canon TS-E 90mm f/2.8L Macro"},
-            {82, "Canon TS-E 135mm f/4L Macro"},
-            {94, "Canon TS-E 17mm f/4L"},
-            {95, "Canon TS-E 24mm f/3.5L II"},
-            {103, "Samyang AF 14mm f/2.8 EF or Rokinon Lens"},
-            {103, "Rokinon SP 14mm f/2.4"},
-            {103, "Rokinon AF 14mm f/2.8 EF"},
-            {106, "Rokinon SP / Samyang XP 35mm f/1.2"},
-            {112, "Sigma 28mm f/1.5 FF High-speed Prime or other Sigma Lens"},
-            {112, "Sigma 40mm f/1.5 FF High-speed Prime"},
-            {112, "Sigma 105mm f/1.5 FF High-speed Prime"},
-            {117, "Tamron 35-150mm f/2.8-4.0 Di VC OSD (A043) or other Tamron Lens"},
-            {117, "Tamron SP 35mm f/1.4 Di USD (F045)"},
-            {124, "Canon MP-E 65mm f/2.8 1-5x Macro Photo"},
-            {125, "Canon TS-E 24mm f/3.5L"},
-            {126, "Canon TS-E 45mm f/2.8"},
-            {127, "Canon TS-E 90mm f/2.8 or Tamron Lens"},
-            {127, "Tamron 18-200mm f/3.5-6.3 Di II VC (B018)"},
-            {129, "Canon EF 300mm f/2.8L USM"},
-            {130, "Canon EF 50mm f/1.0L USM"},
-            {131, "Canon EF 28-80mm f/2.8-4L USM or Sigma Lens"},
-            {131, "Sigma 8mm f/3.5 EX DG Circular Fisheye"},
-            {131, "Sigma 17-35mm f/2.8-4 EX DG Aspherical HSM"},
-            {131, "Sigma 17-70mm f/2.8-4.5 DC Macro"},
-            {131, "Sigma APO 50-150mm f/2.8 [II] EX DC HSM"},
-            {131, "Sigma APO 120-300mm f/2.8 EX DG HSM"},
-            {131, "Sigma 4.5mm f/2.8 EX DC HSM Circular Fisheye"},
-            {131, "Sigma 70-200mm f/2.8 APO EX HSM"},
-            {131, "Sigma 28-70mm f/2.8-4 DG"},
-            {132, "Canon EF 1200mm f/5.6L USM"},
-            {134, "Canon EF 600mm f/4L IS USM"},
-            {135, "Canon EF 200mm f/1.8L USM"},
-            {136, "Canon EF 300mm f/2.8L USM"},
-            {136, "Tamron SP 15-30mm f/2.8 Di VC USD (A012)"},
-            {137, "Canon EF 85mm f/1.2L USM or Sigma or Tamron Lens"},
-            {137, "Sigma 18-50mm f/2.8-4.5 DC OS HSM"},
-            {137, "Sigma 50-200mm f/4-5.6 DC OS HSM"},
-            {137, "Sigma 18-250mm f/3.5-6.3 DC OS HSM"},
-            {137, "Sigma 24-70mm f/2.8 IF EX DG HSM"},
-            {137, "Sigma 18-125mm f/3.8-5.6 DC OS HSM"},
-            {137, "Sigma 17-70mm f/2.8-4 DC Macro OS HSM | C"},
-            {137, "Sigma 17-50mm f/2.8 OS HSM"},
-            {137, "Sigma 18-200mm f/3.5-6.3 DC OS HSM [II]"},
-            {137, "Tamron AF 18-270mm f/3.5-6.3 Di II VC PZD (B008)"},
-            {137, "Sigma 8-16mm f/4.5-5.6 DC HSM"},
-            {137, "Tamron SP 17-50mm f/2.8 XR Di II VC (B005)"},
-            {137, "Tamron SP 60mm f/2 Macro Di II (G005)"},
-            {137, "Sigma 10-20mm f/3.5 EX DC HSM"},
-            {137, "Tamron SP 24-70mm f/2.8 Di VC USD"},
-            {137, "Sigma 18-35mm f/1.8 DC HSM"},
-            {137, "Sigma 12-24mm f/4.5-5.6 DG HSM II"},
-            {137, "Sigma 70-300mm f/4-5.6 DG OS"},
-            {138, "Canon EF 28-80mm f/2.8-4L"},
-            {139, "Canon EF 400mm f/2.8L USM"},
-            {140, "Canon EF 500mm f/4.5L USM"},
-            {141, "Canon EF 500mm f/4.5L USM"},
-            {142, "Canon EF 300mm f/2.8L IS USM"},
-            {143, "Canon EF 500mm f/4L IS USM or Sigma Lens"},
-            {143, "Sigma 17-70mm f/2.8-4 DC Macro OS HSM"},
-            {144, "Canon EF 35-135mm f/4-5.6 USM"},
-            {145, "Canon EF 100-300mm f/4.5-5.6 USM"},
-            {146, "Canon EF 70-210mm f/3.5-4.5 USM"},
-            {147, "Canon EF 35-135mm f/4-5.6 USM"},
-            {148, "Canon EF 28-80mm f/3.5-5.6 USM"},
-            {149, "Canon EF 100mm f/2 USM"},
-            {150, "Canon EF 14mm f/2.8L USM or Sigma Lens"},
-            {150, "Sigma 20mm EX f/1.8"},
-            {150, "Sigma 30mm f/1.4 DC HSM"},
-            {150, "Sigma 24mm f/1.8 DG Macro EX"},
-            {150, "Sigma 28mm f/1.8 DG Macro EX"},
-            {150, "Sigma 18-35mm f/1.8 DC HSM | A"},
-            {151, "Canon EF 200mm f/2.8L USM"},
-            {152, "Canon EF 300mm f/4L IS USM or Sigma Lens"},
-            {152, "Sigma 12-24mm f/4.5-5.6 EX DG ASPHERICAL HSM"},
-            {152, "Sigma 14mm f/2.8 EX Aspherical HSM"},
-            {152, "Sigma 10-20mm f/4-5.6"},
-            {152, "Sigma 100-300mm f/4"},
-            {152, "Sigma 300-800mm f/5.6 APO EX DG HSM"},
-            {153, "Canon EF 35-350mm f/3.5-5.6L USM or Sigma or Tamron Lens"},
-            {153, "Sigma 50-500mm f/4-6.3 APO HSM EX"},
-            {153, "Tamron AF 28-300mm f/3.5-6.3 XR LD Aspherical [IF] Macro"},
-            {153, "Tamron AF 18-200mm f/3.5-6.3 XR Di II LD Aspherical [IF] Macro (A14)"},
-            {153, "Tamron 18-250mm f/3.5-6.3 Di II LD Aspherical [IF] Macro"},
-            {154, "Canon EF 20mm f/2.8 USM or Zeiss Lens"},
-            {154, "Zeiss Milvus 21mm f/2.8"},
-            {154, "Zeiss Milvus 15mm f/2.8 ZE"},
-            {154, "Zeiss Milvus 18mm f/2.8 ZE"},
-            {155, "Canon EF 85mm f/1.8 USM or Sigma Lens"},
-            {155, "Sigma 14mm f/1.8 DG HSM | A"},
-            {156, "Canon EF 28-105mm f/3.5-4.5 USM or Tamron Lens"},
-            {156, "Tamron SP 70-300mm f/4-5.6 Di VC USD (A005)"},
-            {156, "Tamron SP AF 28-105mm f/2.8 LD Aspherical IF (176D)"},
-            {160, "Canon EF 20-35mm f/3.5-4.5 USM or Tamron or Tokina Lens"},
-            {160, "Tamron AF 19-35mm f/3.5-4.5"},
-            {160, "Tokina AT-X 124 AF Pro DX 12-24mm f/4"},
-            {160, "Tokina AT-X 107 AF DX 10-17mm f/3.5-4.5 Fisheye"},
-            {160, "Tokina AT-X 116 AF Pro DX 11-16mm f/2.8"},
-            {160, "Tokina AT-X 11-20 F2.8 PRO DX Aspherical 11-20mm f/2.8"},
-            {161, "Canon EF 28-70mm f/2.8L USM or Other Lens"},
-            {161, "Sigma 24-70mm f/2.8 EX"},
-            {161, "Sigma 28-70mm f/2.8 EX"},
-            {161, "Sigma 24-60mm f/2.8 EX DG"},
-            {161, "Tamron AF 17-50mm f/2.8 Di-II LD Aspherical"},
-            {161, "Tamron 90mm f/2.8"},
-            {161, "Tamron SP AF 17-35mm f/2.8-4 Di LD Aspherical IF (A05)"},
-            {161, "Tamron SP AF 28-75mm f/2.8 XR Di LD Aspherical [IF] Macro"},
-            {161, "Tokina AT-X 24-70mm f/2.8 PRO FX (IF)"},
-            {162, "Canon EF 200mm f/2.8L USM"},
-            {163, "Canon EF 300mm f/4L"},
-            {164, "Canon EF 400mm f/5.6L"},
-            {165, "Canon EF 70-200mm f/2.8L USM"},
-            {166, "Canon EF 70-200mm f/2.8L USM + 1.4x"},
-            {167, "Canon EF 70-200mm f/2.8L USM + 2x"},
-            {168, "Canon EF 28mm f/1.8 USM or Sigma Lens"},
-            {168, "Sigma 50-100mm f/1.8 DC HSM | A"},
-            {169, "Canon EF 17-35mm f/2.8L USM or Sigma Lens"},
-            {169, "Sigma 18-200mm f/3.5-6.3 DC OS"},
-            {169, "Sigma 15-30mm f/3.5-4.5 EX DG Aspherical"},
-            {169, "Sigma 18-50mm f/2.8 Macro"},
-            {169, "Sigma 50mm f/1.4 EX DG HSM"},
-            {169, "Sigma 85mm f/1.4 EX DG HSM"},
-            {169, "Sigma 30mm f/1.4 EX DC HSM"},
-            {169, "Sigma 35mm f/1.4 DG HSM"},
-            {169, "Sigma 35mm f/1.5 FF High-Speed Prime | 017"},
-            {169, "Sigma 70mm f/2.8 Macro EX DG"},
-            {170, "Canon EF 200mm f/2.8L II USM or Sigma Lens"},
-            {170, "Sigma 300mm f/2.8 APO EX DG HSM"},
-            {170, "Sigma 800mm f/5.6 APO EX DG HSM"},
-            {171, "Canon EF 300mm f/4L USM"},
-            {172, "Canon EF 400mm f/5.6L USM or Sigma Lens"},
-            {172, "Sigma 150-600mm f/5-6.3 DG OS HSM | S"},
-            {172, "Sigma 500mm f/4.5 APO EX DG HSM"},
-            {173, "Canon EF 180mm Macro f/3.5L USM or Sigma Lens"},
-            {173, "Sigma 180mm EX HSM Macro f/3.5"},
-            {173, "Sigma APO Macro 150mm f/2.8 EX DG HSM"},
-            {173, "Sigma 10mm f/2.8 EX DC Fisheye"},
-            {173, "Sigma 15mm f/2.8 EX DG Diagonal Fisheye"},
-            {173, "Venus Laowa 100mm F2.8 2X Ultra Macro APO"},
-            {174, "Canon EF 135mm f/2L USM or Other Lens"},
-            {174, "Sigma 70-200mm f/2.8 EX DG APO OS HSM"},
-            {174, "Sigma 50-500mm f/4.5-6.3 APO DG OS HSM"},
-            {174, "Sigma 150-500mm f/5-6.3 APO DG OS HSM"},
-            {174, "Zeiss Milvus 100mm f/2 Makro"},
-            {174, "Sigma APO 50-150mm f/2.8 EX DC OS HSM"},
-            {174, "Sigma APO 120-300mm f/2.8 EX DG OS HSM"},
-            {174, "Sigma 120-300mm f/2.8 DG OS HSM S013"},
-            {174, "Sigma 120-400mm f/4.5-5.6 APO DG OS HSM"},
-            {174, "Sigma 200-500mm f/2.8 APO EX DG"},
-            {175, "Canon EF 400mm f/2.8L USM"},
-            {176, "Canon EF 24-85mm f/3.5-4.5 USM"},
-            {177, "Canon EF 300mm f/4L IS USM"},
-            {178, "Canon EF 28-135mm f/3.5-5.6 IS"},
-            {179, "Canon EF 24mm f/1.4L USM"},
-            {180, "Canon EF 35mm f/1.4L USM or Other Lens"},
-            {180, "Sigma 50mm f/1.4 DG HSM | A"},
-            {180, "Sigma 24mm f/1.4 DG HSM | A"},
-            {180, "Zeiss Milvus 50mm f/1.4"},
-            {180, "Zeiss Milvus 85mm f/1.4"},
-            {180, "Zeiss Otus 28mm f/1.4 ZE"},
-            {180, "Sigma 24mm f/1.5 FF High-Speed Prime | 017"},
-            {180, "Sigma 50mm f/1.5 FF High-Speed Prime | 017"},
-            {180, "Sigma 85mm f/1.5 FF High-Speed Prime | 017"},
-            {180, "Tokina Opera 50mm f/1.4 FF"},
-            {180, "Sigma 20mm f/1.4 DG HSM | A"},
-            {181, "Canon EF 100-400mm f/4.5-5.6L IS USM + 1.4x or Sigma Lens"},
-            {181, "Sigma 150-600mm f/5-6.3 DG OS HSM | S + 1.4x"},
-            {182, "Canon EF 100-400mm f/4.5-5.6L IS USM + 2x or Sigma Lens"},
-            {182, "Sigma 150-600mm f/5-6.3 DG OS HSM | S + 2x"},
-            {183, "Canon EF 100-400mm f/4.5-5.6L IS USM or Sigma Lens"},
-            {183, "Sigma 150mm f/2.8 EX DG OS HSM APO Macro"},
-            {183, "Sigma 105mm f/2.8 EX DG OS HSM Macro"},
-            {183, "Sigma 180mm f/2.8 EX DG OS HSM APO Macro"},
-            {183, "Sigma 150-600mm f/5-6.3 DG OS HSM | C"},
-            {183, "Sigma 150-600mm f/5-6.3 DG OS HSM | S"},
-            {183, "Sigma 100-400mm f/5-6.3 DG OS HSM"},
-            {183, "Sigma 180mm f/3.5 APO Macro EX DG IF HSM"},
-            {184, "Canon EF 400mm f/2.8L USM + 2x"},
-            {185, "Canon EF 600mm f/4L IS USM"},
-            {186, "Canon EF 70-200mm f/4L USM"},
-            {187, "Canon EF 70-200mm f/4L USM + 1.4x"},
-            {188, "Canon EF 70-200mm f/4L USM + 2x"},
-            {189, "Canon EF 70-200mm f/4L USM + 2.8x"},
-            {190, "Canon EF 100mm f/2.8 Macro USM"},
-            {191, "Canon EF 400mm f/4 DO IS or Sigma Lens"},
-            {191, "Sigma 500mm f/4 DG OS HSM"},
-            {193, "Canon EF 35-80mm f/4-5.6 USM"},
-            {194, "Canon EF 80-200mm f/4.5-5.6 USM"},
-            {195, "Canon EF 35-105mm f/4.5-5.6 USM"},
-            {196, "Canon EF 75-300mm f/4-5.6 USM"},
-            {197, "Canon EF 75-300mm f/4-5.6 IS USM or Sigma Lens"},
-            {197, "Sigma 18-300mm f/3.5-6.3 DC Macro OS HSM"},
-            {198, "Canon EF 50mm f/1.4 USM or Other Lens"},
-            {198, "Zeiss Otus 55mm f/1.4 ZE"},
-            {198, "Zeiss Otus 85mm f/1.4 ZE"},
-            {198, "Zeiss Milvus 25mm f/1.4"},
-            {198, "Zeiss Otus 100mm f/1.4"},
-            {198, "Zeiss Milvus 35mm f/1.4 ZE"},
-            {198, "Yongnuo YN 35mm f/2"},
-            {199, "Canon EF 28-80mm f/3.5-5.6 USM"},
-            {200, "Canon EF 75-300mm f/4-5.6 USM"},
-            {201, "Canon EF 28-80mm f/3.5-5.6 USM"},
-            {202, "Canon EF 28-80mm f/3.5-5.6 USM IV"},
-            {208, "Canon EF 22-55mm f/4-5.6 USM"},
-            {209, "Canon EF 55-200mm f/4.5-5.6"},
-            {210, "Canon EF 28-90mm f/4-5.6 USM"},
-            {211, "Canon EF 28-200mm f/3.5-5.6 USM"},
-            {212, "Canon EF 28-105mm f/4-5.6 USM"},
-            {213, "Canon EF 90-300mm f/4.5-5.6 USM or Tamron Lens"},
-            {213, "Tamron SP 150-600mm f/5-6.3 Di VC USD (A011)"},
-            {213, "Tamron 16-300mm f/3.5-6.3 Di II VC PZD Macro (B016)"},
-            {213, "Tamron SP 35mm f/1.8 Di VC USD (F012)"},
-            {213, "Tamron SP 45mm f/1.8 Di VC USD (F013)"},
-            {214, "Canon EF-S 18-55mm f/3.5-5.6 USM"},
-            {215, "Canon EF 55-200mm f/4.5-5.6 II USM"},
-            {217, "Tamron AF 18-270mm f/3.5-6.3 Di II VC PZD"},
-            {220, "Yongnuo YN 50mm f/1.8"},
-            {224, "Canon EF 70-200mm f/2.8L IS USM"},
-            {225, "Canon EF 70-200mm f/2.8L IS USM + 1.4x"},
-            {226, "Canon EF 70-200mm f/2.8L IS USM + 2x"},
-            {227, "Canon EF 70-200mm f/2.8L IS USM + 2.8x"},
-            {228, "Canon EF 28-105mm f/3.5-4.5 USM"},
-            {229, "Canon EF 16-35mm f/2.8L USM"},
-            {230, "Canon EF 24-70mm f/2.8L USM"},
-            {231, "Canon EF 17-40mm f/4L USM or Sigma Lens"},
-            {231, "Sigma 12-24mm f/4 DG HSM A016"},
-            {232, "Canon EF 70-300mm f/4.5-5.6 DO IS USM"},
-            {233, "Canon EF 28-300mm f/3.5-5.6L IS USM"},
-            {234, "Canon EF-S 17-85mm f/4-5.6 IS USM or Tokina Lens"},
-            {234, "Tokina AT-X 12-28 PRO DX 12-28mm f/4"},
-            {235, "Canon EF-S 10-22mm f/3.5-4.5 USM"},
-            {236, "Canon EF-S 60mm f/2.8 Macro USM"},
-            {237, "Canon EF 24-105mm f/4L IS USM"},
-            {238, "Canon EF 70-300mm f/4-5.6 IS USM"},
-            {239, "Canon EF 85mm f/1.2L II USM or Rokinon Lens"},
-            {239, "Rokinon SP 85mm f/1.2"},
-            {240, "Canon EF-S 17-55mm f/2.8 IS USM or Sigma Lens"},
-            {240, "Sigma 17-50mm f/2.8 EX DC OS HSM"},
-            {241, "Canon EF 50mm f/1.2L USM"},
-            {242, "Canon EF 70-200mm f/4L IS USM"},
-            {243, "Canon EF 70-200mm f/4L IS USM + 1.4x"},
-            {244, "Canon EF 70-200mm f/4L IS USM + 2x"},
-            {245, "Canon EF 70-200mm f/4L IS USM + 2.8x"},
-            {246, "Canon EF 16-35mm f/2.8L II USM"},
-            {247, "Canon EF 14mm f/2.8L II USM"},
-            {248, "Canon EF 200mm f/2L IS USM or Sigma Lens"},
-            {248, "Sigma 24-35mm f/2 DG HSM | A"},
-            {248, "Sigma 135mm f/2 FF High-Speed Prime | 017"},
-            {248, "Sigma 24-35mm f/2.2 FF Zoom | 017"},
-            {248, "Sigma 135mm f/1.8 DG HSM A017"},
-            {249, "Canon EF 800mm f/5.6L IS USM"},
-            {250, "Canon EF 24mm f/1.4L II USM or Sigma Lens"},
-            {250, "Sigma 20mm f/1.4 DG HSM | A"},
-            {250, "Sigma 20mm f/1.5 FF High-Speed Prime | 017"},
-            {250, "Tokina Opera 16-28mm f/2.8 FF"},
-            {250, "Sigma 85mm f/1.4 DG HSM A016"},
-            {251, "Canon EF 70-200mm f/2.8L IS II USM"},
-            {251, "Canon EF 70-200mm f/2.8L IS III USM"},
-            {252, "Canon EF 70-200mm f/2.8L IS II USM + 1.4x"},
-            {252, "Canon EF 70-200mm f/2.8L IS III USM + 1.4x"},
-            {253, "Canon EF 70-200mm f/2.8L IS II USM + 2x"},
-            {253, "Canon EF 70-200mm f/2.8L IS III USM + 2x"},
-            {254, "Canon EF 100mm f/2.8L Macro IS USM or Tamron Lens"},
-            {254, "Tamron SP 90mm f/2.8 Di VC USD 1:1 Macro (F017)"},
-            {255, "Sigma 24-105mm f/4 DG OS HSM | A or Other Lens"},
-            {255, "Sigma 180mm f/2.8 EX DG OS HSM APO Macro"},
-            {255, "Tamron SP 70-200mm f/2.8 Di VC USD"},
-            {368, "Sigma 14-24mm f/2.8 DG HSM | A or other Sigma Lens"},
-            {368, "Sigma 20mm f/1.4 DG HSM | A"},
-            {368, "Sigma 50mm f/1.4 DG HSM | A"},
-            {368, "Sigma 40mm f/1.4 DG HSM | A"},
-            {368, "Sigma 60-600mm f/4.5-6.3 DG OS HSM | S"},
-            {368, "Sigma 28mm f/1.4 DG HSM | A"},
-            {368, "Sigma 150-600mm f/5-6.3 DG OS HSM | S"},
-            {368, "Sigma 85mm f/1.4 DG HSM | A"},
-            {368, "Sigma 105mm f/1.4 DG HSM"},
-            {368, "Sigma 14-24mm f/2.8 DG HSM"},
-            {368, "Sigma 35mm f/1.4 DG HSM | A"},
-            {368, "Sigma 70mm f/2.8 DG Macro"},
-            {368, "Sigma 18-35mm f/1.8 DC HSM | A"},
-            {368, "Sigma 24-105mm f/4 DG OS HSM | A"},
-            {488, "Canon EF-S 15-85mm f/3.5-5.6 IS USM"},
-            {489, "Canon EF 70-300mm f/4-5.6L IS USM"},
-            {490, "Canon EF 8-15mm f/4L Fisheye USM"},
-            {491, "Canon EF 300mm f/2.8L IS II USM or Tamron Lens"},
-            {491, "Tamron SP 70-200mm f/2.8 Di VC USD G2 (A025)"},
-            {491, "Tamron 18-400mm f/3.5-6.3 Di II VC HLD (B028)"},
-            {491, "Tamron 100-400mm f/4.5-6.3 Di VC USD (A035)"},
-            {491, "Tamron 70-210mm f/4 Di VC USD (A034)"},
-            {491, "Tamron 70-210mm f/4 Di VC USD (A034) + 1.4x"},
-            {491, "Tamron SP 24-70mm f/2.8 Di VC USD G2 (A032)"},
-            {492, "Canon EF 400mm f/2.8L IS II USM"},
-            {493, "Canon EF 500mm f/4L IS II USM or EF 24-105mm f4L IS USM"},
-            {493, "Canon EF 24-105mm f/4L IS USM"},
-            {494, "Canon EF 600mm f/4L IS II USM"},
-            {495, "Canon EF 24-70mm f/2.8L II USM or Sigma Lens"},
-            {495, "Sigma 24-70mm f/2.8 DG OS HSM | A"},
-            {496, "Canon EF 200-400mm f/4L IS USM"},
-            {499, "Canon EF 200-400mm f/4L IS USM + 1.4x"},
-            {502, "Canon EF 28mm f/2.8 IS USM or Tamron Lens"},
-            {502, "Tamron 35mm f/1.8 Di VC USD (F012)"},
-            {503, "Canon EF 24mm f/2.8 IS USM"},
-            {504, "Canon EF 24-70mm f/4L IS USM"},
-            {505, "Canon EF 35mm f/2 IS USM"},
-            {506, "Canon EF 400mm f/4 DO IS II USM"},
-            {507, "Canon EF 16-35mm f/4L IS USM"},
-            {508, "Canon EF 11-24mm f/4L USM or Tamron Lens"},
-            {508, "Tamron 10-24mm f/3.5-4.5 Di II VC HLD (B023)"},
-            {624, "Sigma 70-200mm f/2.8 DG OS HSM | S or other Sigma Lens"},
-            {624, "Sigma 150-600mm f/5-6.3 | C"},
-            {747, "Canon EF 100-400mm f/4.5-5.6L IS II USM or Tamron Lens"},
-            {747, "Tamron SP 150-600mm f/5-6.3 Di VC USD G2"},
-            {748, "Canon EF 100-400mm f/4.5-5.6L IS II USM + 1.4x or Tamron Lens"},
-            {748, "Tamron 100-400mm f/4.5-6.3 Di VC USD A035E + 1.4x"},
-            {748, "Tamron 70-210mm f/4 Di VC USD (A034) + 2x"},
-            {749, "Tamron 100-400mm f/4.5-6.3 Di VC USD A035E + 2x"},
-            {750, "Canon EF 35mm f/1.4L II USM or Tamron Lens"},
-            {750, "Tamron SP 85mm f/1.8 Di VC USD (F016)"},
-            {750, "Tamron SP 45mm f/1.8 Di VC USD (F013)"},
-            {751, "Canon EF 16-35mm f/2.8L III USM"},
-            {752, "Canon EF 24-105mm f/4L IS II USM"},
-            {753, "Canon EF 85mm f/1.4L IS USM"},
-            {754, "Canon EF 70-200mm f/4L IS II USM"},
-            {757, "Canon EF 400mm f/2.8L IS III USM"},
-            {758, "Canon EF 600mm f/4L IS III USM"},
-            {1136, "Sigma 24-70mm f/2.8 DG OS HSM | A"},
-            {4142, "Canon EF-S 18-135mm f/3.5-5.6 IS STM"},
-            {4143, "Canon EF-M 18-55mm f/3.5-5.6 IS STM or Tamron Lens"},
-            {4143, "Tamron 18-200mm f/3.5-6.3 Di III VC"},
-            {4144, "Canon EF 40mm f/2.8 STM"},
-            {4145, "Canon EF-M 22mm f/2 STM"},
-            {4146, "Canon EF-S 18-55mm f/3.5-5.6 IS STM"},
-            {4147, "Canon EF-M 11-22mm f/4-5.6 IS STM"},
-            {4148, "Canon EF-S 55-250mm f/4-5.6 IS STM"},
-            {4149, "Canon EF-M 55-200mm f/4.5-6.3 IS STM"},
-            {4150, "Canon EF-S 10-18mm f/4.5-5.6 IS STM"},
-            {4152, "Canon EF 24-105mm f/3.5-5.6 IS STM"},
-            {4153, "Canon EF-M 15-45mm f/3.5-6.3 IS STM"},
-            {4154, "Canon EF-S 24mm f/2.8 STM"},
-            {4155, "Canon EF-M 28mm f/3.5 Macro IS STM"},
-            {4156, "Canon EF 50mm f/1.8 STM"},
-            {4157, "Canon EF-M 18-150mm f/3.5-6.3 IS STM"},
-            {4158, "Canon EF-S 18-55mm f/4-5.6 IS STM"},
-            {4159, "Canon EF-M 32mm f/1.4 STM"},
-            {4160, "Canon EF-S 35mm f/2.8 Macro IS STM"},
-            {4208, "Sigma 56mm f/1.4 DC DN | C or other Sigma Lens"},
-            {4208, "Sigma 30mm F1.4 DC DN | C"},
-            {36910, "Canon EF 70-300mm f/4-5.6 IS II USM"},
-            {36912, "Canon EF-S 18-135mm f/3.5-5.6 IS USM"},
-            {61182, "Canon RF 35mm F1.8 Macro IS STM or other Canon RF Lens"},
-            {61182, "Canon RF 50mm F1.2 L USM"},
-            {61182, "Canon RF 24-105mm F4 L IS USM"},
-            {61182, "Canon RF 28-70mm F2 L USM"},
-            {61182, "Canon RF 85mm F1.2L USM"},
-            {61182, "Canon RF 85mm F1.2L USM DS"},
-            {61182, "Canon RF 24-70mm F2.8L IS USM"},
-            {61182, "Canon RF 15-35mm F2.8L IS USM"},
-            {61182, "Canon RF 24-240mm F4-6.3 IS USM"},
-            {61182, "Canon RF 70-200mm F2.8L IS USM"},
-            {61182, "Canon RF 85mm F2 MACRO IS STM"},
-            {61182, "Canon RF 600mm F11 IS STM"},
-            {61182, "Canon RF 600mm F11 IS STM + RF1.4x"},
-            {61182, "Canon RF 600mm F11 IS STM + RF2x"},
-            {61182, "Canon RF 800mm F11 IS STM"},
-            {61182, "Canon RF 800mm F11 IS STM + RF1.4x"},
-            {61182, "Canon RF 800mm F11 IS STM + RF2x"},
-            {61182, "Canon RF 24-105mm F4-7.1 IS STM"},
-            {61182, "Canon RF 100-500mm F4.5-7.1L IS USM"},
-            {61182, "Canon RF 100-500mm F4.5-7.1L IS USM + RF1.4x"},
-            {61182, "Canon RF 100-500mm F4.5-7.1L IS USM + RF2x"},
-            {61182, "Canon RF 70-200mm F4L IS USM"},
-            {61182, "Canon RF 100mm F2.8L MACRO IS USM"},
-            {61182, "Canon RF 50mm F1.8 STM"},
-            {61182, "Canon RF 14-35mm F4L IS USM"},
-            {61182, "Canon RF-S 18-45mm F4.5-6.3 IS STM"},
-            {61182, "Canon RF 100-400mm F5.6-8 IS USM"},
-            {61182, "Canon RF 100-400mm F5.6-8 IS USM + RF1.4x"},
-            {61182, "Canon RF 100-400mm F5.6-8 IS USM + RF2x"},
-            {61182, "Canon RF-S 18-150mm F3.5-6.3 IS STM"},
-            {61182, "Canon RF 24mm F1.8 MACRO IS STM"},
-            {61182, "Canon RF 16mm F2.8 STM"},
-            {61182, "Canon RF 400mm F2.8L IS USM"},
-            {61182, "Canon RF 400mm F2.8L IS USM + RF1.4x"},
-            {61182, "Canon RF 400mm F2.8L IS USM + RF2x"},
-            {61182, "Canon RF 600mm F4L IS USM"},
-            {61182, "Canon RF 15-30mm F4.5-6.3 IS STM"},
-            {61182, "Canon RF 800mm F5.6L IS USM"},
-            {61182, "Canon RF 1200mm F8L IS USM"},
-            {61182, "Canon RF 5.2mm F2.8L Dual Fisheye 3D VR"},
-            {61491, "Canon CN-E 14mm T3.1 L F"},
-            {61492, "Canon CN-E 24mm T1.5 L F"},
-            {61494, "Canon CN-E 85mm T1.3 L F"},
-            {61495, "Canon CN-E 135mm T2.2 L F"},
-            {61496, "Canon CN-E 35mm T1.5 L F"},
-            {65535, "n/a"}
-        };
-    }
-
-    std::string toString (const Tag* t) const override
-    {
-        int lensID = t->toInt();
-
-        it_t r;
-        size_t nFound = choices.count ( lensID );
-
-        if (1 == nFound) {
-            r = choices.find ( lensID );
-            return r->second;
-        }
-
-        Tag *apertureTag = t->getParent()->getRoot()->findTag ("MaxAperture");
-        Tag *focalLengthTag = t->getParent()->getRoot()->findTag ("FocalLength");
-        Tag *focalLengthMaxTag = t->getParent()->getRoot()->findTag ("LongFocal");
-        Tag *focalLengthMinTag = t->getParent()->getRoot()->findTag ("ShortFocal");
-        Tag *unitTag = t->getParent()->getRoot()->findTag ("FocalUnits");
-        double maxApertureAtFocal = 0.;
-        double focalLength = 0.;
-        double focalLengthMin = 0.;
-        double focalLengthMax = 0.;
-
-        if ( apertureTag ) {
-            maxApertureAtFocal = pow (2.0, apertureTag->toDouble() / 64.0);
-        }
-
-        if ( unitTag ) {
-            double unit = unitTag->toDouble();
-
-            if ( unit == 0. ) {
-                unit = 1;
-            }
-
-            if ( focalLengthTag ) {
-                focalLength = focalLengthTag->toDouble();
-            }
-
-            if ( focalLengthMinTag ) {
-                focalLengthMin = focalLengthMinTag->toDouble() / unit;
-            }
-
-            if ( focalLengthMaxTag ) {
-                focalLengthMax = focalLengthMaxTag->toDouble() / unit;
-            }
-        }
-
-        std::ostringstream s;
-        s << "Unknown ";
-
-        if (focalLengthMin > 0.) {
-            s << focalLengthMin;
-        }
-
-        if (focalLengthMax > 0. && focalLengthMax != focalLengthMin) {
-            s << "-" << focalLengthMax;
-        }
-
-        if (focalLengthMin > 0.) {
-            s << "mm";
-        }
-
-        s << " (" << lensID << ")";
-
-        if (0 == nFound) {
-            return s.str();
-        }
-
-        double deltaMin = 1000.;
-
-        std::string bestMatch (s.str());
-        std::ostringstream candidates;
-
-        for (r = choices.lower_bound (lensID); r != choices.upper_bound (lensID); r++) {
-            double a1, a2, f1, f2, dif;
-
-            if ( !extractLensInfo ( r->second, f1, f2, a1, a2) ) {
-                continue;
-            }
-
-            if ( f1 == 0. || a1 == 0.) {
-                continue;
-            }
-
-            if ( focalLength < f1 - .5 || focalLength > f2 + 0.5 ) {
-                continue;
-            }
-
-            if ( focalLengthMin > 0. && fabs (f1 - focalLengthMin) > 0.5 ) {
-                continue;
-            }
-
-            if ( focalLengthMax > 0. && fabs (f2 - focalLengthMax) > 0.5 ) {
-                continue;
-            }
-
-            if ( maxApertureAtFocal > 0.1) {
-                double lensAperture;
-
-                if ( maxApertureAtFocal < a1 - 0.15 || maxApertureAtFocal > a2 + 0.15) {
-                    continue;
-                }
-
-                if ( a1 == a2 || f1 == f2) {
-                    lensAperture = a1;
-                } else {
-                    lensAperture = exp ( log (a1) + (log (a2) - log (a1)) / (log (f2) - log (f1)) * (log (focalLength) - log (f1)) );
-                }
-
-                dif = abs (lensAperture - maxApertureAtFocal);
-            } else {
-                dif = 0;
-            }
-
-            if ( dif < deltaMin ) {
-                deltaMin = dif;
-                bestMatch = r->second;
-            }
-
-            if ( dif < 0.15) {
-                if ( candidates.tellp() ) {
-                    candidates << "\n or " <<  r->second;
-                } else {
-                    candidates <<  r->second;
-                }
-            }
-
-        }
-
-        if ( !candidates.tellp() ) {
-            return bestMatch;
-        } else {
-            return candidates.str();
-        }
-    }
-};
-CALensInterpreter caLensInterpreter;
-
-class CAFocalTypeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAFocalTypeInterpreter()
-    {
-        choices[0] = "Fixed";
-        choices[1] = "Fixed";
-        choices[2] = "Zoom";
-    }
-};
-CAFocalTypeInterpreter caFocalTypeInterpreter;
-
-class CAFocalPlaneInterpreter : public Interpreter
-{
-public:
-    std::string toString (const Tag* t) const override
-    {
-        int val = t->toInt();
-
-        if ( val < 40 ) {
-            return "undef";
-        }
-
-        char buffer[32];
-        snprintf(buffer, sizeof(buffer), "%.2fmm", val * 25.4 / 1000);
-        return buffer;
-    }
-};
-CAFocalPlaneInterpreter caFocalPlaneInterpreter;
-
-class CAExposureTimeInterpreter : public Interpreter
-{
-public:
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        double d = pow (2, - t->toInt() / 32.0);
-        snprintf(buffer, sizeof(buffer), "%.3f", d);
-        return buffer;
-    }
-};
-CAExposureTimeInterpreter caExposureTimeInterpreter;
-
-class CAEVInterpreter : public Interpreter
-{
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        snprintf(buffer, sizeof(buffer), "%.1f", t->toDouble() / 32.0  );
-        return buffer;
-    }
-};
-CAEVInterpreter caEVInterpreter;
-
-class CABaseISOInterpreter : public Interpreter
-{
-public:
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        int a = t->toInt();
-        snprintf(buffer, sizeof(buffer), "%d", a);
-        return buffer;
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        int a = Interpreter::toInt (t, ofs);
-
-        if (a > 1) {
-            double i = pow (2., double (a) / 32. - 4.) * 50.;
-            return i;
-        } else {
-            return 0.;
-        }
-    }
-    int toInt (const Tag* t, int ofs, TagType astype) override
-    {
-        int a = Interpreter::toInt (t, ofs, astype);
-
-        if (a > 1) {
-            int i = static_cast<double>(powf (2.f, static_cast<float>(a) / 32.f - 4.f)) * 50.0 + 0.5;
-            return i;
-        } else {
-            return 0;
-        }
-    }
-};
-CABaseISOInterpreter caBaseISOInterpreter;
-
-class CAToneCurveInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAToneCurveInterpreter()
-    {
-        choices[0] = "Standard";
-        choices[1] = "Manual";
-        choices[2] = "Custom";
-    }
-};
-CAToneCurveInterpreter caToneCurveInterpreter;
-
-class CASharpnessFrequencyInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CASharpnessFrequencyInterpreter()
-    {
-        choices[0] = "N/A";
-        choices[1] = "Lowest";
-        choices[2] = "Low";
-        choices[3] = "Standard";
-        choices[4] = "High";
-        choices[5] = "Highest";
-    }
-};
-CASharpnessFrequencyInterpreter caSharpnessFrequencyInterpreter;
-
-class CAWhiteBalanceInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAWhiteBalanceInterpreter()
-    {
-        choices[0] = "Auto";
-        choices[1] = "Daylight";
-        choices[2] = "Cloudy";
-        choices[3] = "Tungsten";
-        choices[4] = "Fluorescent";
-        choices[5] = "Flash";
-        choices[6] = "Custom";
-        choices[7] = "Black & White";
-        choices[8] = "Shade";
-        choices[9] = "Manual Temperature (Kelvin)";
-        choices[10] = "PC Set1";
-        choices[11] = "PC Set2";
-        choices[12] = "PC Set3";
-        choices[14] = "Daylight Fluorescent";
-        choices[15] = "Custom 1";
-        choices[16] = "Custom 2";
-        choices[17] = "Underwater";
-        choices[18] = "Custom 3";
-        choices[19] = "Custom 4";
-        choices[20] = "PC Set4";
-        choices[21] = "PC Set5";
-        choices[23] = "Auto (ambience priority)";
-    }
-};
-CAWhiteBalanceInterpreter caWhiteBalanceInterpreter;
-
-class CAPictureStyleInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAPictureStyleInterpreter()
-    {
-        choices[0] = "None";
-        choices[1] = "Standard";
-        choices[2] = "Portrait";
-        choices[3] = "High Saturation";
-        choices[4] = "Adobe RGB";
-        choices[5] = "Low Saturation";
-        choices[6] = "CM Set 1";
-        choices[7] = "CM Set 2";
-        choices[0x21] = "User Def. 1";
-        choices[0x22] = "User Def. 2";
-        choices[0x23] = "User Def. 3";
-        choices[0x41] = "PC 1";
-        choices[0x42] = "PC 2";
-        choices[0x43] = "PC 3";
-        choices[0x81] = "Standard";
-        choices[0x82] = "Portrait";
-        choices[0x83] = "Landscape";
-        choices[0x84] = "Neutral";
-        choices[0x85] = "Faithful";
-        choices[0x86] = "Monochrome";
-        choices[0x87] = "Auto";
-        choices[0x88] = "Fine Detail";
-    }
-};
-CAPictureStyleInterpreter caPictureStyleInterpreter;
-
-class CASlowShutterInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CASlowShutterInterpreter()
-    {
-        choices[0] = "Off";
-        choices[1] = "Night Scene";
-        choices[2] = "On";
-        choices[3] = "None";
-    }
-};
-CASlowShutterInterpreter caSlowShutterInterpreter;
-
-class CAFlashGuideNumberInterpreter : public Interpreter
-{
-public:
-    std::string toString (const Tag* t) const override
-    {
-        int n = t->toInt();
-
-        if ( n == -1) {
-            return "undef";
-        }
-
-        char buffer[32];
-        snprintf(buffer, sizeof(buffer), "%.0f", n / 32. );
-        return buffer;
-    }
-};
-CAFlashGuideNumberInterpreter caFlashGuideNumberInterpreter;
-
-class CAAFPointsInFocusInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAAFPointsInFocusInterpreter()
-    {
-        choices[0x3000] = "None (MF)";
-        choices[0x3001] = "Right";
-        choices[0x3002] = "Center";
-        choices[0x3003] = "Center+Right";
-        choices[0x3004] = "Left";
-        choices[0x3005] = "Left+Right";
-        choices[0x3006] = "Left+Center";
-        choices[0x3007] = "All";
-    }
-};
-CAAFPointsInFocusInterpreter caAFPointsInFocusInterpreter;
-
-class CAAutoExposureBracketingInterpreter : public ChoiceInterpreter<int>
-{
-public:
-    CAAutoExposureBracketingInterpreter()
-    {
-        choices[-1] = "On ";
-        choices[0] = "Off ";
-        choices[1] = "On (shot 1)";
-        choices[2] = "On (shot 2)";
-        choices[3] = "On (shot 3)";
-    }
-};
-CAAutoExposureBracketingInterpreter caAutoExposureBracketingInterpreter;
-
-class CAControModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAControModeInterpreter()
-    {
-        choices[0] = "n/a";
-        choices[1] = "Camera Local Control";
-        choices[3] = "Computer Remote Control";
-    }
-};
-CAControModeInterpreter caControModeInterpreter;
-
-class CAFocusDistanceInterpreter : public Interpreter
-{
-public:
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        snprintf(buffer, sizeof(buffer), "%.2f", t->toDouble() / 100 );
-        return buffer;
-    }
-};
-CAFocusDistanceInterpreter caFocusDistanceInterpreter;
-
-class CAMeasuredEVInterpreter : public Interpreter
-{
-public:
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        snprintf(buffer, sizeof(buffer), "%.1f", t->toDouble() / 8 - 6 );
-        return buffer;
-    }
-};
-CAMeasuredEVInterpreter caMeasuredEVInterpreter;
-
-class CACameraTypeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CACameraTypeInterpreter()
-    {
-        choices[248] = "EOS High-end";
-        choices[250] = "Compact";
-        choices[252] = "EOS Mid-range";
-        choices[255] = "DV Camera";
-    }
-};
-CACameraTypeInterpreter caCameraTypeInterpreter;
-
-class CAAutoRotateInterpreter : public ChoiceInterpreter<int>
-{
-public:
-    CAAutoRotateInterpreter()
-    {
-        choices[-1] = "Rotated by Software";
-        choices[0] = "None";
-        choices[1] = "Rotate 90 CW";
-        choices[2] = "Rotate 180";
-        choices[3] = "Rotate 270 CW";
-    }
-};
-CAAutoRotateInterpreter caAutoRotateInterpreter;
-
-class CABracketModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CABracketModeInterpreter()
-    {
-        choices[0] = "Off";
-        choices[1] = "AEB";
-        choices[2] = "FEB";
-        choices[3] = "ISO";
-        choices[4] = "WB";
-    }
-};
-CABracketModeInterpreter caBracketModeInterpreter;
-
-class CARAWJpegQualityInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CARAWJpegQualityInterpreter()
-    {
-        choices[1] = "Economy";
-        choices[2] = "Normal";
-        choices[3] = "Fine";
-        choices[4] = "RAW";
-        choices[5] = "Superfine";
-        choices[130] = "Normal Movie";
-        choices[131] = "Movie (2)";
-    }
-};
-CARAWJpegQualityInterpreter caRAWJpegQualityInterpreter;
-
-class CAJpegSizeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAJpegSizeInterpreter()
-    {
-        choices[0] = "Large";
-        choices[1] = "Medium";
-        choices[2] = "Small";
-        choices[5] = "Medium 1";
-        choices[6] = "Medium 2";
-        choices[7] = "Medium 3";
-        choices[8] = "Postcard";
-        choices[9] = "Widescreen";
-        choices[10] = "Medium Widescreen";
-        choices[14] = "Small 1";
-        choices[15] = "Small 2";
-        choices[16] = "Small 3";
-        choices[128] = "640x480 Movie";
-        choices[129] = "Medium Movie";
-        choices[130] = "Small Movie";
-        choices[137] = "1280x720 Movie";
-        choices[142] = "1920x1080 Movie";
-    }
-};
-CAJpegSizeInterpreter caJpegSizeInterpreter;
-
-class CAWBBracketModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAWBBracketModeInterpreter()
-    {
-        choices[0] = "Off";
-        choices[1] = "On (shift AB)";
-        choices[2] = "On (shift GM)";
-    }
-};
-CAWBBracketModeInterpreter caWBBracketModeInterpreter;
-
-class CAFilterEffectInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAFilterEffectInterpreter()
-    {
-        choices[0] = "None";
-        choices[1] = "Yellow";
-        choices[2] = "Orange";
-        choices[3] = "Red";
-        choices[4] = "Green";
-    }
-};
-CAFilterEffectInterpreter caFilterEffectInterpreter;
-
-class CAToningEffectInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAToningEffectInterpreter()
-    {
-        choices[0] = "None";
-        choices[1] = "Sepia";
-        choices[2] = "Blue";
-        choices[3] = "Purple";
-        choices[4] = "Green";
-    }
-};
-CAToningEffectInterpreter caToningEffectInterpreter;
-
-class CAFileNumberInterpreter : public Interpreter
-{
-public:
-    std::string toString (const Tag* t) const override
-    {
-        unsigned long val = t->toInt (0, LONG);
-        char buffer[32];
-        snprintf(buffer, sizeof(buffer), "%ld", ((val & 0xffc0) >> 6) * 10000 + ((val >> 16) & 0xff) + ((val & 0x3f) << 8) );
-        return buffer;
-    }
-};
-CAFileNumberInterpreter caFileNumberInterpreter;
-
-// CanonModelID
-class CAModelIDInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAModelIDInterpreter ()
-    {
-        choices[1042] = "EOS M50 / Kiss M";
-        choices[2049] = "PowerShot SX740 HS";
-        choices[2052] = "PowerShot G5 X Mark II";
-        choices[2053] = "PowerShot SX70 HS";
-        choices[2056] = "PowerShot G7 X Mark III";
-        choices[2065] = "EOS M6 Mark II";
-        choices[2066] = "EOS M200";
-        choices[16842752] = "PowerShot A30";
-        choices[17039360] = "PowerShot S300 / Digital IXUS 300 / IXY Digital 300";
-        choices[17170432] = "PowerShot A20";
-        choices[17301504] = "PowerShot A10";
-        choices[17367040] = "PowerShot S110 / Digital IXUS v / IXY Digital 200";
-        choices[17825792] = "PowerShot G2";
-        choices[17891328] = "PowerShot S40";
-        choices[17956864] = "PowerShot S30";
-        choices[18022400] = "PowerShot A40";
-        choices[18087936] = "EOS D30";
-        choices[18153472] = "PowerShot A100";
-        choices[18219008] = "PowerShot S200 / Digital IXUS v2 / IXY Digital 200a";
-        choices[18284544] = "PowerShot A200";
-        choices[18350080] = "PowerShot S330 / Digital IXUS 330 / IXY Digital 300a";
-        choices[18415616] = "PowerShot G3";
-        choices[18939904] = "PowerShot S45";
-        choices[19070976] = "PowerShot SD100 / Digital IXUS II / IXY Digital 30";
-        choices[19136512] = "PowerShot S230 / Digital IXUS v3 / IXY Digital 320";
-        choices[19202048] = "PowerShot A70";
-        choices[19267584] = "PowerShot A60";
-        choices[19333120] = "PowerShot S400 / Digital IXUS 400 / IXY Digital 400";
-        choices[19464192] = "PowerShot G5";
-        choices[19922944] = "PowerShot A300";
-        choices[19988480] = "PowerShot S50";
-        choices[20185088] = "PowerShot A80";
-        choices[20250624] = "PowerShot SD10 / Digital IXUS i / IXY Digital L";
-        choices[20316160] = "PowerShot S1 IS";
-        choices[20381696] = "PowerShot Pro1";
-        choices[20447232] = "PowerShot S70";
-        choices[20512768] = "PowerShot S60";
-        choices[20971520] = "PowerShot G6";
-        choices[21037056] = "PowerShot S500 / Digital IXUS 500 / IXY Digital 500";
-        choices[21102592] = "PowerShot A75";
-        choices[21233664] = "PowerShot SD110 / Digital IXUS IIs / IXY Digital 30a";
-        choices[21299200] = "PowerShot A400";
-        choices[21430272] = "PowerShot A310";
-        choices[21561344] = "PowerShot A85";
-        choices[22151168] = "PowerShot S410 / Digital IXUS 430 / IXY Digital 450";
-        choices[22216704] = "PowerShot A95";
-        choices[22282240] = "PowerShot SD300 / Digital IXUS 40 / IXY Digital 50";
-        choices[22347776] = "PowerShot SD200 / Digital IXUS 30 / IXY Digital 40";
-        choices[22413312] = "PowerShot A520";
-        choices[22478848] = "PowerShot A510";
-        choices[22609920] = "PowerShot SD20 / Digital IXUS i5 / IXY Digital L2";
-        choices[23330816] = "PowerShot S2 IS";
-        choices[23396352] = "PowerShot SD430 / Digital IXUS Wireless / IXY Digital Wireless";
-        choices[23461888] = "PowerShot SD500 / Digital IXUS 700 / IXY Digital 600";
-        choices[23494656] = "EOS D60";
-        choices[24117248] = "PowerShot SD30 / Digital IXUS i Zoom / IXY Digital L3";
-        choices[24379392] = "PowerShot A430";
-        choices[24444928] = "PowerShot A410";
-        choices[24510464] = "PowerShot S80";
-        choices[24641536] = "PowerShot A620";
-        choices[24707072] = "PowerShot A610";
-        choices[25165824] = "PowerShot SD630 / Digital IXUS 65 / IXY Digital 80";
-        choices[25231360] = "PowerShot SD450 / Digital IXUS 55 / IXY Digital 60";
-        choices[25296896] = "PowerShot TX1";
-        choices[25624576] = "PowerShot SD400 / Digital IXUS 50 / IXY Digital 55";
-        choices[25690112] = "PowerShot A420";
-        choices[25755648] = "PowerShot SD900 / Digital IXUS 900 Ti / IXY Digital 1000";
-        choices[26214400] = "PowerShot SD550 / Digital IXUS 750 / IXY Digital 700";
-        choices[26345472] = "PowerShot A700";
-        choices[26476544] = "PowerShot SD700 IS / Digital IXUS 800 IS / IXY Digital 800 IS";
-        choices[26542080] = "PowerShot S3 IS";
-        choices[26607616] = "PowerShot A540";
-        choices[26673152] = "PowerShot SD600 / Digital IXUS 60 / IXY Digital 70";
-        choices[26738688] = "PowerShot G7";
-        choices[26804224] = "PowerShot A530";
-        choices[33554432] = "PowerShot SD800 IS / Digital IXUS 850 IS / IXY Digital 900 IS";
-        choices[33619968] = "PowerShot SD40 / Digital IXUS i7 / IXY Digital L4";
-        choices[33685504] = "PowerShot A710 IS";
-        choices[33751040] = "PowerShot A640";
-        choices[33816576] = "PowerShot A630";
-        choices[34144256] = "PowerShot S5 IS";
-        choices[34603008] = "PowerShot A460";
-        choices[34734080] = "PowerShot SD850 IS / Digital IXUS 950 IS / IXY Digital 810 IS";
-        choices[34799616] = "PowerShot A570 IS";
-        choices[34865152] = "PowerShot A560";
-        choices[34930688] = "PowerShot SD750 / Digital IXUS 75 / IXY Digital 90";
-        choices[34996224] = "PowerShot SD1000 / Digital IXUS 70 / IXY Digital 10";
-        choices[35127296] = "PowerShot A550";
-        choices[35192832] = "PowerShot A450";
-        choices[35848192] = "PowerShot G9";
-        choices[35913728] = "PowerShot A650 IS";
-        choices[36044800] = "PowerShot A720 IS";
-        choices[36241408] = "PowerShot SX100 IS";
-        choices[36700160] = "PowerShot SD950 IS / Digital IXUS 960 IS / IXY Digital 2000 IS";
-        choices[36765696] = "PowerShot SD870 IS / Digital IXUS 860 IS / IXY Digital 910 IS";
-        choices[36831232] = "PowerShot SD890 IS / Digital IXUS 970 IS / IXY Digital 820 IS";
-        choices[37093376] = "PowerShot SD790 IS / Digital IXUS 90 IS / IXY Digital 95 IS";
-        choices[37158912] = "PowerShot SD770 IS / Digital IXUS 85 IS / IXY Digital 25 IS";
-        choices[37224448] = "PowerShot A590 IS";
-        choices[37289984] = "PowerShot A580";
-        choices[37879808] = "PowerShot A470";
-        choices[37945344] = "PowerShot SD1100 IS / Digital IXUS 80 IS / IXY Digital 20 IS";
-        choices[38141952] = "PowerShot SX1 IS";
-        choices[38207488] = "PowerShot SX10 IS";
-        choices[38273024] = "PowerShot A1000 IS";
-        choices[38338560] = "PowerShot G10";
-        choices[38862848] = "PowerShot A2000 IS";
-        choices[38928384] = "PowerShot SX110 IS";
-        choices[38993920] = "PowerShot SD990 IS / Digital IXUS 980 IS / IXY Digital 3000 IS";
-        choices[39059456] = "PowerShot SD880 IS / Digital IXUS 870 IS / IXY Digital 920 IS";
-        choices[39124992] = "PowerShot E1";
-        choices[39190528] = "PowerShot D10";
-        choices[39256064] = "PowerShot SD960 IS / Digital IXUS 110 IS / IXY Digital 510 IS";
-        choices[39321600] = "PowerShot A2100 IS";
-        choices[39387136] = "PowerShot A480";
-        choices[39845888] = "PowerShot SX200 IS";
-        choices[39911424] = "PowerShot SD970 IS / Digital IXUS 990 IS / IXY Digital 830 IS";
-        choices[39976960] = "PowerShot SD780 IS / Digital IXUS 100 IS / IXY Digital 210 IS";
-        choices[40042496] = "PowerShot A1100 IS";
-        choices[40108032] = "PowerShot SD1200 IS / Digital IXUS 95 IS / IXY Digital 110 IS";
-        choices[40894464] = "PowerShot G11";
-        choices[40960000] = "PowerShot SX120 IS";
-        choices[41025536] = "PowerShot S90";
-        choices[41222144] = "PowerShot SX20 IS";
-        choices[41287680] = "PowerShot SD980 IS / Digital IXUS 200 IS / IXY Digital 930 IS";
-        choices[41353216] = "PowerShot SD940 IS / Digital IXUS 120 IS / IXY Digital 220 IS";
-        choices[41943040] = "PowerShot A495";
-        choices[42008576] = "PowerShot A490";
-        choices[42074112] = "PowerShot A3100/A3150 IS";
-        choices[42139648] = "PowerShot A3000 IS";
-        choices[42205184] = "PowerShot SD1400 IS / IXUS 130 / IXY 400F";
-        choices[42270720] = "PowerShot SD1300 IS / IXUS 105 / IXY 200F";
-        choices[42336256] = "PowerShot SD3500 IS / IXUS 210 / IXY 10S";
-        choices[42401792] = "PowerShot SX210 IS";
-        choices[42467328] = "PowerShot SD4000 IS / IXUS 300 HS / IXY 30S";
-        choices[42532864] = "PowerShot SD4500 IS / IXUS 1000 HS / IXY 50S";
-        choices[43122688] = "PowerShot G12";
-        choices[43188224] = "PowerShot SX30 IS";
-        choices[43253760] = "PowerShot SX130 IS";
-        choices[43319296] = "PowerShot S95";
-        choices[43515904] = "PowerShot A3300 IS";
-        choices[43581440] = "PowerShot A3200 IS";
-        choices[50331648] = "PowerShot ELPH 500 HS / IXUS 310 HS / IXY 31S";
-        choices[50397184] = "PowerShot Pro90 IS";
-        choices[50397185] = "PowerShot A800";
-        choices[50462720] = "PowerShot ELPH 100 HS / IXUS 115 HS / IXY 210F";
-        choices[50528256] = "PowerShot SX230 HS";
-        choices[50593792] = "PowerShot ELPH 300 HS / IXUS 220 HS / IXY 410F";
-        choices[50659328] = "PowerShot A2200";
-        choices[50724864] = "PowerShot A1200";
-        choices[50790400] = "PowerShot SX220 HS";
-        choices[50855936] = "PowerShot G1 X";
-        choices[50921472] = "PowerShot SX150 IS";
-        choices[51380224] = "PowerShot ELPH 510 HS / IXUS 1100 HS / IXY 51S";
-        choices[51445760] = "PowerShot S100 (new)";
-        choices[51511296] = "PowerShot ELPH 310 HS / IXUS 230 HS / IXY 600F";
-        choices[51576832] = "PowerShot SX40 HS";
-        choices[51642368] = "IXY 32S";
-        choices[51773440] = "PowerShot A1300";
-        choices[51838976] = "PowerShot A810";
-        choices[51904512] = "PowerShot ELPH 320 HS / IXUS 240 HS / IXY 420F";
-        choices[51970048] = "PowerShot ELPH 110 HS / IXUS 125 HS / IXY 220F";
-        choices[52428800] = "PowerShot D20";
-        choices[52494336] = "PowerShot A4000 IS";
-        choices[52559872] = "PowerShot SX260 HS";
-        choices[52625408] = "PowerShot SX240 HS";
-        choices[52690944] = "PowerShot ELPH 530 HS / IXUS 510 HS / IXY 1";
-        choices[52756480] = "PowerShot ELPH 520 HS / IXUS 500 HS / IXY 3";
-        choices[52822016] = "PowerShot A3400 IS";
-        choices[52887552] = "PowerShot A2400 IS";
-        choices[52953088] = "PowerShot A2300";
-        choices[53608448] = "PowerShot S100V";
-        choices[53673984] = "PowerShot G15";
-        choices[53739520] = "PowerShot SX50 HS";
-        choices[53805056] = "PowerShot SX160 IS";
-        choices[53870592] = "PowerShot S110 (new)";
-        choices[53936128] = "PowerShot SX500 IS";
-        choices[54001664] = "PowerShot N";
-        choices[54067200] = "IXUS 245 HS / IXY 430F";
-        choices[54525952] = "PowerShot SX280 HS";
-        choices[54591488] = "PowerShot SX270 HS";
-        choices[54657024] = "PowerShot A3500 IS";
-        choices[54722560] = "PowerShot A2600";
-        choices[54788096] = "PowerShot SX275 HS";
-        choices[54853632] = "PowerShot A1400";
-        choices[54919168] = "PowerShot ELPH 130 IS / IXUS 140 / IXY 110F";
-        choices[54984704] = "PowerShot ELPH 115/120 IS / IXUS 132/135 / IXY 90F/100F";
-        choices[55115776] = "PowerShot ELPH 330 HS / IXUS 255 HS / IXY 610F";
-        choices[55640064] = "PowerShot A2500";
-        choices[55836672] = "PowerShot G16";
-        choices[55902208] = "PowerShot S120";
-        choices[55967744] = "PowerShot SX170 IS";
-        choices[56098816] = "PowerShot SX510 HS";
-        choices[56164352] = "PowerShot S200 (new)";
-        choices[56623104] = "IXY 620F";
-        choices[56688640] = "PowerShot N100";
-        choices[56885248] = "PowerShot G1 X Mark II";
-        choices[56950784] = "PowerShot D30";
-        choices[57016320] = "PowerShot SX700 HS";
-        choices[57081856] = "PowerShot SX600 HS";
-        choices[57147392] = "PowerShot ELPH 140 IS / IXUS 150 / IXY 130";
-        choices[57212928] = "PowerShot ELPH 135 / IXUS 145 / IXY 120";
-        choices[57671680] = "PowerShot ELPH 340 HS / IXUS 265 HS / IXY 630";
-        choices[57737216] = "PowerShot ELPH 150 IS / IXUS 155 / IXY 140";
-        choices[57933824] = "EOS M3";
-        choices[57999360] = "PowerShot SX60 HS";
-        choices[58064896] = "PowerShot SX520 HS";
-        choices[58130432] = "PowerShot SX400 IS";
-        choices[58195968] = "PowerShot G7 X";
-        choices[58261504] = "PowerShot N2";
-        choices[58720256] = "PowerShot SX530 HS";
-        choices[58851328] = "PowerShot SX710 HS";
-        choices[58916864] = "PowerShot SX610 HS";
-        choices[58982400] = "EOS M10";
-        choices[59047936] = "PowerShot G3 X";
-        choices[59113472] = "PowerShot ELPH 165 HS / IXUS 165 / IXY 160";
-        choices[59179008] = "PowerShot ELPH 160 / IXUS 160";
-        choices[59244544] = "PowerShot ELPH 350 HS / IXUS 275 HS / IXY 640";
-        choices[59310080] = "PowerShot ELPH 170 IS / IXUS 170";
-        choices[59834368] = "PowerShot SX410 IS";
-        choices[59965440] = "PowerShot G9 X";
-        choices[60030976] = "EOS M5";
-        choices[60096512] = "PowerShot G5 X";
-        choices[60227584] = "PowerShot G7 X Mark II";
-        choices[60293120] = "EOS M100";
-        choices[60358656] = "PowerShot ELPH 360 HS / IXUS 285 HS / IXY 650";
-        choices[67174400] = "PowerShot SX540 HS";
-        choices[67239936] = "PowerShot SX420 IS";
-        choices[67305472] = "PowerShot ELPH 190 IS / IXUS 180 / IXY 190";
-        choices[67371008] = "PowerShot G1";
-        choices[67371009] = "PowerShot ELPH 180 IS / IXUS 175 / IXY 180";
-        choices[67436544] = "PowerShot SX720 HS";
-        choices[67502080] = "PowerShot SX620 HS";
-        choices[67567616] = "EOS M6";
-        choices[68157440] = "PowerShot G9 X Mark II";
-        choices[68485120] = "PowerShot ELPH 185 / IXUS 185 / IXY 200";
-        choices[68550656] = "PowerShot SX430 IS";
-        choices[68616192] = "PowerShot SX730 HS";
-        choices[68681728] = "PowerShot G1 X Mark III";
-        choices[100925440] = "PowerShot S100 / Digital IXUS / IXY Digital";
-        choices[1074255475] = "DC19/DC21/DC22";
-        choices[1074255476] = "XH A1";
-        choices[1074255477] = "HV10";
-        choices[1074255478] = "MD130/MD140/MD150/MD160/ZR850";
-        choices[1074255735] = "DC50";
-        choices[1074255736] = "HV20";
-        choices[1074255737] = "DC211";
-        choices[1074255738] = "HG10";
-        choices[1074255739] = "HR10";
-        choices[1074255741] = "MD255/ZR950";
-        choices[1074255900] = "HF11";
-        choices[1074255992] = "HV30";
-        choices[1074255996] = "XH A1S";
-        choices[1074255998] = "DC301/DC310/DC311/DC320/DC330";
-        choices[1074255999] = "FS100";
-        choices[1074256000] = "HF10";
-        choices[1074256002] = "HG20/HG21";
-        choices[1074256165] = "HF21";
-        choices[1074256166] = "HF S11";
-        choices[1074256248] = "HV40";
-        choices[1074256263] = "DC410/DC411/DC420";
-        choices[1074256264] = "FS19/FS20/FS21/FS22/FS200";
-        choices[1074256265] = "HF20/HF200";
-        choices[1074256266] = "HF S10/S100";
-        choices[1074256526] = "HF R10/R16/R17/R18/R100/R106";
-        choices[1074256527] = "HF M30/M31/M36/M300/M306";
-        choices[1074256528] = "HF S20/S21/S200";
-        choices[1074256530] = "FS31/FS36/FS37/FS300/FS305/FS306/FS307";
-        choices[1074257056] = "EOS C300";
-        choices[1074257321] = "HF G25";
-        choices[1074257844] = "XC10";
-        choices[1074258371] = "EOS C200";
-        choices[2147483649] = "EOS-1D";
-        choices[2147484007] = "EOS-1DS";
-        choices[2147484008] = "EOS 10D";
-        choices[2147484009] = "EOS-1D Mark III";
-        choices[2147484016] = "EOS Digital Rebel / 300D / Kiss Digital";
-        choices[2147484020] = "EOS-1D Mark II";
-        choices[2147484021] = "EOS 20D";
-        choices[2147484022] = "EOS Digital Rebel XSi / 450D / Kiss X2";
-        choices[2147484040] = "EOS-1Ds Mark II";
-        choices[2147484041] = "EOS Digital Rebel XT / 350D / Kiss Digital N";
-        choices[2147484048] = "EOS 40D";
-        choices[2147484179] = "EOS 5D";
-        choices[2147484181] = "EOS-1Ds Mark III";
-        choices[2147484184] = "EOS 5D Mark II";
-        choices[2147484185] = "WFT-E1";
-        choices[2147484210] = "EOS-1D Mark II N";
-        choices[2147484212] = "EOS 30D";
-        choices[2147484214] = "EOS Digital Rebel XTi / 400D / Kiss Digital X";
-        choices[2147484225] = "WFT-E2";
-        choices[2147484230] = "WFT-E3";
-        choices[2147484240] = "EOS 7D";
-        choices[2147484242] = "EOS Rebel T1i / 500D / Kiss X3";
-        choices[2147484244] = "EOS Rebel XS / 1000D / Kiss F";
-        choices[2147484257] = "EOS 50D";
-        choices[2147484265] = "EOS-1D X";
-        choices[2147484272] = "EOS Rebel T2i / 550D / Kiss X4";
-        choices[2147484273] = "WFT-E4";
-        choices[2147484275] = "WFT-E5";
-        choices[2147484289] = "EOS-1D Mark IV";
-        choices[2147484293] = "EOS 5D Mark III";
-        choices[2147484294] = "EOS Rebel T3i / 600D / Kiss X5";
-        choices[2147484295] = "EOS 60D";
-        choices[2147484296] = "EOS Rebel T3 / 1100D / Kiss X50";
-        choices[2147484297] = "EOS 7D Mark II";
-        choices[2147484311] = "WFT-E2 II";
-        choices[2147484312] = "WFT-E4 II";
-        choices[2147484417] = "EOS Rebel T4i / 650D / Kiss X6i";
-        choices[2147484418] = "EOS 6D";
-        choices[2147484452] = "EOS-1D C";
-        choices[2147484453] = "EOS 70D";
-        choices[2147484454] = "EOS Rebel T5i / 700D / Kiss X7i";
-        choices[2147484455] = "EOS Rebel T5 / 1200D / Kiss X70 / Hi";
-        choices[2147484456] = "EOS-1D X Mark II";
-        choices[2147484465] = "EOS M";
-        choices[2147484486] = "EOS Rebel SL1 / 100D / Kiss X7";
-        choices[2147484487] = "EOS Rebel T6s / 760D / 8000D";
-        choices[2147484489] = "EOS 5D Mark IV";
-        choices[2147484496] = "EOS 80D";
-        choices[2147484501] = "EOS M2";
-        choices[2147484546] = "EOS 5DS";
-        choices[2147484563] = "EOS Rebel T6i / 750D / Kiss X8i";
-        choices[2147484673] = "EOS 5DS R";
-        choices[2147484676] = "EOS Rebel T6 / 1300D / Kiss X80";
-        choices[2147484677] = "EOS Rebel T7i / 800D / Kiss X9i";
-        choices[2147484678] = "EOS 6D Mark II";
-        choices[2147484680] = "EOS 77D / 9000D";
-        choices[2147484695] = "EOS Rebel SL2 / 200D / Kiss X9";
-        choices[2147484705] = "EOS R5";
-        choices[2147484706] = "EOS Rebel T100 / 4000D / 3000D";
-        choices[2147484708] = "EOS R";
-        choices[2147484712] = "EOS-1D X Mark III";
-        choices[2147484722] = "EOS Rebel T7 / 2000D / 1500D / Kiss X90";
-        choices[2147484723] = "EOS RP";
-        choices[2147484725] = "EOS Rebel T8i / 850D / X10i";
-        choices[2147484726] = "EOS SL3 / 250D / Kiss X10";
-        choices[2147484727] = "EOS 90D";
-        choices[2147484752] = "EOS R3";
-        choices[2147484755] = "EOS R6";
-        choices[2147484772] = "EOS R7";
-        choices[2147484773] = "EOS R10";
-        choices[2147484775] = "PowerShot ZOOM";
-        choices[2147484776] = "EOS M50 Mark II / Kiss M2";
-        choices[2147484960] = "EOS D2000C";
-        choices[2147485024] = "EOS D6000C";
-    }
-};
-CAModelIDInterpreter caModelIDInterpreter;
-
-class CAPanoramaDirectionInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAPanoramaDirectionInterpreter()
-    {
-        choices[0] = "Left to Right";
-        choices[1] = "Right to Left";
-        choices[2] = "Bottom to Top";
-        choices[3] = "Top to Bottom";
-        choices[4] = "2x2 Matrix (Clockwise)";
-    }
-};
-CAPanoramaDirectionInterpreter caPanoramaDirectionInterpreter;
-
-class CAAspectRatioInterpreter : public ChoiceInterpreter<>
-{
-public:
-    CAAspectRatioInterpreter()
-    {
-        choices[0] = "3:2";
-        choices[1] = "1:1";
-        choices[2] = "4:3";
-        choices[7] = "16:9";
-        choices[8] = "4:5";
-    }
-
-};
-CAAspectRatioInterpreter caAspectRatioInterpreter;
-
-const TagAttrib canonCameraSettingsAttribs[] = {
-    {0, AC_WRITE, 0, nullptr,  1, AUTO, "MacroMode", &caMacroModeInterpreter},
-    {0, AC_WRITE, 0, nullptr,  2, AUTO, "SelfTimer", &caSelfTimerInterpreter},
-    {0, AC_WRITE, 0, nullptr,  3, AUTO, "Quality", &caQualityInterpreter},
-    {0, AC_WRITE, 0, nullptr,  4, AUTO, "CanonFlashMode", &caFlashModeInterpreter},
-    {0, AC_WRITE, 0, nullptr,  5, AUTO, "ContinuousDrive", &caContinuousDriveInterpreter},
-    {0, AC_WRITE, 0, nullptr,  7, AUTO, "FocusMode", &caFocusModeInterpreter},
-    {0, AC_WRITE, 0, nullptr,  9, AUTO, "RecordMode", &caRecordModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 10, AUTO, "CanonImageSize", &caImageSizeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 11, AUTO, "EasyMode", &caEasyModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 12, AUTO, "DigitalZoom", &caDigitalZoomInterpreter},
-    {0, AC_WRITE, 0, nullptr, 13, AUTO, "Contrast", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 14, AUTO, "Saturation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 15, AUTO, "Sharpness", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 16, AUTO, "CameraISO", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 17, AUTO, "MeteringMode", &caMeteringModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 18, AUTO, "FocusRange", &caFocusRangeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 19, AUTO, "AFPoint", &caAFPointInterpreter},
-    {0, AC_WRITE, 0, nullptr, 20, AUTO, "CanonExposureMode", &caExposureModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 22, AUTO, "LensID", &caLensInterpreter},
-    {0, AC_WRITE, 0, nullptr, 23, AUTO, "LongFocal", &caFocalInterpreter},
-    {0, AC_WRITE, 0, nullptr, 24, AUTO, "ShortFocal", &caFocalInterpreter},
-    {0, AC_WRITE, 0, nullptr, 25, AUTO, "FocalUnits", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 26, AUTO, "MaxAperture", &caApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 27, AUTO, "MinAperture", &caApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 28, AUTO, "FlashActivity", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 29, AUTO, "FlashBits", &caFlashBitsInterpreter},
-    {0, AC_WRITE, 0, nullptr, 32, AUTO, "FocusContinuous", &caFocusContinuousInterpreter},
-    {0, AC_WRITE, 0, nullptr, 33, AUTO, "AESetting", &caAESettingsInterpreter},
-    {0, AC_WRITE, 0, nullptr, 34, AUTO, "ImageStabilization", &caStabilizationInterpreter},
-    {0, AC_WRITE, 0, nullptr, 35, AUTO, "DisplayAperture", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 36, AUTO, "ZoomSourceWidth", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 37, AUTO, "ZoomTargetWidth", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 39, AUTO, "SpotMeteringMode", &caSpotMeteringInterpreter},
-    {0, AC_WRITE, 0, nullptr, 40, AUTO, "PhotoEffect", &caPhotoEffectInterpreter},
-    {0, AC_WRITE, 0, nullptr, 41, AUTO, "ManualFlashOutput", &caManualFlashInterpreter},
-    {0, AC_WRITE, 0, nullptr, 42, AUTO, "ColorTone", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 46, AUTO, "SRAWQuality", &caRAWQualityInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib canonFocalLengthAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0, AUTO, "FocalType", &caFocalTypeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 1, AUTO, "FocalLength", &caFocalInterpreter},
-    {0, AC_WRITE, 0, nullptr, 2, AUTO, "FocalPlaneXSize", &caFocalPlaneInterpreter},
-    {0, AC_WRITE, 0, nullptr, 3, AUTO, "FocalPlaneYSize", &caFocalPlaneInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib canonShotInfoAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 1, AUTO, "AutoISO", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 2, AUTO, "BaseISO", &caBaseISOInterpreter},
-    {0, AC_WRITE, 0, nullptr, 3, AUTO, "MeasuredEV", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 4, AUTO, "TargetAperture", &caApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 5, AUTO, "TargetExposureTime", &caExposureTimeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 6, AUTO, "ExposureCompensation", &caEVInterpreter},
-    {0, AC_WRITE, 0, nullptr, 7, AUTO, "WhiteBalance", &caWhiteBalanceInterpreter},
-    {0, AC_WRITE, 0, nullptr, 8, AUTO, "SlowShutter", &caSlowShutterInterpreter},
-    {0, AC_WRITE, 0, nullptr, 9, AUTO, "SequenceNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 10, AUTO, "OpticalZoomCode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 13, AUTO, "FlashGuideNumber", &caFlashGuideNumberInterpreter},
-    {0, AC_WRITE, 0, nullptr, 14, AUTO, "AFPointsInFocus", &caAFPointsInFocusInterpreter},
-    {0, AC_WRITE, 0, nullptr, 15, AUTO, "FlashExposureComp", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 16, AUTO, "AutoExposureBracketing", &caAutoExposureBracketingInterpreter},
-    {0, AC_WRITE, 0, nullptr, 17, AUTO, "AEBBracketValue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 18, AUTO, "ControlMode", &caControModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 21, AUTO, "FNumber", &caApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 22, AUTO, "ExposureTime", &caExposureTimeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 23, AUTO, "MeasuredEV2", &caMeasuredEVInterpreter},
-    {0, AC_WRITE, 0, nullptr, 24, AUTO, "BulbDuration", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 26, AUTO, "CameraType", &caCameraTypeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 27, AUTO, "AutoRotate", &caAutoRotateInterpreter},
-    {0, AC_WRITE, 0, nullptr, 28, AUTO, "NDFilter", &caOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 29, AUTO, "Self-timer2", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 33, AUTO, "FlashOutput", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0, nullptr, 0, AUTO, "", nullptr},
-};
-
-const TagAttrib canonFileInfoAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 1, AUTO, "FileNumber",  &caFileNumberInterpreter},
-    {0, AC_WRITE, 0, nullptr, 3, AUTO, "BracketMode", &caBracketModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 4, AUTO, "BracketValue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 5, AUTO, "BracketShotNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 6, AUTO, "RawJpgQuality", &caRAWJpegQualityInterpreter},
-    {0, AC_WRITE, 0, nullptr, 7, AUTO, "RawJpgSize", &caJpegSizeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 8, AUTO, "NoiseReduction", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 9, AUTO, "WBBracketMode", &caWBBracketModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 12, AUTO, "WBBracketValueAB", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 13, AUTO, "WBBracketValueGM", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 14, AUTO, "FilterEffect", &caFilterEffectInterpreter},
-    {0, AC_WRITE, 0, nullptr, 15, AUTO, "ToningEffect", &caToningEffectInterpreter},
-    {0, AC_WRITE, 0, nullptr, 19, AUTO, "LiveViewShooting", &caOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 20, AUTO, "FocusDistanceUpper", &caFocusDistanceInterpreter},
-    {0, AC_WRITE, 0, nullptr, 21, AUTO, "FocusDistanceLower", &caFocusDistanceInterpreter},
-    {0, AC_WRITE, 0, nullptr, 25, AUTO, "FlashExposureLock", &caOnOffInterpreter},
-    { -1, AC_DONTWRITE, 0, nullptr, 0, AUTO, "", nullptr},
-};
-
-const TagAttrib canonProcessingInfoAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 1, AUTO, "ToneCurve", &caToneCurveInterpreter},
-    {0, AC_WRITE, 0, nullptr, 2, AUTO, "Sharpness", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 3, AUTO, "SharpnessFrequency", &caSharpnessFrequencyInterpreter},
-    {0, AC_WRITE, 0, nullptr, 4, AUTO, "SensorRedLevel", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 5, AUTO, "SensorBlueLevel", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 6, AUTO, "WhiteBalanceRed", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 7, AUTO, "WhiteBalanceBlue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 8, AUTO, "WhiteBalance", &caWhiteBalanceInterpreter},
-    {0, AC_WRITE, 0, nullptr, 9, AUTO, "ColorTemperature", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 10, AUTO, "PictureStyle", &caPictureStyleInterpreter},
-    {0, AC_WRITE, 0, nullptr, 11, AUTO, "DigitalGain", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 12, AUTO, "WBShiftAB", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 13, AUTO, "WBShiftGM", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0, nullptr, 0, AUTO, "", nullptr},
-};
-
-const TagAttrib canonPanoramaInfoAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 2, AUTO, "PanoramaFrameNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 5, AUTO, "PanoramaDirection", &caPanoramaDirectionInterpreter},
-    { -1, AC_DONTWRITE, 0, nullptr, 0, AUTO, "", nullptr},
-};
-
-const TagAttrib canonCropInfoAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0, AUTO, "CropLeftMargin", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 1, AUTO, "CropRightMargin", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 2, AUTO, "CropTopMargin", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 3, AUTO, "CropBottomMargin", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0, nullptr, 0, AUTO, "", nullptr},
-};
-
-const TagAttrib canonAspectInfoAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0, AUTO, "AspectRatio", &caAspectRatioInterpreter},
-    {0, AC_WRITE, 0, nullptr, 1, AUTO, "CroppedImageWidth", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 2, AUTO, "CroppedImageHeight", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0, nullptr, 0, AUTO, "", nullptr},
-};
-
-const TagAttrib canonMicroAdjustAttrib[] = {
-    {0, AC_WRITE, 0, nullptr, 1, AUTO, "AFMicroAdjActive", &caOnOffInterpreter},
-    { -1, AC_DONTWRITE, 0, nullptr, 2, AUTO, "", nullptr},
-};
-
-const TagAttrib canonAttribs[] = {
-    {0, AC_WRITE, 0, canonCameraSettingsAttribs, 0x0001, AUTO, "CanonCameraSettings", &stdInterpreter},
-    {0, AC_WRITE, 0, canonFocalLengthAttribs, 0x0002, AUTO, "CanonFocalLength", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0003, AUTO, "CanonFlashInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, canonShotInfoAttribs, 0x0004, AUTO, "CanonShotInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, canonPanoramaInfoAttribs, 0x0005, AUTO, "CanonPanorama", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0006, AUTO, "CanonImageType", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0007, AUTO, "CanonFirmwareVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0008, AUTO, "FileNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0009, AUTO, "OwnerName", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000a, AUTO, "ColorInfoD30", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000c, AUTO, "SerialNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000d, AUTO, "CanonCameraInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000e, AUTO, "CanonFileLength", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000f, AUTO, "CustomFunctions", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0010, AUTO, "CanonModelID", &caModelIDInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0012, AUTO, "CanonAFInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0015, AUTO, "SerialNumberFormat", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x001c, AUTO, "DateStampMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x001d, AUTO, "MyColors", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x001e, AUTO, "FirmwareRevision", &stdInterpreter},
-    {0, AC_NEW,   0, nullptr, 0x0024, AUTO, "FaceDetect1", &stdInterpreter},
-    {0, AC_NEW,   0, nullptr, 0x0025, AUTO, "FaceDetect2", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0026, AUTO, "CanonAFInfo2", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0083, AUTO, "OriginalDecisionData", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0090, AUTO, "CustomFunctions1D", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0091, AUTO, "PersonalFunctions", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0092, AUTO, "PersonalFunctionValues", &stdInterpreter},
-    {0, AC_WRITE, 0, canonFileInfoAttribs, 0x0093, AUTO, "CanonFileInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0094, AUTO, "AFPointsInFocus1D", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0095, AUTO, "LensType", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0096, AUTO, "InternalSerialNumber", &caIntSerNumInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0097, AUTO, "DustRemovalData", &stdInterpreter},
-    {0, AC_WRITE, 0, canonCropInfoAttribs, 0x0098, AUTO, "CropInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0099, AUTO, "CustomFunctions2", &stdInterpreter},
-    {0, AC_WRITE, 0, canonAspectInfoAttribs, 0x009a, AUTO, "AspectInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, canonProcessingInfoAttribs, 0x00a0, AUTO, "ProcessingInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00a1, AUTO, "ToneCurveTable", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00a2, AUTO, "SharpnessTable", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00a3, AUTO, "SharpnessFreqTable", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00a4, AUTO, "WhiteBalanceTable", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00a9, AUTO, "ColorBalance", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00aa, AUTO, "MeasuredColor", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00ae, AUTO, "ColorTemperature", &stdInterpreter},
-    {0, AC_NEW, 0, nullptr, 0x00b0, AUTO, "CanonFlags", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00b1, AUTO, "ModifiedInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00b2, AUTO, "ToneCurveMatching", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00b3, AUTO, "WhiteBalanceMatching", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00b4, AUTO, "ColorSpace", &stdInterpreter},
-    {1, AC_WRITE, 0, nullptr, 0x00b6, AUTO, "PreviewImageInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00d0, AUTO, "VRDOffset", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00e0, AUTO, "SensorInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x4001, AUTO, "ColorBalance", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x4002, AUTO, "UnknownBlock1", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x4003, AUTO, "ColorInfo", &stdInterpreter},
-    {1, AC_WRITE, 0, nullptr, 0x4005, AUTO, "UnknownBlock2", &stdInterpreter},
-    {1, AC_WRITE, 0, nullptr, 0x4008, AUTO, "BlackLevel", &stdInterpreter},
-    {1, AC_WRITE, 0, canonMicroAdjustAttrib, 0x4013, AUTO, "AFMicroAdj", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-}
-
diff --git a/rtexif/fujiattribs.cc b/rtexif/fujiattribs.cc
deleted file mode 100644
index ffbf3a0be..000000000
--- a/rtexif/fujiattribs.cc
+++ /dev/null
@@ -1,313 +0,0 @@
-/*
- *  This file is part of RawTherapee.
- *
- *  Copyright (c) 2004-2010 Gabor Horvath <hgabor@rawtherapee.com>
- *
- *  RawTherapee is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  RawTherapee is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-#include "rtexif.h"
-
-namespace rtexif
-{
-
-class FAOnOffInterpreter : public ChoiceInterpreter<>
-{
-public:
-    FAOnOffInterpreter ()
-    {
-        choices[0]      = "Off";
-        choices[1]      = "On";
-    }
-};
-FAOnOffInterpreter faOnOffInterpreter;
-
-class FASharpnessInterpreter : public ChoiceInterpreter<>
-{
-public:
-    FASharpnessInterpreter ()
-    {
-        choices[1]      = "Soft";
-        choices[2]      = "Soft2";
-        choices[3]      = "Normal";
-        choices[4]      = "Hard";
-        choices[5]      = "Hard2";
-        choices[0x82]   = "Medium Soft";
-        choices[0x84]   = "Medium Hard";
-        choices[0x8000] = "Film Simulation";
-        choices[0xffff] = "n/a";
-    }
-};
-FASharpnessInterpreter faSharpnessInterpreter;
-
-class FAWhiteBalanceInterpreter : public ChoiceInterpreter<>
-{
-public:
-    FAWhiteBalanceInterpreter ()
-    {
-        choices[0]      = "Auto";
-        choices[0x100]  = "Daylight";
-        choices[0x200]  = "Cloudy";
-        choices[0x300]  = "Daylight Fluorescent";
-        choices[0x301]  = "Day White Fluorescent";
-        choices[0x302]  = "White Fluorescent";
-        choices[0x303]  = "Warm White Fluorescent";
-        choices[0x304]  = "Living Room Warm White Fluorescent";
-        choices[0x400]  = "Incandescent";
-        choices[0x500]  = "Flash";
-        choices[0x600]  = "Underwater";
-        choices[0xf00]  = "Custom";
-        choices[0xf01]  = "Custom2";
-        choices[0xf02]  = "Custom3";
-        choices[0xf03]  = "Custom4";
-        choices[0xf04]  = "Custom5";
-        choices[0xff0]  = "Kelvin";
-    }
-};
-FAWhiteBalanceInterpreter faWhiteBalanceInterpreter;
-
-class FASaturationInterpreter : public ChoiceInterpreter<>
-{
-public:
-    FASaturationInterpreter ()
-    {
-        choices[0] = "Normal";
-        choices[128] = "Medium High";
-        choices[256] = "High";
-        choices[384] = "Medium Low";
-        choices[512] = "Low";
-        choices[768] = "None (B&W)";
-        choices[769] = "B&W Red Filter";
-        choices[770] = "B&W Yellow Filter";
-        choices[771] = "B&W Green Filter";
-        choices[784] = "B&W Sepia";
-        choices[1024] = "Low 2";
-        choices[1280] = "Acros";
-        choices[1281] = "Acros Red Filter";
-        choices[1282] = "Acros Yellow Filter";
-        choices[1283] = "Acros Green Filter";
-        choices[32768] = "Film Simulation";
-    }
-};
-FASaturationInterpreter faSaturationInterpreter;
-
-class FAContrastInterpreter : public ChoiceInterpreter<>
-{
-public:
-    FAContrastInterpreter ()
-    {
-        choices[0]      = "Normal";
-        choices[0x80]   = "Medium High";
-        choices[0x100]  = "High";
-        choices[0x180]  = "Medium Low";
-        choices[0x200]  = "Low";
-        choices[0x8000] = "Film Simulation";
-    }
-};
-FAContrastInterpreter faContrastInterpreter;
-
-class FAContrast2Interpreter : public ChoiceInterpreter<>
-{
-public:
-    FAContrast2Interpreter ()
-    {
-        choices[0]      = "Normal";
-        choices[0x100]  = "High";
-        choices[0x300]  = "Low";
-    }
-};
-FAContrast2Interpreter faContrast2Interpreter;
-
-class FANoiseReductionInterpreter : public ChoiceInterpreter<>
-{
-public:
-    FANoiseReductionInterpreter ()
-    {
-        choices[0x40]  = "Low";
-        choices[0x80]  = "Normal";
-        choices[0x100] = "n/a";
-    }
-};
-FANoiseReductionInterpreter faNoiseReductionInterpreter;
-
-class FAFlashInterpreter : public ChoiceInterpreter<>
-{
-public:
-    // FujiFlashMode
-    FAFlashInterpreter ()
-    {
-        choices[0]  = "Auto";
-        choices[1]  = "On";
-        choices[2]  = "Off";
-        choices[3]  = "Red-eye reduction";
-        choices[4]  = "External";
-    }
-};
-FAFlashInterpreter faFlashInterpreter;
-
-class FAFocusModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    FAFocusModeInterpreter ()
-    {
-        choices[0]  = "Auto";
-        choices[1]  = "Manual";
-    }
-};
-FAFocusModeInterpreter faFocusModeInterpreter;
-
-class FAColorModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    FAColorModeInterpreter ()
-    {
-        choices[0]    = "Standard";
-        choices[0x10] = "Chrome";
-        choices[0x30] = "B & W";
-    }
-};
-FAColorModeInterpreter faColorModeInterpreter;
-
-class FADynamicRangeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    FADynamicRangeInterpreter ()
-    {
-        choices[1]  = "Standard";
-        choices[3]  = "Wide";
-    }
-};
-FADynamicRangeInterpreter faDynamicRangeInterpreter;
-
-class FAFilmModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    FAFilmModeInterpreter ()
-    {
-        choices[0x0]   = "F0/Standard (Provia)";
-        choices[0x100] = "F1/Studio Portrait";
-        choices[0x110] = "F1a/Studio Portrait Enhanced Saturation";
-        choices[0x120] = "F1b/Studio Portrait Smooth Skin Tone (Astia)";
-        choices[0x130] = "F1c/Studio Portrait Increased Sharpness";
-        choices[0x200] = "F2/Fujichrome (Velvia)";
-        choices[0x300] = "F3/Studio Portrait Ex";
-        choices[0x400] = "F4/Velvia";
-        choices[0x500] = "Pro Neg. Std";
-        choices[0x501] = "Pro Neg. Hi";
-        choices[0x600] = "Classic Chrome";
-    }
-};
-FAFilmModeInterpreter faFilmModeInterpreter;
-
-class FADRSettingInterpreter : public ChoiceInterpreter<>
-{
-public:
-    // DynamicRangeSetting
-    FADRSettingInterpreter ()
-    {
-        choices[0x0]    = "Auto (100-400%)";
-        choices[0x1]    = "Manual";
-        choices[0x100]  = "Standard (100%)";
-        choices[0x200]  = "Wide1 (230%)";
-        choices[0x201]  = "Wide2 (400%)";
-        choices[0x8000] = "Film Simulation";
-    }
-};
-FADRSettingInterpreter faDRSettingInterpreter;
-
-class FAPictureModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    FAPictureModeInterpreter ()
-    {
-        choices[0x0]   = "Auto";
-        choices[0x1]   = "Portrait";
-        choices[0x2]   = "Landscape";
-        choices[0x3]   = "Macro";
-        choices[0x4]   = "Sports";
-        choices[0x5]   = "Night Scene";
-        choices[0x6]   = "Program AE";
-        choices[0x7]   = "Natural Light";
-        choices[0x8]   = "Anti-blur";
-        choices[0x9]   = "Beach & Snow";
-        choices[0xa]   = "Sunset";
-        choices[0xb]   = "Museum";
-        choices[0xc]   = "Party";
-        choices[0xd]   = "Flower";
-        choices[0xe]   = "Text";
-        choices[0xf]   = "Natural Light & Flash";
-        choices[0x10]  = "Beach";
-        choices[0x11]  = "Snow";
-        choices[0x12]  = "Fireworks";
-        choices[0x13]  = "Underwater";
-        choices[0x14]  = "Portrait with Skin Correction";
-        choices[0x16]  = "Panorama";
-        choices[0x17]  = "Night (tripod)";
-        choices[0x18]  = "Pro Low-light";
-        choices[0x19]  = "Pro Focus";
-        choices[0x1a]  = "Portrait 2";
-        choices[0x1b]  = "Dog Face Detection";
-        choices[0x1c]  = "Cat Face Detection";
-        choices[0x40]  = "Advanced Filter";
-        choices[0x100] = "Aperture-priority AE";
-        choices[0x200] = "Shutter speed priority AE";
-        choices[0x300] = "Manual";
-    }
-};
-FAPictureModeInterpreter faPictureModeInterpreter;
-
-
-
-const TagAttrib fujiAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0000, AUTO, "Version", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0010, AUTO, "InternalSerialNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1000, AUTO, "Quality", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1001, AUTO, "Sharpness", &faSharpnessInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1002, AUTO, "WhiteBalance", &faWhiteBalanceInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1003, AUTO, "Saturation", &faSaturationInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1004, AUTO, "Contrast", &faContrastInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1005, AUTO, "ColorTemperature", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1006, AUTO, "Contrast2", &faContrast2Interpreter},
-    {0, AC_WRITE, 0, nullptr, 0x100a, AUTO, "WhiteBalanceFineTune", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x100b, AUTO, "NoiseReduction", &faNoiseReductionInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1010, AUTO, "FujiFlashMode", &faFlashInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1011, AUTO, "FlashExposureComp", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1020, AUTO, "Macro", &faOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1021, AUTO, "FocusMode", &faFocusModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1023, AUTO, "FocusPixel", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1030, AUTO, "SlowSync", &faOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1031, AUTO, "PictureMode", &faPictureModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1100, AUTO, "AutoBracketing", &faOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1101, AUTO, "SequenceNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1210, AUTO, "ColorMode", &faColorModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1300, AUTO, "BlurWarning", &faOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1301, AUTO, "FocusWarning", &faOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1302, AUTO, "ExposureWarning", &faOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1400, AUTO, "DynamicRange", &faDynamicRangeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1401, AUTO, "FilmMode", &faFilmModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1402, AUTO, "DynamicRangeSetting", &faDRSettingInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1403, AUTO, "DevelopmentDynamicRange", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1404, AUTO, "MinFocalLength", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1405, AUTO, "MaxFocalLength", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1406, AUTO, "MaxApertureAtMinFocal", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1407, AUTO, "MaxApertureAtMaxFocal", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x140b, AUTO, "AutoDynamicRange", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x4100, AUTO, "FacesDetected", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x8000, AUTO, "FileSource", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x8002, AUTO, "OrderNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x8003, AUTO, "FrameNumber", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-}
-
diff --git a/rtexif/kodakattribs.cc b/rtexif/kodakattribs.cc
deleted file mode 100644
index c89ca2298..000000000
--- a/rtexif/kodakattribs.cc
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- *  This file is part of RawTherapee.
- */
-
-#include <string.h>
-#include "rtexif.h"
-
-namespace rtexif
-{
-
-
-void parseKodakIfdTextualInfo (Tag *textualInfo, Tag* exif_)
-{
-    // parse TextualInfo and copy values into corresponding standard Exif
-    if (textualInfo->getType() != ASCII) {
-        return;
-    }
-
-    TagDirectory *exif = exif_->getDirectory();
-    char *value = (char *)textualInfo->getValue();
-
-    char *p = value;
-    char *pc, *plf;
-
-    while ((pc = strchr (p, ':')) != nullptr && (plf = strchr (pc, '\n')) != nullptr) {
-        while (*p == ' ') {
-            p++;
-        }
-
-        size_t len = pc - p;
-
-        while (len > 1 && p[len - 1] == ' ') {
-            len--;
-        }
-
-        std::string key = std::string (p, len);
-        ++pc;
-
-        while (*pc == ' ') {
-            pc++;
-        }
-
-        len = plf - pc;
-
-        while (len > 1 && pc[len - 1] == ' ') {
-            len--;
-        }
-
-        std::string val = std::string (pc, len);
-        p = ++plf;
-
-        // we pick out a few select tags here
-        Tag *t;
-
-        if (key == "Lens") {
-            // Proback645 may have "Lens" but not "Focal Length"
-            float flen = atof (val.c_str());
-
-            if (flen != 0.f) {
-                t = new Tag (exif, lookupAttrib (exifAttribs, "FocalLength"));
-                t->initRational (flen * 32, 32);
-                exif->replaceTag (t);
-            }
-        } else if (key == "Focal Length") {
-            float flen = atof (val.c_str());
-
-            if (flen != 0.f) {
-                t = new Tag (exif, lookupAttrib (exifAttribs, "FocalLength"));
-                t->initRational (flen * 32, 32);
-                exif->replaceTag (t);
-            }
-        } else if (key == "Aperture") {
-            float aperture = atof (&val.c_str()[1]);
-
-            if (aperture != 0.f) {
-                t = new Tag (exif, lookupAttrib (exifAttribs, "FNumber"));
-                t->initRational ((int) (aperture * 10), 10);
-                exif->replaceTag (t);
-            }
-        } else if (key == "Exposure Bias" || key == "Compensation") {
-            float bias = 0.0;
-
-            if (val != "Off") {
-                bias = atof (val.c_str());
-            }
-
-            t = new Tag (exif, lookupAttrib (exifAttribs, "ExposureBiasValue"));
-            t->initRational ((int) (bias * 1000), 1000);
-            exif->replaceTag (t);
-        } else if (key == "ISO Speed") {
-            t = new Tag (exif, lookupAttrib (exifAttribs, "ISOSpeedRatings"));
-            t->initInt (atoi (val.c_str()), SHORT);
-            exif->replaceTag (t);
-        } else if (key == "Shutter") {
-            const char *p1 = strchr (val.c_str(), '/');
-            int a, b;
-
-            if (p1 == nullptr) {
-                a = atoi (val.c_str());
-                b = 1;
-            } else {
-                a = atoi (val.c_str());
-                b = atoi (&p1[1]);
-            }
-            t = new Tag (exif, lookupAttrib (exifAttribs, "ExposureTime"));
-            t->initRational (a, b);
-            exif->replaceTag (t);
-
-            const float ssv = -log2 ((float)a / std::max((float)b, 0.0001f)); // convert to APEX value, avoid division by zero
-            t = new Tag (exif, lookupAttrib (exifAttribs, "ShutterSpeedValue"));
-            t->initRational (1000000 * ssv, 1000000);
-            exif->replaceTag (t);
-        } else if (key == "Flash Fired") {
-            t = new Tag (exif, lookupAttrib (exifAttribs, "Flash"));
-
-            if (val == "No") {
-                t->initInt (0, SHORT);
-            } else {
-                // not sure if "Flash Fired" is only yes/no, only seen "No" in test pictures
-                t->initInt (1, SHORT);
-            }
-
-            exif->replaceTag (t);
-        } else if (key == "White balance") { // yes should be small 'b' int 'balance'.
-            t = new Tag (exif, lookupAttrib (exifAttribs, "Flash"));
-            t->initInt ((val == "Auto") ? 0 : 1, SHORT);
-            exif->replaceTag (t);
-        }
-    }
-}
-
-// table not complete, not all proprietary Kodak tags are known
-const TagAttrib kodakIfdAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0001, AUTO, "UnknownEV?", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0003, AUTO, "ExposureValue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x03e9, AUTO, "OriginalFileName", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x03eb, AUTO, "SensorLeftBorder", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x03ec, AUTO, "SensorTopBorder", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x03ed, AUTO, "SensorImageWidth", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x03ee, AUTO, "SensorImageHeight", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x03f1, AUTO, "TextualInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x03fc, AUTO, "WhiteBalance", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x03fd, AUTO, "Processing", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0401, AUTO, "Time", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0414, AUTO, "NCDFileInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0846, AUTO, "ColorTemperature", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0852, AUTO, "WB_RGBMul0", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0853, AUTO, "WB_RGBMul1", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0854, AUTO, "WB_RGBMul2", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0855, AUTO, "WB_RGBMul3", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x085c, AUTO, "WB_RGBCoeffs0", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x085d, AUTO, "WB_RGBCoeffs1", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x085e, AUTO, "WB_RGBCoeffs2", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x085f, AUTO, "WB_RGBCoeffs3", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0ce5, AUTO, "FirmwareVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1391, AUTO, "ToneCurveFileName", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1784, AUTO, "ISO", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr }
-};
-
-}
-
diff --git a/rtexif/nikonattribs.cc b/rtexif/nikonattribs.cc
deleted file mode 100644
index 83aec22f6..000000000
--- a/rtexif/nikonattribs.cc
+++ /dev/null
@@ -1,1254 +0,0 @@
-/*
- *  This file is part of RawTherapee.
- *
- *  Copyright (c) 2004-2010 Gabor Horvath <hgabor@rawtherapee.com>
- *
- *  RawTherapee is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  RawTherapee is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-#include <cstdio>
-#include <cstring>
-#include <sstream>
-#include <iomanip>
-#include "rtexif.h"
-
-using namespace std;
-
-namespace rtexif
-{
-
-class NAISOInterpreter : public Interpreter
-{
-public:
-    NAISOInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        snprintf(buffer, sizeof(buffer), "%d", t->toInt (2));
-        return buffer;
-    }
-};
-NAISOInterpreter naISOInterpreter;
-
-class NAISOInfoISOInterpreter : public Interpreter
-{
-public:
-    NAISOInfoISOInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        int a = t->toInt();
-        snprintf(buffer, sizeof(buffer), "%d", a);
-        return buffer;
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        int a = t->getValue()[ofs];
-
-        if (a > 1) {
-            double i = pow (2., double (a) / 12. - 5.) * 100.;
-            return i;
-        } else {
-            return 0.;
-        }
-    }
-    int toInt (const Tag* t, int ofs, TagType astype) override
-    {
-        int a = t->getValue()[ofs];
-
-        if (a > 1) {
-            int i = static_cast<double>(powf(2.f, float (a) / 12.f - 5.f)) * 100.0 + 0.5;
-            return i;
-        } else {
-            return 0;
-        }
-    }
-};
-NAISOInfoISOInterpreter naISOInfoISOInterpreter;
-
-class NAISOExpansionInterpreter : public Interpreter
-{
-public:
-    NAISOExpansionInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        int a = t->toInt();
-
-        // unclear if this interpretation is correct!
-        switch (a) {
-            case 0x0:
-                return "Off";
-
-            case 0x101:
-                return "Hi 0.3";
-
-            case 0x102:
-                return "Hi 0.5";
-
-            case 0x103:
-                return "Hi 0.7";
-
-            case 0x104:
-                return "Hi 1.0";
-
-            case 0x105:
-                return "Hi 1.3";
-
-            case 0x106:
-                return "Hi 1.5";
-
-            case 0x107:
-                return "Hi 1.7";
-
-            case 0x108:
-                return "Hi 2.0";
-
-            case 0x201:
-                return "Lo 0.3";
-
-            case 0x202:
-                return "Lo 0.5";
-
-            case 0x203:
-                return "Lo 0.7";
-
-            case 0x204:
-                return "Lo 1.0";
-
-            default: {
-                char buffer[32];
-                snprintf(buffer, sizeof(buffer), "0x%04X", a);
-                return buffer;
-            }
-        }
-    }
-};
-NAISOExpansionInterpreter naISOExpansionInterpreter;
-
-class NALensTypeInterpreter : public Interpreter
-{
-public:
-    NALensTypeInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        int a = t->toInt();
-        std::ostringstream str;
-        str << "MF = " << ((a & 1) ? "Yes" : "No") << std::endl;
-        str << "D = " << ((a & 2) ? "Yes" : "No") << std::endl;
-        str << "G = " << ((a & 4) ? "Yes" : "No") << std::endl;
-        str << "VR = " << ((a & 8) ? "Yes" : "No");
-        return str.str();
-    }
-};
-NALensTypeInterpreter naLensTypeInterpreter;
-
-class NAFlashModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    NAFlashModeInterpreter ()
-    {
-        choices[0x0] = "Did Not Fire";
-        choices[0x1] = "Fired, Manual";
-        choices[0x3] = "Not Ready";
-        choices[0x7] = "Fired, External";
-        choices[0x8] = "Fired, Commander Mode";
-        choices[0x9] = "Fired, TTL Mode";
-    }
-};
-NAFlashModeInterpreter naFlashModeInterpreter;
-
-class NAHiISONRInterpreter : public ChoiceInterpreter<>
-{
-public:
-    // HighISONoiseReduction
-    NAHiISONRInterpreter ()
-    {
-        choices[0x0] = "Off";
-        choices[0x1] = "Minimal";
-        choices[0x2] = "Low";
-        choices[0x3] = "Medium Low";
-        choices[0x4] = "Normal";
-        choices[0x5] = "Medium High";
-        choices[0x6] = "High";
-    }
-};
-NAHiISONRInterpreter naHiISONRInterpreter;
-
-class NAShootingModeInterpreter : public Interpreter
-{
-public:
-    NAShootingModeInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        int a = t->toInt();
-        std::ostringstream str;
-        str << "Continuous = " << ((a & 1) ? "Yes" : "No") << std::endl;
-        str << "Delay = " << ((a & 2) ? "Yes" : "No") << std::endl;
-        str << "PC Control = " << ((a & 4) ? "Yes" : "No") << std::endl;
-        str << "White-Balance Bracketing = " << ((a & 8) ? "Yes" : "No") << std::endl;
-        str << "Exposure Bracketing = " << ((a & 16) ? "Yes" : "No") << std::endl;
-        str << "Auto ISO = " << ((a & 32) ? "Yes" : "No") << std::endl;
-        str << "IR Control = " << ((a & 64) ? "Yes" : "No");
-        return str.str();
-    }
-};
-NAShootingModeInterpreter naShootingModeInterpreter;
-
-class NAAFInfoInterpreter : public Interpreter
-{
-    std::map<int, std::string> amchoices;
-    std::map<int, std::string> afpchoices;
-public:
-    // AFAreaMode
-    NAAFInfoInterpreter ()
-    {
-        amchoices[0x0] = "Single Area";
-        amchoices[0x1] = "Dynamic Area";
-        amchoices[0x2] = "Dynamic Area (closest subject)";
-        amchoices[0x3] = "Group Dynamic";
-        amchoices[0x4] = "Single Area (wide)";
-        amchoices[0x5] = "Dynamic Area (wide)";
-        // AFPoint
-        afpchoices[0x0] = "Center";
-        afpchoices[0x1] = "Top";
-        afpchoices[0x2] = "Bottom";
-        afpchoices[0x3] = "Mid-left";
-        afpchoices[0x4] = "Mid-right";
-        afpchoices[0x5] = "Upper-left";
-        afpchoices[0x6] = "Upper-right";
-        afpchoices[0x7] = "Lower-left";
-        afpchoices[0x8] = "Lower-right";
-        afpchoices[0x9] = "Far Left";
-        afpchoices[0xa] = "Far Right";
-    }
-    std::string toString (const Tag* t) const override
-    {
-        const auto get_from_choices =
-            [](const std::map<int, std::string>& choices, int index) -> std::string
-            {
-                const std::map<int, std::string>::const_iterator choice = choices.find(index);
-
-                if (choice != choices.end()) {
-                    return choice->second;
-                }
-
-                return {};
-            };
-
-        int am = t->toInt (0, BYTE);
-        int afp = t->toInt (1, BYTE);
-        int aff = t->toInt (2, SHORT);
-        std::ostringstream str;
-        str << "AFAreaMode = " << get_from_choices(amchoices, am) << std::endl;
-        str << "AFAreaMode = " << get_from_choices(afpchoices, afp) << std::endl;
-
-        std::ostringstream af;
-
-        if (aff) {
-            for (size_t i = 0; i < afpchoices.size(); ++i) {
-                if (aff & (1 << i)) {
-                    if (!af.str().empty()) {
-                        af << ", ";
-                    }
-                    af << afpchoices.at(i);
-                }
-            }
-        }
-
-        str << "AFPointsInFocus = " << (af.str().empty() ? "None" : af.str());
-        return str.str();
-    }
-};
-NAAFInfoInterpreter naAFInfoInterpreter;
-
-class NALensDataInterpreter : public Interpreter
-{
-    static const std::map<std::string, std::string> lenses;
-
-public:
-    std::string toString (const Tag* t) const override
-    {
-
-        static const unsigned char xlat[2][256] = {
-            {
-                0xc1, 0xbf, 0x6d, 0x0d, 0x59, 0xc5, 0x13, 0x9d, 0x83, 0x61, 0x6b, 0x4f, 0xc7, 0x7f, 0x3d, 0x3d,
-                0x53, 0x59, 0xe3, 0xc7, 0xe9, 0x2f, 0x95, 0xa7, 0x95, 0x1f, 0xdf, 0x7f, 0x2b, 0x29, 0xc7, 0x0d,
-                0xdf, 0x07, 0xef, 0x71, 0x89, 0x3d, 0x13, 0x3d, 0x3b, 0x13, 0xfb, 0x0d, 0x89, 0xc1, 0x65, 0x1f,
-                0xb3, 0x0d, 0x6b, 0x29, 0xe3, 0xfb, 0xef, 0xa3, 0x6b, 0x47, 0x7f, 0x95, 0x35, 0xa7, 0x47, 0x4f,
-                0xc7, 0xf1, 0x59, 0x95, 0x35, 0x11, 0x29, 0x61, 0xf1, 0x3d, 0xb3, 0x2b, 0x0d, 0x43, 0x89, 0xc1,
-                0x9d, 0x9d, 0x89, 0x65, 0xf1, 0xe9, 0xdf, 0xbf, 0x3d, 0x7f, 0x53, 0x97, 0xe5, 0xe9, 0x95, 0x17,
-                0x1d, 0x3d, 0x8b, 0xfb, 0xc7, 0xe3, 0x67, 0xa7, 0x07, 0xf1, 0x71, 0xa7, 0x53, 0xb5, 0x29, 0x89,
-                0xe5, 0x2b, 0xa7, 0x17, 0x29, 0xe9, 0x4f, 0xc5, 0x65, 0x6d, 0x6b, 0xef, 0x0d, 0x89, 0x49, 0x2f,
-                0xb3, 0x43, 0x53, 0x65, 0x1d, 0x49, 0xa3, 0x13, 0x89, 0x59, 0xef, 0x6b, 0xef, 0x65, 0x1d, 0x0b,
-                0x59, 0x13, 0xe3, 0x4f, 0x9d, 0xb3, 0x29, 0x43, 0x2b, 0x07, 0x1d, 0x95, 0x59, 0x59, 0x47, 0xfb,
-                0xe5, 0xe9, 0x61, 0x47, 0x2f, 0x35, 0x7f, 0x17, 0x7f, 0xef, 0x7f, 0x95, 0x95, 0x71, 0xd3, 0xa3,
-                0x0b, 0x71, 0xa3, 0xad, 0x0b, 0x3b, 0xb5, 0xfb, 0xa3, 0xbf, 0x4f, 0x83, 0x1d, 0xad, 0xe9, 0x2f,
-                0x71, 0x65, 0xa3, 0xe5, 0x07, 0x35, 0x3d, 0x0d, 0xb5, 0xe9, 0xe5, 0x47, 0x3b, 0x9d, 0xef, 0x35,
-                0xa3, 0xbf, 0xb3, 0xdf, 0x53, 0xd3, 0x97, 0x53, 0x49, 0x71, 0x07, 0x35, 0x61, 0x71, 0x2f, 0x43,
-                0x2f, 0x11, 0xdf, 0x17, 0x97, 0xfb, 0x95, 0x3b, 0x7f, 0x6b, 0xd3, 0x25, 0xbf, 0xad, 0xc7, 0xc5,
-                0xc5, 0xb5, 0x8b, 0xef, 0x2f, 0xd3, 0x07, 0x6b, 0x25, 0x49, 0x95, 0x25, 0x49, 0x6d, 0x71, 0xc7
-            },
-            {
-                0xa7, 0xbc, 0xc9, 0xad, 0x91, 0xdf, 0x85, 0xe5, 0xd4, 0x78, 0xd5, 0x17, 0x46, 0x7c, 0x29, 0x4c,
-                0x4d, 0x03, 0xe9, 0x25, 0x68, 0x11, 0x86, 0xb3, 0xbd, 0xf7, 0x6f, 0x61, 0x22, 0xa2, 0x26, 0x34,
-                0x2a, 0xbe, 0x1e, 0x46, 0x14, 0x68, 0x9d, 0x44, 0x18, 0xc2, 0x40, 0xf4, 0x7e, 0x5f, 0x1b, 0xad,
-                0x0b, 0x94, 0xb6, 0x67, 0xb4, 0x0b, 0xe1, 0xea, 0x95, 0x9c, 0x66, 0xdc, 0xe7, 0x5d, 0x6c, 0x05,
-                0xda, 0xd5, 0xdf, 0x7a, 0xef, 0xf6, 0xdb, 0x1f, 0x82, 0x4c, 0xc0, 0x68, 0x47, 0xa1, 0xbd, 0xee,
-                0x39, 0x50, 0x56, 0x4a, 0xdd, 0xdf, 0xa5, 0xf8, 0xc6, 0xda, 0xca, 0x90, 0xca, 0x01, 0x42, 0x9d,
-                0x8b, 0x0c, 0x73, 0x43, 0x75, 0x05, 0x94, 0xde, 0x24, 0xb3, 0x80, 0x34, 0xe5, 0x2c, 0xdc, 0x9b,
-                0x3f, 0xca, 0x33, 0x45, 0xd0, 0xdb, 0x5f, 0xf5, 0x52, 0xc3, 0x21, 0xda, 0xe2, 0x22, 0x72, 0x6b,
-                0x3e, 0xd0, 0x5b, 0xa8, 0x87, 0x8c, 0x06, 0x5d, 0x0f, 0xdd, 0x09, 0x19, 0x93, 0xd0, 0xb9, 0xfc,
-                0x8b, 0x0f, 0x84, 0x60, 0x33, 0x1c, 0x9b, 0x45, 0xf1, 0xf0, 0xa3, 0x94, 0x3a, 0x12, 0x77, 0x33,
-                0x4d, 0x44, 0x78, 0x28, 0x3c, 0x9e, 0xfd, 0x65, 0x57, 0x16, 0x94, 0x6b, 0xfb, 0x59, 0xd0, 0xc8,
-                0x22, 0x36, 0xdb, 0xd2, 0x63, 0x98, 0x43, 0xa1, 0x04, 0x87, 0x86, 0xf7, 0xa6, 0x26, 0xbb, 0xd6,
-                0x59, 0x4d, 0xbf, 0x6a, 0x2e, 0xaa, 0x2b, 0xef, 0xe6, 0x78, 0xb6, 0x4e, 0xe0, 0x2f, 0xdc, 0x7c,
-                0xbe, 0x57, 0x19, 0x32, 0x7e, 0x2a, 0xd0, 0xb8, 0xba, 0x29, 0x00, 0x3c, 0x52, 0x7d, 0xa8, 0x49,
-                0x3b, 0x2d, 0xeb, 0x25, 0x49, 0xfa, 0xa3, 0xaa, 0x39, 0xa7, 0xc5, 0xa7, 0x50, 0x11, 0x36, 0xfb,
-                0xc6, 0x67, 0x4a, 0xf5, 0xa5, 0x12, 0x65, 0x7e, 0xb0, 0xdf, 0xaf, 0x4e, 0xb3, 0x61, 0x7f, 0x2f
-            }
-        };
-
-        int ver = (t->toInt (0, BYTE) - '0') * 1000 + (t->toInt (1, BYTE) - '0') * 100 + (t->toInt (2, BYTE) - '0') * 10 + (t->toInt (3, BYTE) - '0');
-
-        std::ostringstream ld;
-        ld << "Version = " << ver << std::endl;
-
-        int lenstype = t->getParent()->getTag (0x0083)->toInt (0, BYTE);
-
-        std::ostringstream lid;
-        lid.setf (std::ios_base::hex, std::ios_base::basefield);
-        lid.setf (std::ios_base::uppercase);
-
-        Tag *modelTag = t->getParent()->getRoot()->findTag ("Model");
-        std::string model ( modelTag ?  modelTag->valueToString() : "");
-        int lidoffs = 7;
-        bool d100 = false;
-
-        if (model.substr (0, 10) == "NIKON D100" || model.substr (0, 9) == "NIKON D1X") {
-            lidoffs = 0;
-            d100 = true;
-        } else if ( ver < 204) {
-            lidoffs = 7;
-            d100 = false;
-        } else {
-            lidoffs = 8;
-            d100 = false;
-        }
-
-        unsigned char buffer[16];
-
-        if (d100) {
-            memcpy (buffer, t->getValue() + 6, 7);
-        } else {
-            memcpy (buffer, t->getValue() + 4, 16);
-        }
-
-        if (ver >= 201) {
-            const unsigned char* serval = t->getParent()->getTag (0x001d)->getValue ();
-            int serial = 0;
-
-            for (int i = 0; serval[i]; i++) {
-                serial = serial * 10 + (isdigit (serval[i]) ? serval[i] - '0' : serval[i] % 10);
-            }
-
-            const unsigned char* scval = t->getParent()->getTag (0x00a7)->getValue ();
-            int key = 0;
-
-            for (int i = 0; i < 4; i++) {
-                key ^= scval[i];
-            }
-
-            unsigned char ci = xlat[0][serial & 0xff];
-            unsigned char cj = xlat[1][key];
-            unsigned char ck = 0x60;
-
-            for (int i = 0; i < 16; i++) {
-                buffer[i] ^= (cj += ci * ck++);
-            }
-        }
-
-        std::string EffectiveMaxApertureString;
-
-        if (!d100) {
-            int  EffectiveMaxApertureValue;
-
-            if ( ver < 204 ) {
-                ld << "ExitPupilPosition = " << (int) buffer[0] << std::endl;
-                ld << "AFAperture = "        << (int) buffer[1] << std::endl;
-                ld << "FocusPosition = "     << (int) buffer[4] << std::endl;
-                ld << "FocusDistance = "     << (int) buffer[5] << std::endl;
-                ld << "FocalLength = "       << (int) buffer[6] << std::endl;
-                EffectiveMaxApertureValue = (int) buffer[14];
-            } else {
-                ld << "ExitPupilPosition = " << (int) buffer[0] << std::endl;
-                ld << "AFAperture = "        << (int) buffer[1] << std::endl;
-                ld << "FocusPosition = "     << (int) buffer[4] << std::endl;
-                ld << "FocusDistance = "     << (int) buffer[6] << std::endl;
-                ld << "FocalLength = "       << (int) buffer[7] << std::endl;
-                EffectiveMaxApertureValue = (int) buffer[15];
-            }
-
-            switch (EffectiveMaxApertureValue) {
-                case 0x8:
-                    EffectiveMaxApertureString = "1.2";
-                    break;
-
-                case 0xc:
-                    EffectiveMaxApertureString = "1.4";
-                    break;
-
-                case 0x14:
-                    EffectiveMaxApertureString = "1.8";
-                    break;
-
-                case 0x18:
-                    EffectiveMaxApertureString = "2.0";
-                    break;
-
-                case 0x20:
-                    EffectiveMaxApertureString = "2.5";
-                    break;
-
-                case 0x24:
-                    EffectiveMaxApertureString = "2.8";
-                    break;
-
-                case 0x2a:
-                    EffectiveMaxApertureString = "3.3";
-                    break;
-
-                case 0x2c:
-                    EffectiveMaxApertureString = "3.5";
-                    break;
-
-                case 0x30:
-                    EffectiveMaxApertureString = "4.0";
-                    break;
-
-                case 0x34:
-                    EffectiveMaxApertureString = "4.5";
-                    break;
-
-                case 0x38:
-                    EffectiveMaxApertureString = "5.0";
-                    break;
-
-                case 0x3c:
-                    EffectiveMaxApertureString = "5.6";
-                    break;
-
-                case 0x40:
-                    EffectiveMaxApertureString = "6.3";
-                    break;
-
-                case 0x44:
-                    EffectiveMaxApertureString = "7.1";
-                    break;
-
-                case 0x48:
-                    EffectiveMaxApertureString = "8.0";
-                    break;
-
-                case 0x4e:
-                    EffectiveMaxApertureString = "9.5";
-                    break;
-
-                case 0x54:
-                    EffectiveMaxApertureString = "11.0";
-                    break;
-
-                case 0x5a:
-                    EffectiveMaxApertureString = "13.0";
-                    break;
-
-                case 0x5e:
-                    EffectiveMaxApertureString = "15.0";
-                    break;
-
-                case 0x60:
-                    EffectiveMaxApertureString = "16.0";
-                    break;
-
-                case 0x66:
-                    EffectiveMaxApertureString = "19.0";
-                    break;
-
-                case 0x6c:
-                    EffectiveMaxApertureString = "22.0";
-                    break;
-
-                default  :
-                    EffectiveMaxApertureString = "";
-            }
-
-            ld << "EffectiveMaxAperture = "  << EffectiveMaxApertureString << std::endl;
-        }
-
-        for (int i = 0; i < 7; i++) {
-            lid << std::setw (2) << std::setfill ('0') << (int)buffer[lidoffs + i] << ' ';
-        }
-
-        lid << std::setw (2) << std::setfill ('0') << lenstype;
-
-        std::map<std::string, std::string>::const_iterator r = lenses.find (lid.str());
-
-        if (r != lenses.end()) {
-            if (r == lenses.begin() && !EffectiveMaxApertureString.empty()) {      // first entry is for unchipped lenses
-                Tag *FLTag = t->getParent()->getRoot()->findTag ("FocalLength");
-                ld << "Lens = MF ";
-
-                if(FLTag) {
-                    ld << FLTag->valueToString () << "mm";
-                } else {
-                    ld << "0mm";
-                }
-
-                ld << " f/" << EffectiveMaxApertureString;
-            } else {
-                ld << "Lens = " << r->second;
-            }
-        } else {
-            ld << "Lens = Unknown, ID=" << lid.str();
-        }
-
-        return ld.str();
-    }
-
-};
-NALensDataInterpreter naLensDataInterpreter;
-const std::map<std::string, std::string> NALensDataInterpreter::lenses = {
-    /*
-     * The Nikon LensID is constructed as a Composite tag from the raw hex values of 8 other tags:
-     * LensIDNumber, LensFStops, MinFocalLength, MaxFocalLength, MaxApertureAtMinFocal, MaxApertureAtMaxFocal, MCUVersion and LensType, in that order.
-     */
-    {"00 00 00 00 00 00 00 01", "Manual Lens No CPU"},
-    {"00 00 00 00 00 00 E1 12", "TC-17E II"},
-    {"00 00 00 00 00 00 F1 0C", "TC-14E [II] or Sigma APO Tele Converter 1.4x EX DG or Kenko Teleplus PRO 300 DG 1.4x"},
-    {"00 00 00 00 00 00 F2 18", "TC-20E [II] or Sigma APO Tele Converter 2x EX DG or Kenko Teleplus PRO 300 DG 2.0x"},
-    {"00 00 48 48 53 53 00 01", "Loreo 40mm f/11-22 3D Lens in a Cap 9005"},
-    {"00 36 1C 2D 34 3C 00 06", "Tamron SP AF 11-18mm f/4.5-5.6 Di II LD Aspherical (IF) (A13)"},
-    {"00 3C 1F 37 30 30 00 06", "Tokina AT-X 124 AF PRO DX (AF 12-24mm f/4)"},
-    {"00 3C 2B 44 30 30 00 06", "Tokina AT-X 17-35 f/4 PRO FX (AF 17-35mm f/4)"},
-    {"00 3C 5C 80 30 30 00 0E", "Tokina AT-X 70-200 f/4 FX VCM-S (AF 70-200mm f/4)"},
-    {"00 3E 80 A0 38 3F 00 02", "Tamron SP AF 200-500mm f/5-6.3 Di LD (IF) (A08)"},
-    {"00 3F 2D 80 2B 40 00 06", "Tamron AF 18-200mm f/3.5-6.3 XR Di II LD Aspherical (IF) (A14)"},
-    {"00 3F 2D 80 2C 40 00 06", "Tamron AF 18-200mm f/3.5-6.3 XR Di II LD Aspherical (IF) Macro (A14)"},
-    {"00 3F 80 A0 38 3F 00 02", "Tamron SP AF 200-500mm f/5-6.3 Di (A08)"},
-    {"00 40 11 11 2C 2C 00 00", "Samyang 8mm f/3.5 Fish-Eye"},
-    {"00 40 18 2B 2C 34 00 06", "Tokina AT-X 107 AF DX Fisheye (AF 10-17mm f/3.5-4.5)"},
-    {"00 40 2A 72 2C 3C 00 06", "Tokina AT-X 16.5-135 DX (AF 16.5-135mm f/3.5-5.6)"},
-    {"00 40 2B 2B 2C 2C 00 02", "Tokina AT-X 17 AF PRO (AF 17mm f/3.5)"},
-    {"00 40 2D 2D 2C 2C 00 00", "Carl Zeiss Distagon T* 3.5/18 ZF.2"},
-    {"00 40 2D 80 2C 40 00 06", "Tamron AF 18-200mm f/3.5-6.3 XR Di II LD Aspherical (IF) Macro (A14NII)"},
-    {"00 40 2D 88 2C 40 00 06", "Tamron AF 18-250mm f/3.5-6.3 Di II LD Aspherical (IF) Macro (A18NII)"},
-    {"00 40 2D 88 2C 40 62 06", "Tamron AF 18-250mm f/3.5-6.3 Di II LD Aspherical (IF) Macro (A18)"},
-    {"00 40 31 31 2C 2C 00 00", "Voigtlander Color Skopar 20mm f/3.5 SLII Aspherical"},
-    {"00 40 37 80 2C 3C 00 02", "Tokina AT-X 242 AF (AF 24-200mm f/3.5-5.6)"},
-    {"00 40 64 64 2C 2C 00 00", "Voigtlander APO-Lanthar 90mm f/3.5 SLII Close Focus"},
-    {"00 44 60 98 34 3C 00 02", "Tokina AT-X 840 D (AF 80-400mm f/4.5-5.6)"},
-    {"00 47 10 10 24 24 00 00", "Fisheye Nikkor 8mm f/2.8 AiS"},
-    {"00 47 25 25 24 24 00 02", "Tamron SP AF 14mm f/2.8 Aspherical (IF) (69E)"},
-    {"00 47 3C 3C 24 24 00 00", "Nikkor 28mm f/2.8 AiS"},
-    {"00 47 44 44 24 24 00 06", "Tokina AT-X M35 PRO DX (AF 35mm f/2.8 Macro)"},
-    {"00 47 53 80 30 3C 00 06", "Tamron AF 55-200mm f/4-5.6 Di II LD (A15)"},
-    {"00 48 1C 29 24 24 00 06", "Tokina AT-X 116 PRO DX (AF 11-16mm f/2.8)"},
-    {"00 48 27 27 24 24 00 00", "Carl Zeiss Distagon T* 2.8/15 ZF.2"},
-    {"00 48 29 3C 24 24 00 06", "Tokina AT-X 16-28 AF PRO FX (AF 16-28mm f/2.8)"},
-    {"00 48 29 50 24 24 00 06", "Tokina AT-X 165 PRO DX (AF 16-50mm f/2.8)"},
-    {"00 48 32 32 24 24 00 00", "Carl Zeiss Distagon T* 2.8/21 ZF.2"},
-    {"00 48 37 5C 24 24 00 06", "Tokina AT-X 24-70 f/2.8 PRO FX (AF 24-70mm f/2.8)"},
-    {"00 48 3C 3C 24 24 00 00", "Voigtlander Color Skopar 28mm f/2.8 SL II"},
-    {"00 48 3C 60 24 24 00 02", "Tokina AT-X 280 AF PRO (AF 28-80mm f/2.8)"},
-    {"00 48 3C 6A 24 24 00 02", "Tamron SP AF 28-105mm f/2.8 LD Aspherical IF (176D)"},
-    {"00 48 50 50 18 18 00 00", "Nikkor H 50mm f/2"},
-    {"00 48 50 72 24 24 00 06", "Tokina AT-X 535 PRO DX (AF 50-135mm f/2.8)"},
-    {"00 48 5C 80 30 30 00 0E", "Tokina AT-X 70-200 f/4 FX VCM-S (AF 70-200mm f/4)"},
-    {"00 48 5C 8E 30 3C 00 06", "Tamron AF 70-300mm f/4-5.6 Di LD Macro 1:2 (A17NII)"},
-    {"00 48 68 68 24 24 00 00", "Series E 100mm f/2.8"},
-    {"00 48 80 80 30 30 00 00", "Nikkor 200mm f/4 AiS"},
-    {"00 49 30 48 22 2B 00 02", "Tamron SP AF 20-40mm f/2.7-3.5 (166D)"},
-    {"00 4C 6A 6A 20 20 00 00", "Nikkor 105mm f/2.5 AiS"},
-    {"00 4C 7C 7C 2C 2C 00 02", "Tamron SP AF 180mm f/3.5 Di Model (B01)"},
-    {"00 53 2B 50 24 24 00 06", "Tamron SP AF 17-50mm f/2.8 XR Di II LD Aspherical (IF) (A16)"},
-    {"00 54 2B 50 24 24 00 06", "Tamron SP AF 17-50mm f/2.8 XR Di II LD Aspherical (IF) (A16NII)"},
-    {"00 54 38 38 18 18 00 00", "Carl Zeiss Distagon T* 2/25 ZF.2"},
-    {"00 54 3C 3C 18 18 00 00", "Carl Zeiss Distagon T* 2/28 ZF.2"},
-    {"00 54 44 44 0C 0C 00 00", "Carl Zeiss Distagon T* 1.4/35 ZF.2"},
-    {"00 54 44 44 18 18 00 00", "Carl Zeiss Distagon T* 2/35 ZF.2"},
-    {"00 54 48 48 18 18 00 00", "Voigtlander Ultron 40mm f/2 SLII Aspherical"},
-    {"00 54 50 50 0C 0C 00 00", "Carl Zeiss Planar T* 1.4/50 ZF.2"},
-    {"00 54 50 50 18 18 00 00", "Carl Zeiss Makro-Planar T* 2/50 ZF.2"},
-    {"00 54 53 53 0C 0C 00 00", "Zeiss Otus 1.4/55"},
-    {"00 54 55 55 0C 0C 00 00", "Voigtlander Nokton 58mm f/1.4 SLII"},
-    {"00 54 56 56 30 30 00 00", "Coastal Optical Systems 60mm 1:4 UV-VIS-IR Macro Apo"},
-    {"00 54 62 62 0C 0C 00 00", "Carl Zeiss Planar T* 1.4/85 ZF.2"},
-    {"00 54 68 68 18 18 00 00", "Carl Zeiss Makro-Planar T* 2/100 ZF.2"},
-    {"00 54 68 68 24 24 00 02", "Tokina AT-X M100 AF PRO D (AF 100mm f/2.8 Macro)"},
-    {"00 54 72 72 18 18 00 00", "Carl Zeiss Apo Sonnar T* 2/135 ZF.2"},
-    {"00 54 8E 8E 24 24 00 02", "Tokina AT-X 300 AF PRO (AF 300mm f/2.8)"},
-    {"00 57 50 50 14 14 00 00", "Nikkor 50mm f/1.8 AI"},
-    {"00 58 64 64 20 20 00 00", "Soligor C/D Macro MC 90mm f/2.5"},
-    {"01 00 00 00 00 00 02 00", "TC-16A"},
-    {"01 00 00 00 00 00 08 00", "TC-16A"},
-    {"01 54 62 62 0C 0C 00 00", "Zeiss Otus 1.4/85"},
-    {"01 58 50 50 14 14 02 00", "AF Nikkor 50mm f/1.8"},
-    {"01 58 50 50 14 14 05 00", "AF Nikkor 50mm f/1.8"},
-    {"02 2F 98 98 3D 3D 02 00", "Sigma APO 400mm f/5.6"},
-    {"02 34 A0 A0 44 44 02 00", "Sigma APO 500mm f/7.2"},
-    {"02 37 5E 8E 35 3D 02 00", "Sigma 75-300mm f/4.5-5.6 APO"},
-    {"02 37 A0 A0 34 34 02 00", "Sigma APO 500mm f/4.5"},
-    {"02 3A 37 50 31 3D 02 00", "Sigma 24-50mm f/4-5.6 UC"},
-    {"02 3A 5E 8E 32 3D 02 00", "Sigma 75-300mm f/4.0-5.6"},
-    {"02 3B 44 61 30 3D 02 00", "Sigma 35-80mm f/4-5.6"},
-    {"02 3B 5C 82 30 3C 02 00", "Sigma Zoom-K 70-210mm f/4-5.6"},
-    {"02 3C B0 B0 3C 3C 02 00", "Sigma APO 800mm f/5.6"},
-    {"02 3F 24 24 2C 2C 02 00", "Sigma 14mm f/3.5"},
-    {"02 3F 3C 5C 2D 35 02 00", "Sigma 28-70mm f/3.5-4.5 UC"},
-    {"02 40 44 5C 2C 34 02 00", "Exakta AF 35-70mm 1:3.5-4.5 MC"},
-    {"02 40 44 73 2B 36 02 00", "Sigma 35-135mm f/3.5-4.5 a"},
-    {"02 40 5C 82 2C 35 02 00", "Sigma APO 70-210mm f/3.5-4.5"},
-    {"02 42 44 5C 2A 34 02 00", "AF Zoom-Nikkor 35-70mm f/3.3-4.5"},
-    {"02 42 44 5C 2A 34 08 00", "AF Zoom-Nikkor 35-70mm f/3.3-4.5"},
-    {"02 46 37 37 25 25 02 00", "Sigma 24mm f/2.8 Super Wide II Macro"},
-    {"02 46 3C 5C 25 25 02 00", "Sigma 28-70mm f/2.8"},
-    {"02 46 5C 82 25 25 02 00", "Sigma 70-210mm f/2.8 APO"},
-    {"02 48 50 50 24 24 02 00", "Sigma Macro 50mm f/2.8"},
-    {"02 48 65 65 24 24 02 00", "Sigma Macro 90mm f/2.8"},
-    {"03 43 5C 81 35 35 02 00", "Soligor AF C/D Zoom UMCS 70-210mm 1:4.5"},
-    {"03 48 5C 81 30 30 02 00", "AF Zoom-Nikkor 70-210mm f/4"},
-    {"03 54 68 68 0C 0C 00 00", "Zeiss Otus 1.4/100"},
-    {"04 48 3C 3C 24 24 03 00", "AF Nikkor 28mm f/2.8"},
-    {"05 54 50 50 0C 0C 04 00", "AF Nikkor 50mm f/1.4"},
-    {"06 3F 68 68 2C 2C 06 00", "Cosina AF 100mm f/3.5 Macro"},
-    {"06 54 53 53 24 24 06 00", "AF Micro-Nikkor 55mm f/2.8"},
-    {"07 36 3D 5F 2C 3C 03 00", "Cosina AF Zoom 28-80mm f/3.5-5.6 MC Macro"},
-    {"07 3E 30 43 2D 35 03 00", "Soligor AF Zoom 19-35mm 1:3.5-4.5 MC"},
-    {"07 40 2F 44 2C 34 03 02", "Tamron AF 19-35mm f/3.5-4.5 (A10)"},
-    {"07 40 30 45 2D 35 03 02", "Tamron AF 19-35mm f/3.5-4.5 (A10)"},
-    {"07 40 30 45 2D 35 03 02", "Voigtlander Ultragon 19-35mm f/3.5-4.5 VMV"},
-    {"07 40 3C 5C 2C 35 03 00", "Tokina AF 270 II (AF 28-70mm f/3.5-4.5)"},
-    {"07 40 3C 62 2C 34 03 00", "AF Zoom-Nikkor 28-85mm f/3.5-4.5"},
-    {"07 46 2B 44 24 30 03 02", "Tamron SP AF 17-35mm f/2.8-4 Di LD Aspherical (IF) (A05)"},
-    {"07 46 3D 6A 25 2F 03 00", "Cosina AF Zoom 28-105mm f/2.8-3.8 MC"},
-    {"07 47 3C 5C 25 35 03 00", "Tokina AF 287 SD (AF 28-70mm f/2.8-4.5)"},
-    {"07 48 3C 5C 24 24 03 00", "Tokina AT-X 287 AF (AF 28-70mm f/2.8)"},
-    {"08 40 44 6A 2C 34 04 00", "AF Zoom-Nikkor 35-105mm f/3.5-4.5"},
-    {"09 48 37 37 24 24 04 00", "AF Nikkor 24mm f/2.8"},
-    {"0A 48 8E 8E 24 24 03 00", "AF Nikkor 300mm f/2.8 IF-ED"},
-    {"0A 48 8E 8E 24 24 05 00", "AF Nikkor 300mm f/2.8 IF-ED N"},
-    {"0B 3E 3D 7F 2F 3D 0E 00", "Tamron AF 28-200mm f/3.8-5.6 (71D)"},
-    {"0B 3E 3D 7F 2F 3D 0E 02", "Tamron AF 28-200mm f/3.8-5.6D (171D)"},
-    {"0B 48 7C 7C 24 24 05 00", "AF Nikkor 180mm f/2.8 IF-ED"},
-    {"0D 40 44 72 2C 34 07 00", "AF Zoom-Nikkor 35-135mm f/3.5-4.5"},
-    {"0E 48 5C 81 30 30 05 00", "AF Zoom-Nikkor 70-210mm f/4"},
-    {"0E 4A 31 48 23 2D 0E 02", "Tamron SP AF 20-40mm f/2.7-3.5 (166D)"},
-    {"0F 58 50 50 14 14 05 00", "AF Nikkor 50mm f/1.8 N"},
-    {"10 3D 3C 60 2C 3C D2 02", "Tamron AF 28-80mm f/3.5-5.6 Aspherical (177D)"},
-    {"10 48 8E 8E 30 30 08 00", "AF Nikkor 300mm f/4 IF-ED"},
-    {"11 48 44 5C 24 24 08 00", "AF Zoom-Nikkor 35-70mm f/2.8"},
-    {"11 48 44 5C 24 24 15 00", "AF Zoom-Nikkor 35-70mm f/2.8"},
-    {"12 36 5C 81 35 3D 09 00", "Cosina AF Zoom 70-210mm f/4.5-5.6 MC Macro"},
-    {"12 36 69 97 35 42 09 00", "Soligor AF Zoom 100-400mm 1:4.5-6.7 MC"},
-    {"12 38 69 97 35 42 09 02", "Promaster Spectrum 7 100-400mm f/4.5-6.7"},
-    {"12 39 5C 8E 34 3D 08 02", "Cosina AF Zoom 70-300mm f/4.5-5.6 MC Macro"},
-    {"12 3B 68 8D 3D 43 09 02", "Cosina AF Zoom 100-300mm f/5.6-6.7 MC Macro"},
-    {"12 3B 98 98 3D 3D 09 00", "Tokina AT-X 400 AF SD (AF 400mm f/5.6)"},
-    {"12 3D 3C 80 2E 3C DF 02", "Tamron AF 28-200mm f/3.8-5.6 AF Aspherical LD (IF) (271D)"},
-    {"12 44 5E 8E 34 3C 09 00", "Tokina AF 730 (AF 75-300mm f/4.5-5.6)"},
-    {"12 48 5C 81 30 3C 09 00", "AF Nikkor 70-210mm f/4-5.6"},
-    {"12 4A 5C 81 31 3D 09 00", "Soligor AF C/D Auto Zoom+Macro 70-210mm 1:4-5.6 UMCS"},
-    {"13 42 37 50 2A 34 0B 00", "AF Zoom-Nikkor 24-50mm f/3.3-4.5"},
-    {"14 48 60 80 24 24 0B 00", "AF Zoom-Nikkor 80-200mm f/2.8 ED"},
-    {"14 48 68 8E 30 30 0B 00", "Tokina AT-X 340 AF (AF 100-300mm f/4)"},
-    {"14 54 60 80 24 24 0B 00", "Tokina AT-X 828 AF (AF 80-200mm f/2.8)"},
-    {"15 4C 62 62 14 14 0C 00", "AF Nikkor 85mm f/1.8"},
-    {"17 3C A0 A0 30 30 0F 00", "Nikkor 500mm f/4 P ED IF"},
-    {"17 3C A0 A0 30 30 11 00", "Nikkor 500mm f/4 P ED IF"},
-    {"18 40 44 72 2C 34 0E 00", "AF Zoom-Nikkor 35-135mm f/3.5-4.5 N"},
-    {"1A 54 44 44 18 18 11 00", "AF Nikkor 35mm f/2"},
-    {"1B 44 5E 8E 34 3C 10 00", "AF Zoom-Nikkor 75-300mm f/4.5-5.6"},
-    {"1C 48 30 30 24 24 12 00", "AF Nikkor 20mm f/2.8"},
-    {"1D 42 44 5C 2A 34 12 00", "AF Zoom-Nikkor 35-70mm f/3.3-4.5 N"},
-    {"1E 54 56 56 24 24 13 00", "AF Micro-Nikkor 60mm f/2.8"},
-    {"1E 5D 64 64 20 20 13 00", "Tamron SP AF 90mm f/2.5 (52E)"},
-    {"1F 54 6A 6A 24 24 14 00", "AF Micro-Nikkor 105mm f/2.8"},
-    {"20 3C 80 98 3D 3D 1E 02", "Tamron AF 200-400mm f/5.6 LD IF (75D)"},
-    {"20 48 60 80 24 24 15 00", "AF Zoom-Nikkor 80-200mm f/2.8 ED"},
-    {"20 5A 64 64 20 20 14 00", "Tamron SP AF 90mm f/2.5 Macro (152E)"},
-    {"21 40 3C 5C 2C 34 16 00", "AF Zoom-Nikkor 28-70mm f/3.5-4.5"},
-    {"21 56 8E 8E 24 24 14 00", "Tamron SP AF 300mm f/2.8 LD-IF (60E)"},
-    {"22 48 72 72 18 18 16 00", "AF DC-Nikkor 135mm f/2"},
-    {"22 53 64 64 24 24 E0 02", "Tamron SP AF 90mm f/2.8 Macro 1:1 (72E)"},
-    {"23 30 BE CA 3C 48 17 00", "Zoom-Nikkor 1200-1700mm f/5.6-8 P ED IF"},
-    {"24 44 60 98 34 3C 1A 02", "Tokina AT-X 840 AF-II (AF 80-400mm f/4.5-5.6)"},
-    {"24 48 60 80 24 24 1A 02", "AF Zoom-Nikkor 80-200mm f/2.8D ED"},
-    {"24 54 60 80 24 24 1A 02", "Tokina AT-X 828 AF PRO (AF 80-200mm f/2.8)"},
-    {"25 44 44 8E 34 42 1B 02", "Tokina AF 353 (AF 35-300mm f/4.5-6.7)"},
-    {"25 48 3C 5C 24 24 1B 02", "Tokina AT-X 270 AF PRO II (AF 28-70mm f/2.6-2.8)"},
-    {"25 48 3C 5C 24 24 1B 02", "Tokina AT-X 287 AF PRO SV (AF 28-70mm f/2.8)"},
-    {"25 48 44 5C 24 24 1B 02", "AF Zoom-Nikkor 35-70mm f/2.8D"},
-    {"25 48 44 5C 24 24 3A 02", "AF Zoom-Nikkor 35-70mm f/2.8D"},
-    {"25 48 44 5C 24 24 52 02", "AF Zoom-Nikkor 35-70mm f/2.8D"},
-    {"26 3C 54 80 30 3C 1C 06", "Sigma 55-200mm f/4-5.6 DC"},
-    {"26 3C 5C 82 30 3C 1C 02", "Sigma 70-210mm f/4-5.6 UC-II"},
-    {"26 3C 5C 8E 30 3C 1C 02", "Sigma 70-300mm f/4-5.6 DG Macro"},
-    {"26 3C 98 98 3C 3C 1C 02", "Sigma APO Tele Macro 400mm f/5.6"},
-    {"26 3D 3C 80 2F 3D 1C 02", "Sigma 28-300mm f/3.8-5.6 Aspherical"},
-    {"26 3E 3C 6A 2E 3C 1C 02", "Sigma 28-105mm f/3.8-5.6 UC-III Aspherical IF"},
-    {"26 40 27 3F 2C 34 1C 02", "Sigma 15-30mm f/3.5-4.5 EX DG Aspherical DF"},
-    {"26 40 2D 44 2B 34 1C 02", "Sigma 18-35mm f/3.5-4.5 Aspherical"},
-    {"26 40 2D 50 2C 3C 1C 06", "Sigma 18-50mm f/3.5-5.6 DC"},
-    {"26 40 2D 70 2B 3C 1C 06", "Sigma 18-125mm f/3.5-5.6 DC"},
-    {"26 40 2D 80 2C 40 1C 06", "Sigma 18-200mm f/3.5-6.3 DC"},
-    {"26 40 37 5C 2C 3C 1C 02", "Sigma 24-70mm f/3.5-5.6 Aspherical HF"},
-    {"26 40 3C 5C 2C 34 1C 02", "AF Zoom-Nikkor 28-70mm f/3.5-4.5D"},
-    {"26 40 3C 60 2C 3C 1C 02", "Sigma 28-80mm f/3.5-5.6 Mini Zoom Macro II Aspherical"},
-    {"26 40 3C 65 2C 3C 1C 02", "Sigma 28-90mm f/3.5-5.6 Macro"},
-    {"26 40 3C 80 2B 3C 1C 02", "Sigma 28-200mm f/3.5-5.6 Compact Aspherical Hyperzoom Macro"},
-    {"26 40 3C 80 2C 3C 1C 02", "Sigma 28-200mm f/3.5-5.6 Compact Aspherical Hyperzoom Macro"},
-    {"26 40 3C 8E 2C 40 1C 02", "Sigma 28-300mm f/3.5-6.3 Macro"},
-    {"26 40 7B A0 34 40 1C 02", "Sigma APO 170-500mm f/5-6.3 Aspherical RF"},
-    {"26 41 3C 8E 2C 40 1C 02", "Sigma 28-300mm f/3.5-6.3 DG Macro"},
-    {"26 44 73 98 34 3C 1C 02", "Sigma 135-400mm f/4.5-5.6 APO Aspherical"},
-    {"26 45 68 8E 34 42 1C 02", "Sigma 100-300mm f/4.5-6.7 DL"},
-    {"26 48 11 11 30 30 1C 02", "Sigma 8mm f/4 EX Circular Fisheye"},
-    {"26 48 27 27 24 24 1C 02", "Sigma 15mm f/2.8 EX Diagonal Fisheye"},
-    {"26 48 2D 50 24 24 1C 06", "Sigma 18-50mm f/2.8 EX DC"},
-    {"26 48 31 49 24 24 1C 02", "Sigma 20-40mm f/2.8"},
-    {"26 48 37 56 24 24 1C 02", "Sigma 24-60mm f/2.8 EX DG"},
-    {"26 48 3C 5C 24 24 1C 06", "Sigma 28-70mm f/2.8 EX DG"},
-    {"26 48 3C 5C 24 30 1C 02", "Sigma 28-70mm f/2.8-4 DG"},
-    {"26 48 3C 6A 24 30 1C 02", "Sigma 28-105mm f/2.8-4 Aspherical"},
-    {"26 48 8E 8E 30 30 1C 02", "Sigma APO Tele Macro 300mm f/4"},
-    {"26 54 2B 44 24 30 1C 02", "Sigma 17-35mm f/2.8-4 EX Aspherical"},
-    {"26 54 37 5C 24 24 1C 02", "Sigma 24-70mm f/2.8 EX DG Macro"},
-    {"26 54 37 73 24 34 1C 02", "Sigma 24-135mm f/2.8-4.5"},
-    {"26 54 3C 5C 24 24 1C 02", "Sigma 28-70mm f/2.8 EX"},
-    {"26 58 31 31 14 14 1C 02", "Sigma 20mm f/1.8 EX DG Aspherical RF"},
-    {"26 58 37 37 14 14 1C 02", "Sigma 24mm f/1.8 EX DG Aspherical Macro"},
-    {"26 58 3C 3C 14 14 1C 02", "Sigma 28mm f/1.8 EX DG Aspherical Macro"},
-    {"27 48 8E 8E 24 24 1D 02", "AF-I Nikkor 300mm f/2.8D IF-ED"},
-    {"27 48 8E 8E 24 24 E1 02", "AF-I Nikkor 300mm f/2.8D IF-ED + TC-17E"},
-    {"27 48 8E 8E 24 24 F1 02", "AF-I Nikkor 300mm f/2.8D IF-ED + TC-14E"},
-    {"27 48 8E 8E 24 24 F2 02", "AF-I Nikkor 300mm f/2.8D IF-ED + TC-20E"},
-    {"27 48 8E 8E 30 30 1D 02", "Tokina AT-X 304 AF (AF 300mm f/4.0)"},
-    {"27 54 8E 8E 24 24 1D 02", "Tamron SP AF 300mm f/2.8 LD-IF (360E)"},
-    {"28 3C A6 A6 30 30 1D 02", "AF-I Nikkor 600mm f/4D IF-ED"},
-    {"28 3C A6 A6 30 30 E1 02", "AF-I Nikkor 600mm f/4D IF-ED + TC-17E"},
-    {"28 3C A6 A6 30 30 F1 02", "AF-I Nikkor 600mm f/4D IF-ED + TC-14E"},
-    {"28 3C A6 A6 30 30 F2 02", "AF-I Nikkor 600mm f/4D IF-ED + TC-20E"},
-    {"2A 54 3C 3C 0C 0C 26 02", "AF Nikkor 28mm f/1.4D"},
-    {"2B 3C 44 60 30 3C 1F 02", "AF Zoom-Nikkor 35-80mm f/4-5.6D"},
-    {"2C 48 6A 6A 18 18 27 02", "AF DC-Nikkor 105mm f/2D"},
-    {"2D 48 80 80 30 30 21 02", "AF Micro-Nikkor 200mm f/4D IF-ED"},
-    {"2E 48 5C 82 30 3C 22 02", "AF Nikkor 70-210mm f/4-5.6D"},
-    {"2E 48 5C 82 30 3C 28 02", "AF Nikkor 70-210mm f/4-5.6D"},
-    {"2F 40 30 44 2C 34 29 02", "Tokina AF 235 II (AF 20-35mm f/3.5-4.5)"},
-    {"2F 40 30 44 2C 34 29 02", "Tokina AF 193 (AF 19-35mm f/3.5-4.5)"},
-    {"2F 48 30 44 24 24 29 02", "AF Zoom-Nikkor 20-35mm f/2.8D IF"},
-    {"2F 48 30 44 24 24 29 02", "Tokina AT-X 235 AF PRO (AF 20-35mm f/2.8)"},
-    {"30 48 98 98 24 24 24 02", "AF-I Nikkor 400mm f/2.8D IF-ED"},
-    {"30 48 98 98 24 24 E1 02", "AF-I Nikkor 400mm f/2.8D IF-ED + TC-17E"},
-    {"30 48 98 98 24 24 F1 02", "AF-I Nikkor 400mm f/2.8D IF-ED + TC-14E"},
-    {"30 48 98 98 24 24 F2 02", "AF-I Nikkor 400mm f/2.8D IF-ED + TC-20E"},
-    {"31 54 56 56 24 24 25 02", "AF Micro-Nikkor 60mm f/2.8D"},
-    {"32 53 64 64 24 24 35 02", "Tamron SP AF 90mm f/2.8 [Di] Macro 1:1 (172E/272E)"},
-    {"32 54 50 50 24 24 35 02", "Sigma Macro 50mm f/2.8 EX DG"},
-    {"32 54 6A 6A 24 24 35 02", "AF Micro-Nikkor 105mm f/2.8D"},
-    {"32 54 6A 6A 24 24 35 02", "Sigma Macro 105mm f/2.8 EX DG"},
-    {"33 48 2D 2D 24 24 31 02", "AF Nikkor 18mm f/2.8D"},
-    {"33 54 3C 5E 24 24 62 02", "Tamron SP AF 28-75mm f/2.8 XR Di LD Aspherical (IF) Macro (A09)"},
-    {"34 48 29 29 24 24 32 02", "AF Fisheye Nikkor 16mm f/2.8D"},
-    {"35 3C A0 A0 30 30 33 02", "AF-I Nikkor 500mm f/4D IF-ED"},
-    {"35 3C A0 A0 30 30 E1 02", "AF-I Nikkor 500mm f/4D IF-ED + TC-17E"},
-    {"35 3C A0 A0 30 30 F1 02", "AF-I Nikkor 500mm f/4D IF-ED + TC-14E"},
-    {"35 3C A0 A0 30 30 F2 02", "AF-I Nikkor 500mm f/4D IF-ED + TC-20E"},
-    {"36 48 37 37 24 24 34 02", "AF Nikkor 24mm f/2.8D"},
-    {"37 48 30 30 24 24 36 02", "AF Nikkor 20mm f/2.8D"},
-    {"38 4C 62 62 14 14 37 02", "AF Nikkor 85mm f/1.8D"},
-    {"3A 40 3C 5C 2C 34 39 02", "AF Zoom-Nikkor 28-70mm f/3.5-4.5D"},
-    {"3B 48 44 5C 24 24 3A 02", "AF Zoom-Nikkor 35-70mm f/2.8D N"},
-    {"3C 48 60 80 24 24 3B 02", "AF Zoom-Nikkor 80-200mm f/2.8D ED"},
-    {"3D 3C 44 60 30 3C 3E 02", "AF Zoom-Nikkor 35-80mm f/4-5.6D"},
-    {"3E 48 3C 3C 24 24 3D 02", "AF Nikkor 28mm f/2.8D"},
-    {"3F 40 44 6A 2C 34 45 02", "AF Zoom-Nikkor 35-105mm f/3.5-4.5D"},
-    {"41 48 7C 7C 24 24 43 02", "AF Nikkor 180mm f/2.8D IF-ED"},
-    {"42 54 44 44 18 18 44 02", "AF Nikkor 35mm f/2D"},
-    {"43 54 50 50 0C 0C 46 02", "AF Nikkor 50mm f/1.4D"},
-    {"44 44 60 80 34 3C 47 02", "AF Zoom-Nikkor 80-200mm f/4.5-5.6D"},
-    {"45 3D 3C 60 2C 3C 48 02", "Tamron AF 28-80mm f/3.5-5.6 Aspherical (177D)"},
-    {"45 40 3C 60 2C 3C 48 02", "AF Zoom-Nikkor 28-80mm f/3.5-5.6D"},
-    {"45 41 37 72 2C 3C 48 02", "Tamron SP AF 24-135mm f/3.5-5.6 AD Aspherical (IF) Macro (190D)"},
-    {"46 3C 44 60 30 3C 49 02", "AF Zoom-Nikkor 35-80mm f/4-5.6D N"},
-    {"47 42 37 50 2A 34 4A 02", "AF Zoom-Nikkor 24-50mm f/3.3-4.5D"},
-    {"48 38 1F 37 34 3C 4B 06", "Sigma 12-24mm f/4.5-5.6 EX DG Aspherical HSM"},
-    {"48 3C 19 31 30 3C 4B 06", "Sigma 10-20mm f/4-5.6 EX DC HSM"},
-    {"48 3C 50 A0 30 40 4B 02", "Sigma 50-500mm f/4-6.3 EX APO RF HSM"},
-    {"48 3C 8E B0 3C 3C 4B 02", "Sigma APO 300-800mm f/5.6 EX DG HSM"},
-    {"48 3C B0 B0 3C 3C 4B 02", "Sigma APO 800mm f/5.6 EX HSM"},
-    {"48 44 A0 A0 34 34 4B 02", "Sigma APO 500mm f/4.5 EX HSM"},
-    {"48 48 24 24 24 24 4B 02", "Sigma 14mm f/2.8 EX Aspherical HSM"},
-    {"48 48 2B 44 24 30 4B 06", "Sigma 17-35mm f/2.8-4 EX DG  Aspherical HSM"},
-    {"48 48 68 8E 30 30 4B 02", "Sigma APO 100-300mm f/4 EX IF HSM"},
-    {"48 48 76 76 24 24 4B 06", "Sigma APO Macro 150mm f/2.8 EX DG HSM"},
-    {"48 48 8E 8E 24 24 4B 02", "AF-S Nikkor 300mm f/2.8D IF-ED"},
-    {"48 48 8E 8E 24 24 E1 02", "AF-S Nikkor 300mm f/2.8D IF-ED + TC-17E"},
-    {"48 48 8E 8E 24 24 F1 02", "AF-S Nikkor 300mm f/2.8D IF-ED + TC-14E"},
-    {"48 48 8E 8E 24 24 F2 02", "AF-S Nikkor 300mm f/2.8D IF-ED + TC-20E"},
-    {"48 4C 7C 7C 2C 2C 4B 02", "Sigma APO Macro 180mm f/3.5 EX DG HSM"},
-    {"48 4C 7D 7D 2C 2C 4B 02", "Sigma APO Macro 180mm f/3.5 EX DG HSM"},
-    {"48 54 3E 3E 0C 0C 4B 06", "Sigma 30mm f/1.4 EX DC HSM"},
-    {"48 54 5C 80 24 24 4B 02", "Sigma 70-200mm f/2.8 EX APO IF HSM"},
-    {"48 54 6F 8E 24 24 4B 02", "Sigma APO 120-300mm f/2.8 EX DG HSM"},
-    {"48 54 8E 8E 24 24 4B 02", "Sigma APO 300mm f/2.8 EX DG HSM"},
-    {"49 3C A6 A6 30 30 4C 02", "AF-S Nikkor 600mm f/4D IF-ED"},
-    {"49 3C A6 A6 30 30 E1 02", "AF-S Nikkor 600mm f/4D IF-ED + TC-17E"},
-    {"49 3C A6 A6 30 30 F1 02", "AF-S Nikkor 600mm f/4D IF-ED + TC-14E"},
-    {"49 3C A6 A6 30 30 F2 02", "AF-S Nikkor 600mm f/4D IF-ED + TC-20E"},
-    {"4A 40 11 11 2C 0C 4D 02", "Samyang 8mm f/3.5 Fish-Eye CS"},
-    {"4A 48 1E 1E 24 0C 4D 02", "Samyang 12mm f/2.8 ED AS NCS Fish-Eye"},
-    {"4A 48 24 24 24 0C 4D 02", "Samyang 10mm f/2.8 ED AS NCS CS"},
-    {"4A 48 24 24 24 0C 4D 02", "Samyang AE 14mm f/2.8 ED AS IF UMC"},
-    {"4A 4C 24 24 1E 6C 4D 06", "Samyang 14mm f/2.4 Premium"},
-    {"4A 54 29 29 18 0C 4D 02", "Samyang 16mm f/2.0 ED AS UMC CS"},
-    {"4A 54 62 62 0C 0C 4D 02", "AF Nikkor 85mm f/1.4D IF"},
-    {"4A 58 30 30 14 0C 4D 02", "Rokinon 20mm f/1.8 ED AS UMC"},
-    {"4A 60 36 36 0C 0C 4D 02", "Samyang 24mm f/1.4 ED AS UMC"},
-    {"4A 60 44 44 0C 0C 4D 02", "Samyang 35mm f/1.4 AS UMC"},
-    {"4A 60 62 62 0C 0C 4D 02", "Samyang AE 85mm f/1.4 AS IF UMC"},
-    {"4B 3C A0 A0 30 30 4E 02", "AF-S Nikkor 500mm f/4D IF-ED"},
-    {"4B 3C A0 A0 30 30 E1 02", "AF-S Nikkor 500mm f/4D IF-ED + TC-17E"},
-    {"4B 3C A0 A0 30 30 F1 02", "AF-S Nikkor 500mm f/4D IF-ED + TC-14E"},
-    {"4B 3C A0 A0 30 30 F2 02", "AF-S Nikkor 500mm f/4D IF-ED + TC-20E"},
-    {"4C 40 37 6E 2C 3C 4F 02", "AF Zoom-Nikkor 24-120mm f/3.5-5.6D IF"},
-    {"4D 3E 3C 80 2E 3C 62 02", "Tamron AF 28-200mm f/3.8-5.6 XR Aspherical (IF) Macro (A03N)"},
-    {"4D 40 3C 80 2C 3C 62 02", "AF Zoom-Nikkor 28-200mm f/3.5-5.6D IF"},
-    {"4D 41 3C 8E 2B 40 62 02", "Tamron AF 28-300mm f/3.5-6.3 XR Di LD Aspherical (IF) (A061)"},
-    {"4D 41 3C 8E 2C 40 62 02", "Tamron AF 28-300mm f/3.5-6.3 XR LD Aspherical (IF) (185D)"},
-    {"4E 48 72 72 18 18 51 02", "AF DC-Nikkor 135mm f/2D"},
-    {"4F 40 37 5C 2C 3C 53 06", "IX-Nikkor 24-70mm f/3.5-5.6"},
-    {"50 48 56 7C 30 3C 54 06", "IX-Nikkor 60-180mm f/4-5.6"},
-    {"52 54 44 44 18 18 00 00", "Zeiss Milvus 35mm f/2"},
-    {"53 48 60 80 24 24 57 02", "AF Zoom-Nikkor 80-200mm f/2.8D ED"},
-    {"53 48 60 80 24 24 60 02", "AF Zoom-Nikkor 80-200mm f/2.8D ED"},
-    {"53 54 50 50 0C 0C 00 00", "Zeiss Milvus 50mm f/1.4"},
-    {"54 44 5C 7C 34 3C 58 02", "AF Zoom-Micro Nikkor 70-180mm f/4.5-5.6D ED"},
-    {"54 44 5C 7C 34 3C 61 02", "AF Zoom-Micro Nikkor 70-180mm f/4.5-5.6D ED"},
-    {"54 54 50 50 18 18 00 00", "Zeiss Milvus 50mm f/2 Macro"},
-    {"55 54 62 62 0C 0C 00 00", "Zeiss Milvus 85mm f/1.4"},
-    {"56 3C 5C 8E 30 3C 1C 02", "Sigma 70-300mm f/4-5.6 APO Macro Super II"},
-    {"56 48 5C 8E 30 3C 5A 02", "AF Zoom-Nikkor 70-300mm f/4-5.6D ED"},
-    {"56 54 68 68 18 18 00 00", "Zeiss Milvus 100mm f/2 Macro"},
-    {"59 48 98 98 24 24 5D 02", "AF-S Nikkor 400mm f/2.8D IF-ED"},
-    {"59 48 98 98 24 24 E1 02", "AF-S Nikkor 400mm f/2.8D IF-ED + TC-17E"},
-    {"59 48 98 98 24 24 F1 02", "AF-S Nikkor 400mm f/2.8D IF-ED + TC-14E"},
-    {"59 48 98 98 24 24 F2 02", "AF-S Nikkor 400mm f/2.8D IF-ED + TC-20E"},
-    {"5A 3C 3E 56 30 3C 5E 06", "IX-Nikkor 30-60mm f/4-5.6"},
-    {"5B 44 56 7C 34 3C 5F 06", "IX-Nikkor 60-180mm f/4.5-5.6"},
-    {"5D 48 3C 5C 24 24 63 02", "AF-S Zoom-Nikkor 28-70mm f/2.8D IF-ED"},
-    {"5E 48 60 80 24 24 64 02", "AF-S Zoom-Nikkor 80-200mm f/2.8D IF-ED"},
-    {"5F 40 3C 6A 2C 34 65 02", "AF Zoom-Nikkor 28-105mm f/3.5-4.5D IF"},
-    {"60 40 3C 60 2C 3C 66 02", "AF Zoom-Nikkor 28-80mm f/3.5-5.6D"},
-    {"61 44 5E 86 34 3C 67 02", "AF Zoom-Nikkor 75-240mm f/4.5-5.6D"},
-    {"63 48 2B 44 24 24 68 02", "AF-S Nikkor 17-35mm f/2.8D IF-ED"},
-    {"64 00 62 62 24 24 6A 02", "PC Micro-Nikkor 85mm f/2.8D"},
-    {"65 44 60 98 34 3C 6B 0A", "AF VR Zoom-Nikkor 80-400mm f/4.5-5.6D ED"},
-    {"66 40 2D 44 2C 34 6C 02", "AF Zoom-Nikkor 18-35mm f/3.5-4.5D IF-ED"},
-    {"67 48 37 62 24 30 6D 02", "AF Zoom-Nikkor 24-85mm f/2.8-4D IF"},
-    {"67 54 37 5C 24 24 1C 02", "Sigma 24-70mm f/2.8 EX DG Macro"},
-    {"68 42 3C 60 2A 3C 6E 06", "AF Zoom-Nikkor 28-80mm f/3.3-5.6G"},
-    {"69 47 5C 8E 30 3C 00 02", "Tamron AF 70-300mm f/4-5.6 Di LD Macro 1:2 (A17N)"},
-    {"69 48 5C 8E 30 3C 6F 02", "Tamron AF 70-300mm f/4-5.6 LD Macro 1:2 (572D/772D)"},
-    {"69 48 5C 8E 30 3C 6F 06", "AF Zoom-Nikkor 70-300mm f/4-5.6G"},
-    {"6A 48 8E 8E 30 30 70 02", "AF-S Nikkor 300mm f/4D IF-ED"},
-    {"6B 48 24 24 24 24 71 02", "AF Nikkor ED 14mm f/2.8D"},
-    {"6D 48 8E 8E 24 24 73 02", "AF-S Nikkor 300mm f/2.8D IF-ED II"},
-    {"6E 48 98 98 24 24 74 02", "AF-S Nikkor 400mm f/2.8D IF-ED II"},
-    {"6F 3C A0 A0 30 30 75 02", "AF-S Nikkor 500mm f/4D IF-ED II"},
-    {"70 3C A6 A6 30 30 76 02", "AF-S Nikkor 600mm f/4D IF-ED II"},
-    {"71 48 64 64 24 24 00 00", "Voigtlander APO-Skopar 90mm f/2.8 SL IIs"},
-    {"72 48 4C 4C 24 24 77 00", "Nikkor 45mm f/2.8 P"},
-    {"74 40 37 62 2C 34 78 06", "AF-S Zoom-Nikkor 24-85mm f/3.5-4.5G IF-ED"},
-    {"75 40 3C 68 2C 3C 79 06", "AF Zoom-Nikkor 28-100mm f/3.5-5.6G"},
-    {"76 58 50 50 14 14 7A 02", "AF Nikkor 50mm f/1.8D"},
-    {"77 44 60 98 34 3C 7B 0E", "Sigma 80-400mm f/4.5-5.6 APO DG D OS"},
-    {"77 44 61 98 34 3C 7B 0E", "Sigma 80-400mm f/4.5-5.6 EX OS"},
-    {"77 48 5C 80 24 24 7B 0E", "AF-S VR Zoom-Nikkor 70-200mm f/2.8G IF-ED"},
-    {"78 40 37 6E 2C 3C 7C 0E", "AF-S VR Zoom-Nikkor 24-120mm f/3.5-5.6G IF-ED"},
-    {"79 40 11 11 2C 2C 1C 06", "Sigma 8mm f/3.5 EX Circular Fisheye"},
-    {"79 40 3C 80 2C 3C 7F 06", "AF Zoom-Nikkor 28-200mm f/3.5-5.6G IF-ED"},
-    {"79 48 3C 5C 24 24 1C 06", "Sigma 28-70mm f/2.8 EX DG"},
-    {"79 48 5C 5C 24 24 1C 06", "Sigma Macro 70mm f/2.8 EX DG"},
-    {"79 54 31 31 0C 0C 4B 06", "Sigma 20mm f/1.4 DG HSM | A"},
-    {"7A 3B 53 80 30 3C 4B 06", "Sigma 55-200mm f/4-5.6 DC HSM"},
-    {"7A 3C 1F 37 30 30 7E 06", "AF-S DX Zoom-Nikkor 12-24mm f/4G IF-ED"},
-    {"7A 3C 1F 37 30 30 7E 06", "Tokina AT-X 124 AF PRO DX II (AF 12-24mm f/4)"},
-    {"7A 3C 1F 3C 30 30 7E 06", "Tokina AT-X 12-28 PRO DX (AF 12-28mm f/4)"},
-    {"7A 40 2D 50 2C 3C 4B 06", "Sigma 18-50mm f/3.5-5.6 DC HSM"},
-    {"7A 40 2D 80 2C 40 4B 0E", "Sigma 18-200mm f/3.5-6.3 DC OS HSM"},
-    {"7A 47 2B 5C 24 34 4B 06", "Sigma 17-70mm f/2.8-4.5 DC Macro Asp. IF HSM"},
-    {"7A 47 50 76 24 24 4B 06", "Sigma 50-150mm f/2.8 EX APO DC HSM"},
-    {"7A 48 1C 29 24 24 7E 06", "Tokina AT-X 116 PRO DX II (AF 11-16mm f/2.8)"},
-    {"7A 48 1C 30 24 24 7E 06", "Tokina AT-X 11-20 f/2.8 PRO DX (AF 11-20mm f/2.8)"},
-    {"7A 48 2B 5C 24 34 4B 06", "Sigma 17-70mm f/2.8-4.5 DC Macro Asp. IF HSM"},
-    {"7A 48 2D 50 24 24 4B 06", "Sigma 18-50mm f/2.8 EX DC Macro"},
-    {"7A 48 5C 80 24 24 4B 06", "Sigma 70-200mm f/2.8 EX APO DG Macro HSM II"},
-    {"7A 54 6E 8E 24 24 4B 02", "Sigma APO 120-300mm f/2.8 EX DG HSM"},
-    {"7B 48 37 44 18 18 4B 06", "Sigma 24-35mm f/2.0 DG HSM | A"},
-    {"7B 48 80 98 30 30 80 0E", "AF-S VR Zoom-Nikkor 200-400mm f/4G IF-ED"},
-    {"7C 54 2B 50 24 24 00 06", "Tamron SP AF 17-50mm f/2.8 XR Di II LD Aspherical (IF) (A16)"},
-    {"7D 48 2B 53 24 24 82 06", "AF-S DX Zoom-Nikkor 17-55mm f/2.8G IF-ED"},
-    {"7F 40 2D 5C 2C 34 84 06", "AF-S DX Zoom-Nikkor 18-70mm f/3.5-4.5G IF-ED"},
-    {"7F 48 2B 5C 24 34 1C 06", "Sigma 17-70mm f/2.8-4.5 DC Macro Asp. IF"},
-    {"7F 48 2D 50 24 24 1C 06", "Sigma 18-50mm f/2.8 EX DC Macro"},
-    {"80 48 1A 1A 24 24 85 06", "AF DX Fisheye-Nikkor 10.5mm f/2.8G ED"},
-    {"80 48 1C 29 24 24 7A 06", "Tokina atx-i 11-16mm f/2.8 CF"},
-    {"81 34 76 A6 38 40 4B 0E", "Sigma 150-600mm f/5-6.3 DG OS HSM | S"},
-    {"81 54 80 80 18 18 86 0E", "AF-S VR Nikkor 200mm f/2G IF-ED"},
-    {"82 34 76 A6 38 40 4B 0E", "Sigma 150-600mm f/5-6.3 DG OS HSM | C"},
-    {"82 48 8E 8E 24 24 87 0E", "AF-S VR Nikkor 300mm f/2.8G IF-ED"},
-    {"83 00 B0 B0 5A 5A 88 04", "FSA-L2, EDG 65, 800mm f/13 G"},
-    {"87 2C 2D 8E 2C 40 4B 0E", "Sigma 18-300mm f/3.5-6.3 DC Macro HSM"},
-    {"88 54 50 50 0C 0C 4B 06", "Sigma 50mm f/1.4 DG HSM | A"},
-    {"89 30 2D 80 2C 40 4B 0E", "Sigma 18-200mm f/3.5-6.3 DC Macro OS HS | C"},
-    {"89 3C 53 80 30 3C 8B 06", "AF-S DX Zoom-Nikkor 55-200mm f/4-5.6G ED"},
-    {"8A 3C 37 6A 30 30 4B 0E", "Sigma 24-105mm f/4 DG OS HSM"},
-    {"8A 54 6A 6A 24 24 8C 0E", "AF-S VR Micro-Nikkor 105mm f/2.8G IF-ED"},
-    {"8B 40 2D 80 2C 3C 8D 0E", "AF-S DX VR Zoom-Nikkor 18-200mm f/3.5-5.6G IF-ED"},
-    {"8B 40 2D 80 2C 3C FD 0E", "AF-S DX VR Zoom-Nikkor 18-200mm f/3.5-5.6G IF-ED [II]"},
-    {"8B 48 1C 30 24 24 85 06", "Tokina AT-X 11-20 f/2.8 PRO DX (AF 11-20mm f/2.8)"},
-    {"8B 4C 2D 44 14 14 4B 06", "Sigma 18-35mm f/1.8 DC HSM"},
-    {"8C 40 2D 53 2C 3C 8E 06", "AF-S DX Zoom-Nikkor 18-55mm f/3.5-5.6G ED"},
-    {"8C 48 29 3C 24 24 86 06", "Tokina opera 16-28mm f/2.8 FF"},
-    {"8D 44 5C 8E 34 3C 8F 0E", "AF-S VR Zoom-Nikkor 70-300mm f/4.5-5.6G IF-ED"},
-    {"8D 48 6E 8E 24 24 4B 0E", "Sigma 120-300mm f/2.8 DG OS HSM Sports"},
-    {"8E 3C 2B 5C 24 30 4B 0E", "Sigma 17-70mm f/2.8-4 DC Macro OS HSM | C"},
-    {"8F 40 2D 72 2C 3C 91 06", "AF-S DX Zoom-Nikkor 18-135mm f/3.5-5.6G IF-ED"},
-    {"8F 48 2B 50 24 24 4B 0E", "Sigma 17-50mm f/2.8 EX DC OS HSM"},
-    {"90 3B 53 80 30 3C 92 0E", "AF-S DX VR Zoom-Nikkor 55-200mm f/4-5.6G IF-ED"},
-    {"90 40 2D 80 2C 40 4B 0E", "Sigma 18-200mm f/3.5-6.3 II DC OS HSM"},
-    {"91 54 44 44 0C 0C 4B 06", "Sigma 35mm f/1.4 DG HSM"},
-    {"92 2C 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC Macro OS HSM"},
-    {"92 48 24 37 24 24 94 06", "AF-S Zoom-Nikkor 14-24mm f/2.8G ED"},
-    {"93 48 37 5C 24 24 95 06", "AF-S Zoom-Nikkor 24-70mm f/2.8G ED"},
-    {"94 40 2D 53 2C 3C 96 06", "AF-S DX Zoom-Nikkor 18-55mm f/3.5-5.6G ED II"},
-    {"94 48 7C 7C 24 24 4B 0E", "Sigma APO Macro 180mm f/2.8 EX DG OS HSM"},
-    {"95 00 37 37 2C 2C 97 06", "PC-E Nikkor 24mm f/3.5D ED"},
-    {"95 4C 37 37 2C 2C 97 02", "PC-E Nikkor 24mm f/3.5D ED"},
-    {"96 38 1F 37 34 3C 4B 06", "Sigma 12-24mm f/4.5-5.6 II DG HSM"},
-    {"96 48 98 98 24 24 98 0E", "AF-S VR Nikkor 400mm f/2.8G ED"},
-    {"97 3C A0 A0 30 30 99 0E", "AF-S VR Nikkor 500mm f/4G ED"},
-    {"97 48 6A 6A 24 24 4B 0E", "Sigma Macro 105mm f/2.8 EX DG OS HSM"},
-    {"98 3C A6 A6 30 30 9A 0E", "AF-S VR Nikkor 600mm f/4G ED"},
-    {"98 48 50 76 24 24 4B 0E", "Sigma 50-150mm f/2.8 EX APO DC OS HSM"},
-    {"99 40 29 62 2C 3C 9B 0E", "AF-S DX VR Zoom-Nikkor 16-85mm f/3.5-5.6G ED"},
-    {"99 48 76 76 24 24 4B 0E", "Sigma APO Macro 150mm f/2.8 EX DG OS HSM"},
-    {"9A 40 2D 53 2C 3C 9C 0E", "AF-S DX VR Zoom-Nikkor 18-55mm f/3.5-5.6G"},
-    {"9A 4C 50 50 14 14 9C 06", "Yongnuo YN50mm f/1.8N"},
-    {"9B 00 4C 4C 24 24 9D 06", "PC-E Micro Nikkor 45mm f/2.8D ED"},
-    {"9B 54 4C 4C 24 24 9D 02", "PC-E Micro Nikkor 45mm f/2.8D ED"},
-    {"9B 54 62 62 0C 0C 4B 06", "Sigma 85mm f/1.4 EX DG HSM"},
-    {"9C 48 5C 80 24 24 4B 0E", "Sigma 70-200mm f/2.8 EX DG OS HSM"},
-    {"9C 54 56 56 24 24 9E 06", "AF-S Micro Nikkor 60mm f/2.8G ED"},
-    {"9D 00 62 62 24 24 9F 06", "PC-E Micro Nikkor 85mm f/2.8D"},
-    {"9D 48 2B 50 24 24 4B 0E", "Sigma 17-50mm f/2.8 EX DC OS HSM"},
-    {"9D 54 62 62 24 24 9F 02", "PC-E Micro Nikkor 85mm f/2.8D"},
-    {"9E 38 11 29 34 3C 4B 06", "Sigma 8-16mm f/4.5-5.6 DC HSM"},
-    {"9E 40 2D 6A 2C 3C A0 0E", "AF-S DX VR Zoom-Nikkor 18-105mm f/3.5-5.6G ED"},
-    {"9F 37 50 A0 34 40 4B 0E", "Sigma 50-500mm f/4.5-6.3 DG OS HSM"},
-    {"9F 48 48 48 24 24 A1 06", "Yongnuo YN40mm f/2.8N"},
-    {"9F 54 68 68 18 18 A2 06", "Yongnuo YN100mm f/2N"},
-    {"9F 58 44 44 14 14 A1 06", "AF-S DX Nikkor 35mm f/1.8G"},
-    {"A0 37 5C 8E 34 3C A2 06", "Sony FE 70-300mm f/4.5-5.6 G OSS"},
-    {"A0 40 2D 53 2C 3C CA 0E", "AF-P DX Nikkor 18-55mm f/3.5-5.6G VR"},
-    {"A0 40 2D 53 2C 3C CA 8E", "AF-P DX Nikkor 18-55mm f/3.5-5.6G"},
-    {"A0 40 2D 74 2C 3C BB 0E", "AF-S DX Nikkor 18-140mm f/3.5-5.6G ED VR"},
-    {"A0 48 2A 5C 24 30 4B 0E", "Sigma 17-70mm f/2.8-4 DC Macro OS HSM"},
-    {"A0 54 50 50 0C 0C A2 06", "AF-S Nikkor 50mm f/1.4G"},
-    {"A0 56 44 44 14 14 A2 06", "Sony FE 35mm f/1.8"},
-    {"A1 40 18 37 2C 34 A3 06", "AF-S DX Nikkor 10-24mm f/3.5-4.5G ED"},
-    {"A1 40 2D 53 2C 3C CB 86", "AF-P DX Nikkor 18-55mm f/3.5-5.6G"},
-    {"A1 41 19 31 2C 2C 4B 06", "Sigma 10-20mm f/3.5 EX DC HSM"},
-    {"A1 48 6E 8E 24 24 DB 4E", "AF-S Nikkor 120-300mm f/2.8E FL ED SR VR"},
-    {"A1 54 55 55 0C 0C BC 06", "AF-S Nikkor 58mm f/1.4G"},
-    {"A2 38 5C 8E 34 40 CD 86", "AF-P DX Nikkor 70-300mm f/4.5-6.3G VR"},
-    {"A2 40 2D 53 2C 3C BD 0E", "AF-S DX Nikkor 18-55mm f/3.5-5.6G VR II"},
-    {"A2 48 5C 80 24 24 A4 0E", "AF-S Nikkor 70-200mm f/2.8G ED VR II"},
-    {"A3 38 5C 8E 34 40 CE 0E", "AF-P DX Nikkor 70-300mm f/4.5-6.3G ED"},
-    {"A3 38 5C 8E 34 40 CE 8E", "AF-P DX Nikkor 70-300mm f/4.5-6.3G ED VR"},
-    {"A3 3C 29 44 30 30 A5 0E", "AF-S Nikkor 16-35mm f/4G ED VR"},
-    {"A3 3C 5C 8E 30 3C 4B 0E", "Sigma 70-300mm f/4-5.6 DG OS"},
-    {"A4 40 2D 8E 2C 40 BF 0E", "AF-S DX Nikkor 18-300mm f/3.5-6.3G ED VR"},
-    {"A4 47 2D 50 24 34 4B 0E", "Sigma 18-50mm f/2.8-4.5 DC OS HSM"},
-    {"A4 48 5C 80 24 24 CF 0E", "AF-S Nikkor 70-200mm f/2.8E FL ED VR"},
-    {"A4 48 5C 80 24 24 CF 4E", "AF-S Nikkor 70-200mm f/2.8E FL ED VR"},
-    {"A4 54 37 37 0C 0C A6 06", "AF-S Nikkor 24mm f/1.4G ED"},
-    {"A5 40 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC OS HSM"},
-    {"A5 40 3C 8E 2C 3C A7 0E", "AF-S Nikkor 28-300mm f/3.5-5.6G ED VR"},
-    {"A5 4C 44 44 14 14 C0 06", "AF-S Nikkor 35mm f/1.8G ED"},
-    {"A5 54 6A 6A 0C 0C D0 06", "AF-S Nikkor 105mm f/1.4E ED"},
-    {"A5 54 6A 6A 0C 0C D0 46", "AF-S Nikkor 105mm f/1.4E ED"},
-    {"A6 48 2F 2F 30 30 D1 06", "PC Nikkor 19mm f/4E ED"},
-    {"A6 48 2F 2F 30 30 D1 46", "PC Nikkor 19mm f/4E ED"},
-    {"A6 48 37 5C 24 24 4B 06", "Sigma 24-70mm f/2.8 IF EX DG HSM"},
-    {"A6 48 8E 8E 24 24 A8 0E", "AF-S Nikkor 300mm f/2.8G IF-ED VR II"},
-    {"A6 48 98 98 24 24 C1 0E", "AF-S Nikkor 400mm f/2.8E FL ED VR"},
-    {"A7 3C 53 80 30 3C C2 0E", "AF-S DX Nikkor 55-200mm f/4-5.6G ED VR II"},
-    {"A7 40 11 26 2C 34 D2 06", "AF-S Fisheye Nikkor 8-15mm f/3.5-4.5E ED"},
-    {"A7 40 11 26 2C 34 D2 46", "AF-S Fisheye Nikkor 8-15mm f/3.5-4.5E ED"},
-    {"A7 49 80 A0 24 24 4B 06", "Sigma APO 200-500mm f/2.8 EX DG"},
-    {"A7 4B 62 62 2C 2C A9 0E", "AF-S DX Micro Nikkor 85mm f/3.5G ED VR"},
-    {"A8 38 18 30 34 3C D3 0E", "AF-P DX Nikkor 10-20mm f/4.5-5.6G VR"},
-    {"A8 38 18 30 34 3C D3 8E", "AF-P DX Nikkor 10-20mm f/4.5-5.6G VR"},
-    {"A8 48 80 98 30 30 AA 0E", "AF-S Zoom-Nikkor 200-400mm f/4G IF-ED VR II"},
-    {"A8 48 8E 8E 30 30 C3 0E", "AF-S Nikkor 300mm f/4E PF ED VR"},
-    {"A8 48 8E 8E 30 30 C3 4E", "AF-S Nikkor 300mm f/4E PF ED VR"},
-    {"A9 48 7C 98 30 30 D4 0E", "AF-S Nikkor 180-400mm f/4E TC1.4 FL ED VR"},
-    {"A9 48 7C 98 30 30 D4 4E", "AF-S Nikkor 180-400mm f/4E TC1.4 FL ED VR"},
-    {"A9 4C 31 31 14 14 C4 06", "AF-S Nikkor 20mm f/1.8G ED"},
-    {"A9 54 80 80 18 18 AB 0E", "AF-S Nikkor 200mm f/2G ED VR II"},
-    {"AA 3C 37 6E 30 30 AC 0E", "AF-S Nikkor 24-120mm f/4G ED VR"},
-    {"AA 48 37 5C 24 24 C5 0E", "AF-S Nikkor 24-70mm f/2.8E ED VR"},
-    {"AA 48 37 5C 24 24 C5 4E", "AF-S Nikkor 24-70mm f/2.8E ED VR"},
-    {"AA 48 88 A4 3C 3C D5 0E", "AF-S Nikkor 180-400mm f/4E TC1.4 FL ED VR + 1.4x TC"},
-    {"AA 48 88 A4 3C 3C D5 4E", "AF-S Nikkor 180-400mm f/4E TC1.4 FL ED VR + 1.4x TC"},
-    {"AB 3C A0 A0 30 30 C6 4E", "AF-S Nikkor 500mm f/4E FL ED VR"},
-    {"AB 44 5C 8E 34 3C D6 0E", "AF-P Nikkor 70-300mm f/4.5-5.6E ED VR"},
-    {"AB 44 5C 8E 34 3C D6 4E", "AF-P Nikkor 70-300mm f/4.5-5.6E ED VR"},
-    {"AB 44 5C 8E 34 3C D6 CE", "AF-P Nikkor 70-300mm f/4.5-5.6E ED VR"},
-    {"AC 38 53 8E 34 3C AE 0E", "AF-S DX Nikkor 55-300mm f/4.5-5.6G ED VR"},
-    {"AC 3C A6 A6 30 30 C7 4E", "AF-S Nikkor 600mm f/4E FL ED VR"},
-    {"AC 54 3C 3C 0C 0C D7 06", "AF-S Nikkor 28mm f/1.4E ED"},
-    {"AC 54 3C 3C 0C 0C D7 46", "AF-S Nikkor 28mm f/1.4E ED"},
-    {"AD 3C 2D 8E 2C 3C AF 0E", "AF-S DX Nikkor 18-300mm f/3.5-5.6G ED VR"},
-    {"AD 3C A0 A0 3C 3C D8 0E", "AF-S Nikkor 500mm f/5.6E PF ED VR"},
-    {"AD 3C A0 A0 3C 3C D8 4E", "AF-S Nikkor 500mm f/5.6E PF ED VR"},
-    {"AD 48 28 60 24 30 C8 0E", "AF-S DX Nikkor 16-80mm f/2.8-4E ED VR"},
-    {"AD 48 28 60 24 30 C8 4E", "AF-S DX Nikkor 16-80mm f/2.8-4E ED VR"},
-    {"AE 3C 80 A0 3C 3C C9 0E", "AF-S Nikkor 200-500mm f/5.6E ED VR"},
-    {"AE 3C 80 A0 3C 3C C9 4E", "AF-S Nikkor 200-500mm f/5.6E ED VR"},
-    {"AE 54 62 62 0C 0C B0 06", "AF-S Nikkor 85mm f/1.4G"},
-    {"AF 4C 37 37 14 14 CC 06", "AF-S Nikkor 24mm f/1.8G ED"},
-    {"AF 54 44 44 0C 0C B1 06", "AF-S Nikkor 35mm f/1.4G"},
-    {"B0 4C 50 50 14 14 B2 06", "AF-S Nikkor 50mm f/1.8G"},
-    {"B1 48 48 48 24 24 B3 06", "AF-S DX Micro Nikkor 40mm f/2.8G"},
-    {"B2 48 5C 80 30 30 B4 0E", "AF-S Nikkor 70-200mm f/4G ED VR"},
-    {"B3 4C 62 62 14 14 B5 06", "AF-S Nikkor 85mm f/1.8G"},
-    {"B4 40 37 62 2C 34 B6 0E", "AF-S Zoom-Nikkor 24-85mm f/3.5-4.5G IF-ED VR"},
-    {"B5 4C 3C 3C 14 14 B7 06", "AF-S Nikkor 28mm f/1.8G"},
-    {"B6 3C B0 B0 3C 3C B8 0E", "AF-S VR Nikkor 800mm f/5.6E FL ED"},
-    {"B6 3C B0 B0 3C 3C B8 4E", "AF-S VR Nikkor 800mm f/5.6E FL ED"},
-    {"B6 48 37 56 24 24 1C 02", "Sigma 24-60mm f/2.8 EX DG"},
-    {"B7 44 60 98 34 3C B9 0E", "AF-S Nikkor 80-400mm f/4.5-5.6G ED VR"},
-    {"B8 40 2D 44 2C 34 BA 06", "AF-S Nikkor 18-35mm f/3.5-4.5G ED"},
-    {"BB 48 5C 80 24 24 4B 4E", "Sigma 70-200mm f/2.8 DG OS HSM | S"},
-    {"BF 3C 1B 1B 30 30 01 04", "Irix 11mm f/4 Firefly"},
-    {"BF 4E 26 26 1E 1E 01 04", "Irix 15mm f/2.4 Firefly"},
-    {"C1 48 24 37 24 24 4B 46", "Sigma 14-24mm f/2.8 DG HSM | A"},
-    {"C2 4C 24 24 14 14 4B 06", "Sigma 14mm f/1.8 DG HSM | A"},
-    {"C3 34 68 98 38 40 4B 4E", "Sigma 100-400mm f/5-6.3 DG OS HSM | C"},
-    {"C4 4C 73 73 14 14 4B 46", "Sigma 135mm f/1.8 DG HSM | A"},
-    {"C8 54 44 44 0D 0D DF 46", "Tamron SP 35mm f/1.4 Di USD (F045)"},
-    {"C8 54 62 62 0C 0C 4B 06", "Sigma 85mm f/1.4 DG HSM | A"},
-    {"C8 54 62 62 0C 0C 4B 46", "Sigma 85mm f/1.4 DG HSM | A"},
-    {"C9 3C 44 76 25 31 DF 4E", "Tamron 35-150mm f/2.8-4 Di VC OSD (A043)"},
-    {"C9 48 37 5C 24 24 4B 4E", "Sigma 24-70mm f/2.8 DG OS HSM | A"},
-    {"CA 3C 1F 37 30 30 4B 46", "Sigma 12-24mm f/4 DG HSM | A"},
-    {"CA 48 27 3E 24 24 DF 4E", "Tamron SP 15-30mm f/2.8 Di VC USD G2 (A041)"},
-    {"CB 3C 2B 44 24 31 DF 46", "Tamron 17-35mm f/2.8-4 Di OSD (A037)"},
-    {"CC 44 68 98 34 41 DF 0E", "Tamron 100-400mm f/4.5-6.3 Di VC USD"},
-    {"CC 4C 50 68 14 14 4B 06", "Sigma 50-100mm f/1.8 DC HSM | A"},
-    {"CD 3D 2D 70 2E 3C 4B 0E", "Sigma 18-125mm f/3.8-5.6 DC OS HSM"},
-    {"CE 34 76 A0 38 40 4B 0E", "Sigma 150-500mm f/5-6.3 DG OS APO HSM"},
-    {"CE 47 37 5C 25 25 DF 4E", "Tamron SP 24-70mm f/2.8 Di VC USD G2 (A032)"},
-    {"CF 38 6E 98 34 3C 4B 0E", "Sigma APO 120-400mm f/4.5-5.6 DG OS HSM"},
-    {"CF 47 5C 8E 31 3D DF 0E", "Tamron SP 70-300mm f/4-5.6 Di VC USD (A030)"},
-    {"D2 3C 8E B0 3C 3C 4B 02", "Sigma APO 300-800mm f/5.6 EX DG HSM"},
-    {"DB 40 11 11 2C 2C 1C 06", "Sigma 8mm f/3.5 EX DG Circular Fisheye"},
-    {"DC 48 19 19 24 24 4B 06", "Sigma 10mm f/2.8 EX DC HSM Fisheye"},
-    {"DE 54 50 50 0C 0C 4B 06", "Sigma 50mm f/1.4 EX DG HSM"},
-    {"E0 3C 5C 8E 30 3C 4B 06", "Sigma 70-300mm f/4-5.6 APO DG Macro HSM"},
-    {"E0 40 2D 98 2C 41 DF 4E", "Tamron 18-400mm f/3.5-6.3 Di II VC HLD (B028)"},
-    {"E1 40 19 36 2C 35 DF 4E", "Tamron 10-24mm f/3.5-4.5 Di II VC HLD (B023)"},
-    {"E1 58 37 37 14 14 1C 02", "Sigma 24mm f/1.8 EX DG Aspherical Macro"},
-    {"E2 47 5C 80 24 24 DF 4E", "Tamron SP 70-200mm f/2.8 Di VC USD G2 (A025)"},
-    {"E3 40 76 A6 38 40 DF 0E", "Tamron SP 150-600mm f/5-6.3 Di VC USD G2 (A022)"},
-    {"E3 40 76 A6 38 40 DF 4E", "Tamron SP 150-600mm f/5-6.3 Di VC USD G2"},
-    {"E3 54 50 50 24 24 35 02", "Sigma Macro 50mm f/2.8 EX DG"},
-    {"E4 54 64 64 24 24 DF 0E", "Tamron SP 90mm f/2.8 Di VC USD Macro 1:1 (F017)"},
-    {"E5 4C 62 62 14 14 C9 4E", "Tamron SP 85mm f/1.8 Di VC USD (F016)"},
-    {"E5 54 6A 6A 24 24 35 02", "Sigma Macro 105mm f/2.8 EX DG"},
-    {"E6 40 2D 80 2C 40 DF 0E", "Tamron 18-200mm f/3.5-6.3 Di II VC (B018)"},
-    {"E6 41 3C 8E 2C 40 1C 02", "Sigma 28-300mm f/3.5-6.3 DG Macro"},
-    {"E7 4C 4C 4C 14 14 DF 0E", "Tamron SP 45mm f/1.8 Di VC USD (F013)"},
-    {"E8 4C 44 44 14 14 DF 0E", "Tamron SP 35mm f/1.8 Di VC USD (F012)"},
-    {"E9 48 27 3E 24 24 DF 0E", "Tamron SP 15-30mm f/2.8 Di VC USD (A012)"},
-    {"E9 54 37 5C 24 24 1C 02", "Sigma 24-70mm f/2.8 EX DG Macro"},
-    {"EA 40 29 8E 2C 40 DF 0E", "Tamron 16-300mm f/3.5-6.3 Di II VC PZD (B016)"},
-    {"EA 48 27 27 24 24 1C 02", "Sigma 15mm f/2.8 EX Diagonal Fisheye"},
-    {"EB 40 76 A6 38 40 DF 0E", "Tamron SP AF 150-600mm f/5-6.3 VC USD (A011)"},
-    {"EC 3E 3C 8E 2C 40 DF 0E", "Tamron 28-300mm f/3.5-6.3 Di VC PZD A010"},
-    {"ED 40 2D 80 2C 40 4B 0E", "Sigma 18-200mm f/3.5-6.3 DC OS HSM"},
-    {"EE 48 5C 80 24 24 4B 06", "Sigma 70-200mm f/2.8 EX APO DG Macro HSM II"},
-    {"F0 38 1F 37 34 3C 4B 06", "Sigma 12-24mm f/4.5-5.6 EX DG Aspherical HSM"},
-    {"F0 3F 2D 8A 2C 40 DF 0E", "Tamron AF 18-270mm f/3.5-6.3 Di II VC PZD (B008)"},
-    {"F1 44 A0 A0 34 34 4B 02", "Sigma APO 500mm f/4.5 EX DG HSM"},
-    {"F1 47 5C 8E 30 3C DF 0E", "Tamron SP 70-300mm f/4-5.6 Di VC USD (A005)"},
-    {"F3 48 68 8E 30 30 4B 02", "Sigma APO 100-300mm f/4 EX IF HSM"},
-    {"F3 54 2B 50 24 24 84 0E", "Tamron SP AF 17-50mm f/2.8 XR Di II VC LD Aspherical (IF) (B005)"},
-    {"F4 4C 7C 7C 2C 2C 4B 02", "Sigma APO Macro 180mm f/3.5 EX DG HSM"},
-    {"F4 54 56 56 18 18 84 06", "Tamron SP AF 60mm f/2.0 Di II Macro 1:1 (G005)"},
-    {"F5 40 2C 8A 2C 40 40 0E", "Tamron AF 18-270mm f/3.5-6.3 Di II VC LD Aspherical (IF) Macro (B003)"},
-    {"F5 48 76 76 24 24 4B 06", "Sigma APO Macro 150mm f/2.8 EX DG HSM"},
-    {"F6 3F 18 37 2C 34 84 06", "Tamron SP AF 10-24mm f/3.5-4.5 Di II LD Aspherical (IF) (B001)"},
-    {"F6 3F 18 37 2C 34 DF 06", "Tamron SP AF 10-24mm f/3.5-4.5 Di II LD Aspherical (IF) (B001)"},
-    {"F6 48 2D 50 24 24 4B 06", "Sigma 18-50mm f/2.8 EX DC Macro"},
-    {"F7 53 5C 80 24 24 40 06", "Tamron SP AF 70-200mm f/2.8 Di LD (IF) Macro (A001)"},
-    {"F7 53 5C 80 24 24 84 06", "Tamron SP AF 70-200mm f/2.8 Di LD (IF) Macro (A001)"},
-    {"F8 54 3E 3E 0C 0C 4B 06", "Sigma 30mm f/1.4 EX DC HSM"},
-    {"F8 54 64 64 24 24 DF 06", "Tamron SP AF 90mm f/2.8 Di Macro 1:1 (272NII)"},
-    {"F8 55 64 64 24 24 84 06", "Tamron SP AF 90mm f/2.8 Di Macro 1:1 (272NII)"},
-    {"F9 3C 19 31 30 3C 4B 06", "Sigma 10-20mm f/4-5.6 EX DC HSM"},
-    {"F9 40 3C 8E 2C 40 40 0E", "Tamron AF 28-300mm f/3.5-6.3 XR Di VC LD Aspherical (IF) Macro (A20)"},
-    {"FA 54 3C 5E 24 24 84 06", "Tamron SP AF 28-75mm f/2.8 XR Di LD Aspherical (IF) Macro (A09NII)"},
-    {"FA 54 3C 5E 24 24 DF 06", "Tamron SP AF 28-75mm f/2.8 XR Di LD Aspherical (IF) Macro (A09NII)"},
-    {"FA 54 6E 8E 24 24 4B 02", "Sigma APO 120-300mm f/2.8 EX DG HSM"},
-    {"FB 54 2B 50 24 24 84 06", "Tamron SP AF 17-50mm f/2.8 XR Di II LD Aspherical (IF) (A16NII)"},
-    {"FB 54 8E 8E 24 24 4B 02", "Sigma APO 300mm f/2.8 EX DG HSM"},
-    {"FC 40 2D 80 2C 40 DF 06", "Tamron AF 18-200mm f/3.5-6.3 XR Di II LD Aspherical (IF) Macro (A14NII)"},
-    {"FD 47 50 76 24 24 4B 06", "Sigma 50-150mm f/2.8 EX APO DC HSM II"},
-    {"FE 47 00 00 24 24 4B 06", "Sigma 4.5mm f/2.8 EX DC HSM Circular Fisheye"},
-    {"FE 48 37 5C 24 24 DF 0E", "Tamron SP 24-70mm f/2.8 Di VC USD (A007)"},
-    {"FE 53 5C 80 24 24 84 06", "Tamron SP AF 70-200mm f/2.8 Di LD (IF) Macro (A001)"},
-    {"FE 54 5C 80 24 24 DF 0E", "Tamron SP 70-200mm f/2.8 Di VC USD (A009)"},
-    {"FE 54 64 64 24 24 DF 0E", "Tamron SP 90mm f/2.8 Di VC USD Macro 1:1 (F004)"},
-    {"FF 40 2D 80 2C 40 4B 06", "Sigma 18-200mm f/3.5-6.3 DC"},
-
-    // There are cases where one lens uses multiple IDs which change based on the focal length or aperture.
-    // These IDs cannot be listed using ExifTool, and so must be entered manually below.
-    // #4135
-
-    {"92 2B 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC Macro OS HSM"}, // (210mm)
-    {"92 2C 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC Macro OS HSM"}, // (185mm)
-    {"92 2D 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC Macro OS HSM"}, // (155mm)
-    {"92 2E 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC Macro OS HSM"}, // (130mm)
-    {"92 2F 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC Macro OS HSM"}, // (105mm)
-    {"92 30 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC Macro OS HSM"}, // (90mm)
-    {"92 32 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC Macro OS HSM"}, // (75mm)
-    {"92 33 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC Macro OS HSM"}, // (62mm)
-    {"92 35 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC Macro OS HSM"}, // (52mm)
-    {"92 37 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC Macro OS HSM"}, // (44mm)
-    {"92 39 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC Macro OS HSM"}, // (38mm)
-    {"92 3A 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC Macro OS HSM"}, // (32mm)
-    {"92 3E 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC Macro OS HSM"}, // (22mm)
-    {"92 40 2D 88 2C 40 4B 0E", "Sigma 18-250mm f/3.5-6.3 DC Macro OS HSM"} // (18mm)
-};
-
-const TagAttrib nikonISOInfoAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0000, AUTO, "ISO", &naISOInfoISOInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0004, SHORT, "ISOExpansion", &naISOExpansionInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0006, AUTO, "ISO2", &naISOInfoISOInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000a, SHORT, "ISOExpansion2", &naISOExpansionInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib nikon2Attribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0002, AUTO, "Unknown", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0003, AUTO, "Quality", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0004, AUTO, "ColorMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0005, AUTO, "ImageAdjustment", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0006, AUTO, "ISOSpeed", &naISOInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0007, AUTO, "WhiteBalance", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0008, AUTO, "Focus", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0009, AUTO, "Unknown", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000a, AUTO, "DigitalZoom", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000b, AUTO, "AuxiliaryLens", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0f00, AUTO, "Unknown", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib nikon3Attribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0001, AUTO, "MakerNoteVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0002, AUTO, "ISOSpeed", &naISOInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0003, AUTO, "ColorMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0004, AUTO, "Quality", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0005, AUTO, "WhiteBalance", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0006, AUTO, "Sharpness", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0007, AUTO, "FocusMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0008, AUTO, "FlashSetting", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0009, AUTO, "FlashType", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000b, AUTO, "WhiteBalanceFineTune", &stdInterpreter},
-    {0, AC_NEW,   0, nullptr, 0x000c, AUTO, "ColorBalance1", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000d, AUTO, "ProgramShift", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000e, AUTO, "ExposureDifference", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000f, AUTO, "ISOSelection", &naISOInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0010, AUTO, "DataDump", &stdInterpreter},
-    {1, AC_WRITE, 0, nullptr, 0x0011, AUTO, "NikonPreview", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0012, AUTO, "FlashExposureComp", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0013, AUTO, "ISOSetting", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0016, AUTO, "ImageBoundary", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0018, AUTO, "FlashExposureBracketValue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0019, AUTO, "ExposureBracketValue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x001a, AUTO, "ImageProcessing", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x001b, AUTO, "CropHiSpeed", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x001d, AUTO, "SerialNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x001e, AUTO, "ColorSpace", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0020, AUTO, "ImageAuthentication", &stdInterpreter},
-    {0, AC_WRITE, 0, nikonISOInfoAttribs, 0x0025, AUTO, "ISOInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0080, AUTO, "ImageAdjustment", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0081, AUTO, "ToneComp", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0082, AUTO, "AuxiliaryLens", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0083, AUTO, "LensType", &naLensTypeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0084, AUTO, "Lens", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0085, AUTO, "ManualFocusDistance", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0086, AUTO, "DigitalZoom", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0087, AUTO, "FlashMode", &naFlashModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0088, AUTO, "AFInfo", &naAFInfoInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0089, AUTO, "ShootingMode", &naShootingModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x008a, AUTO, "AutoBracketRelease", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x008b, AUTO, "LensFStops", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x008c, AUTO, "NEFCurve1", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x008d, AUTO, "ColorHue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x008f, AUTO, "SceneMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0090, AUTO, "LightSource", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0091, AUTO, "ShotInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0092, AUTO, "HueAdjustment", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0094, AUTO, "Saturation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0095, AUTO, "NoiseReduction", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0096, AUTO, "NEFCurve2", &stdInterpreter},
-    {0, AC_NEW,   0, nullptr, 0x0097, AUTO, "ColorBalance", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0098, AUTO, "LensData", &naLensDataInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0099, AUTO, "RawImageCenter", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x009a, AUTO, "SensorPixelSize", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00a0, AUTO, "SerialNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00a2, AUTO, "ImageDataSize", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00a5, AUTO, "ImageCount", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00a6, AUTO, "DeletedImageCount", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00a7, AUTO, "ShutterCount", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00a9, AUTO, "ImageOptimization", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00aa, AUTO, "Saturation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00ab, AUTO, "VariProgram", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00ac, AUTO, "ImageStabilization", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00ad, AUTO, "AFResponse", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00b0, AUTO, "MultiExposure", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00b1, AUTO, "HighISONoiseReduction", &naHiISONRInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0e00, AUTO, "PrintIM", &stdInterpreter},
-    {0, AC_DONTWRITE, 0, nullptr, 0x0e01, AUTO, "NikonCaptureData", &stdInterpreter},
-    {0, AC_DONTWRITE, 0, nullptr, 0x0e09, AUTO, "NikonCaptureVersion", &stdInterpreter},
-    {0, AC_DONTWRITE, 0, nullptr, 0x0e0e, AUTO, "NikonCaptureOffsets", &stdInterpreter},
-    {0, AC_DONTWRITE, 0, nullptr, 0x0e10, AUTO, "NikonScanIFD", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-}
diff --git a/rtexif/olympusattribs.cc b/rtexif/olympusattribs.cc
deleted file mode 100644
index 63ce6bb43..000000000
--- a/rtexif/olympusattribs.cc
+++ /dev/null
@@ -1,859 +0,0 @@
-/*
- *  This file is part of RawTherapee.
- *
- *  Copyright (c) 2004-2010 Gabor Horvath <hgabor@rawtherapee.com>
- *
- *  RawTherapee is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  RawTherapee is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-#include <string>
-#include <cmath>
-#include <iomanip>
-#include <sstream>
-
-#include "rtexif.h"
-
-namespace rtexif
-{
-
-class OLOnOffInterpreter : public Interpreter
-{
-public:
-    OLOnOffInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        if (t->toInt() == 0) {
-            return "Off";
-        } else {
-            return "On";
-        }
-    }
-};
-OLOnOffInterpreter olOnOffInterpreter;
-
-class OLYesNoInterpreter : public Interpreter
-{
-public:
-    OLYesNoInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        if (t->toInt() == 0) {
-            return "No";
-        } else {
-            return "Yes";
-        }
-    }
-};
-OLYesNoInterpreter olYesNoInterpreter;
-
-class OLApertureInterpreter : public Interpreter
-{
-public:
-    OLApertureInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        std::ostringstream str;
-        str.precision (2);
-        str << pow (2, t->toInt() / 512.0);
-        return str.str();
-    }
-};
-OLApertureInterpreter olApertureInterpreter;
-
-class OLLensTypeInterpreter : public Interpreter
-{
-    std::map<std::string, std::string> lenses;
-public:
-    OLLensTypeInterpreter ()
-    {
-        lenses["00 01 00"] = "Olympus Zuiko Digital ED 50mm f/2.0 Macro";
-        lenses["00 01 01"] = "Olympus Zuiko Digital 40-150mm f/3.5-4.5";
-        lenses["00 01 10"] = "Olympus M.Zuiko Digital ED 14-42mm f/3.5-5.6";
-        lenses["00 02 00"] = "Olympus Zuiko Digital ED 150mm f/2.0";
-        lenses["00 02 10"] = "Olympus M.Zuiko Digital 17mm f/2.8 Pancake";
-        lenses["00 03 00"] = "Olympus Zuiko Digital ED 300mm f/2.8";
-        lenses["00 03 10"] = "Olympus M.Zuiko Digital ED 14-150mm f/4.0-5.6 [II]";
-        lenses["00 04 10"] = "Olympus M.Zuiko Digital ED 9-18mm f/4.0-5.6";
-        lenses["00 05 00"] = "Olympus Zuiko Digital 14-54mm f/2.8-3.5";
-        lenses["00 05 01"] = "Olympus Zuiko Digital Pro ED 90-250mm f/2.8";
-        lenses["00 05 10"] = "Olympus M.Zuiko Digital ED 14-42mm f/3.5-5.6 L";
-        lenses["00 06 00"] = "Olympus Zuiko Digital ED 50-200mm f/2.8-3.5";
-        lenses["00 06 01"] = "Olympus Zuiko Digital ED 8mm f/3.5 Fisheye";
-        lenses["00 06 10"] = "Olympus M.Zuiko Digital ED 40-150mm f/4.0-5.6";
-        lenses["00 07 00"] = "Olympus Zuiko Digital 11-22mm f/2.8-3.5";
-        lenses["00 07 01"] = "Olympus Zuiko Digital 18-180mm f/3.5-6.3";
-        lenses["00 07 10"] = "Olympus M.Zuiko Digital ED 12mm f/2.0";
-        lenses["00 08 01"] = "Olympus Zuiko Digital 70-300mm f/4.0-5.6";
-        lenses["00 08 10"] = "Olympus M.Zuiko Digital ED 75-300mm f/4.8-6.7";
-        lenses["00 09 10"] = "Olympus M.Zuiko Digital 14-42mm f/3.5-5.6 II";
-        lenses["00 10 01"] = "Kenko Tokina Reflex 300mm f/6.3 MF Macro";
-        lenses["00 10 10"] = "Olympus M.Zuiko Digital ED 12-50mm f/3.5-6.3 EZ";
-        lenses["00 11 10"] = "Olympus M.Zuiko Digital 45mm f/1.8";
-        lenses["00 12 10"] = "Olympus M.Zuiko Digital ED 60mm f/2.8 Macro";
-        lenses["00 13 10"] = "Olympus M.Zuiko Digital 14-42mm f/3.5-5.6 II R";
-        lenses["00 14 10"] = "Olympus M.Zuiko Digital ED 40-150mm f/4.0-5.6 R";
-        lenses["00 15 00"] = "Olympus Zuiko Digital ED 7-14mm f/4.0";
-        lenses["00 15 10"] = "Olympus M.Zuiko Digital ED 75mm f/1.8";
-        lenses["00 16 10"] = "Olympus M.Zuiko Digital 17mm f/1.8";
-        lenses["00 17 00"] = "Olympus Zuiko Digital Pro ED 35-100mm f/2.0";
-        lenses["00 18 00"] = "Olympus Zuiko Digital 14-45mm f/3.5-5.6";
-        lenses["00 18 10"] = "Olympus M.Zuiko Digital ED 75-300mm f/4.8-6.7 II";
-        lenses["00 19 10"] = "Olympus M.Zuiko Digital ED 12-40mm f/2.8 Pro";
-        lenses["00 20 00"] = "Olympus Zuiko Digital 35mm f/3.5 Macro";
-        lenses["00 20 10"] = "Olympus M.Zuiko Digital ED 40-150mm f/2.8 Pro";
-        lenses["00 21 10"] = "Olympus M.Zuiko Digital ED 14-42mm f/3.5-5.6 EZ";
-        lenses["00 22 00"] = "Olympus Zuiko Digital 17.5-45mm f/3.5-5.6";
-        lenses["00 22 10"] = "Olympus M.Zuiko Digital 25mm f/1.8";
-        lenses["00 23 00"] = "Olympus Zuiko Digital ED 14-42mm f/3.5-5.6";
-        lenses["00 23 10"] = "Olympus M.Zuiko Digital ED 7-14mm f/2.8 Pro";
-        lenses["00 24 00"] = "Olympus Zuiko Digital ED 40-150mm f/4.0-5.6";
-        lenses["00 24 10"] = "Olympus M.Zuiko Digital ED 300mm f/4.0 IS Pro";
-        lenses["00 25 10"] = "Olympus M.Zuiko Digital ED 8mm f/1.8 Fisheye Pro";
-        lenses["00 26 10"] = "Olympus M.Zuiko Digital ED 12-100mm f/4.0 IS Pro";
-        lenses["00 27 10"] = "Olympus M.Zuiko Digital ED 30mm f/3.5 Macro";
-        lenses["00 28 10"] = "Olympus M.Zuiko Digital ED 25mm f/1.2 Pro";
-        lenses["00 29 10"] = "Olympus M.Zuiko Digital ED 17mm f/1.2 Pro";
-        lenses["00 30 00"] = "Olympus Zuiko Digital ED 50-200mm f/2.8-3.5 SWD";
-        lenses["00 30 10"] = "Olympus M.Zuiko Digital ED 45mm f/1.2 Pro";
-        lenses["00 31 00"] = "Olympus Zuiko Digital ED 12-60mm f/2.8-4.0 SWD";
-        lenses["00 32 00"] = "Olympus Zuiko Digital ED 14-35mm f/2.0 SWD";
-        lenses["00 32 10"] = "Olympus M.Zuiko Digital ED 12-200mm f/3.5-6.3";
-        lenses["00 33 00"] = "Olympus Zuiko Digital 25mm f/2.8";
-        lenses["00 33 10"] = "Olympus M.Zuiko Digital 150-400mm f/4.5 TC1.25x IS Pro";
-        lenses["00 34 00"] = "Olympus Zuiko Digital ED 9-18mm f/4.0-5.6";
-        lenses["00 34 10"] = "Olympus M.Zuiko Digital ED 12-45mm f/4.0 Pro";
-        lenses["00 35 00"] = "Olympus Zuiko Digital 14-54mm f/2.8-3.5 II";
-        lenses["00 35 10"] = "Olympus M.Zuiko 100-400mm f/5.0-6.3";
-        lenses["00 36 10"] = "Olympus M.Zuiko Digital ED 8-25mm f/4 Pro";
-        lenses["01 01 00"] = "Sigma 18-50mm f/3.5-5.6 DC";
-        lenses["01 01 10"] = "Sigma 30mm f/2.8 EX DN";
-        lenses["01 02 00"] = "Sigma 55-200mm f/4.0-5.6 DC";
-        lenses["01 02 10"] = "Sigma 19mm f/2.8 EX DN";
-        lenses["01 03 00"] = "Sigma 18-125mm f/3.5-5.6 DC";
-        lenses["01 03 10"] = "Sigma 30mm f/2.8 DN | A";
-        lenses["01 04 00"] = "Sigma 18-125mm f/3.5-5.6 DC";
-        lenses["01 04 10"] = "Sigma 19mm f/2.8 DN | A";
-        lenses["01 05 00"] = "Sigma 30mm f/1.4 EX DC HSM";
-        lenses["01 05 10"] = "Sigma 60mm f/2.8 DN | A";
-        lenses["01 06 00"] = "Sigma APO 50-500mm f/4.0-6.3 EX DG HSM";
-        lenses["01 06 10"] = "Sigma 30mm f/1.4 DC DN | C";
-        lenses["01 07 00"] = "Sigma Macro 105mm f/2.8 EX DG";
-        lenses["01 07 10"] = "Sigma 16mm f/1.4 DC DN | C (017)";
-        lenses["01 08 00"] = "Sigma APO Macro 150mm f/2.8 EX DG HSM";
-        lenses["01 09 00"] = "Sigma 18-50mm f/2.8 EX DC Macro";
-        lenses["01 10 00"] = "Sigma 24mm f/1.8 EX DG Aspherical Macro";
-        lenses["01 11 00"] = "Sigma APO 135-400mm f/4.5-5.6 DG";
-        lenses["01 12 00"] = "Sigma APO 300-800mm f/5.6 EX DG HSM";
-        lenses["01 13 00"] = "Sigma 30mm f/1.4 EX DC HSM";
-        lenses["01 14 00"] = "Sigma APO 50-500mm f/4.0-6.3 EX DG HSM";
-        lenses["01 15 00"] = "Sigma 10-20mm f/4.0-5.6 EX DC HSM";
-        lenses["01 16 00"] = "Sigma APO 70-200mm f/2.8 II EX DG Macro HSM";
-        lenses["01 17 00"] = "Sigma 50mm f/1.4 EX DG HSM";
-        lenses["02 01 00"] = "Leica D Vario Elmarit 14-50mm f/2.8-3.5 Asph.";
-        lenses["02 01 10"] = "Lumix G Vario 14-45mm f/3.5-5.6 Asph. Mega OIS";
-        lenses["02 02 00"] = "Leica D Summilux 25mm f/1.4 Asph.";
-        lenses["02 02 10"] = "Lumix G Vario 45-200mm f/4.0-5.6 Mega OIS";
-        lenses["02 03 00"] = "Leica D Vario Elmar 14-50mm f/3.8-5.6 Asph. Mega OIS";
-        lenses["02 03 01"] = "Leica D Vario Elmar 14-50mm f/3.8-5.6 Asph.";
-        lenses["02 03 10"] = "Lumix G Vario HD 14-140mm f/4.0-5.8 Asph. Mega OIS";
-        lenses["02 04 00"] = "Leica D Vario Elmar 14-150mm f/3.5-5.6";
-        lenses["02 04 10"] = "Lumix G Vario 7-14mm f/4.0 Asph.";
-        lenses["02 05 10"] = "Lumix G 20mm f/1.7 Asph.";
-        lenses["02 06 10"] = "Leica DG Macro-Elmarit 45mm f/2.8 Asph. Mega OIS";
-        lenses["02 07 10"] = "Lumix G Vario 14-42mm f/3.5-5.6 Asph. Mega OIS";
-        lenses["02 08 10"] = "Lumix G Fisheye 8mm f/3.5";
-        lenses["02 09 10"] = "Lumix G Vario 100-300mm f/4.0-5.6 Mega OIS";
-        lenses["02 10 10"] = "Lumix G 14mm f/2.5 Asph.";
-        lenses["02 11 10"] = "Lumix G 12.5mm f/12 3D";
-        lenses["02 12 10"] = "Leica DG Summilux 25mm f/1.4 Asph.";
-        lenses["02 13 10"] = "Lumix G X Vario PZ 45-175mm f/4.0-5.6 Asph. Power OIS";
-        lenses["02 14 10"] = "Lumix G X Vario PZ 14-42mm f/3.5-5.6 Asph. Power OIS";
-        lenses["02 15 10"] = "Lumix G X Vario 12-35mm f/2.8 Asph. Power OIS";
-        lenses["02 16 10"] = "Lumix G Vario 45-150mm f/4.0-5.6 Asph. Mega OIS";
-        lenses["02 17 10"] = "Lumix G X Vario 35-100mm f/2.8 Power OIS";
-        lenses["02 18 10"] = "Lumix G Vario 14-42mm f/3.5-5.6 II Asph. Mega OIS";
-        lenses["02 19 10"] = "Lumix G Vario 14-140mm f/3.5-5.6 Asph. Power OIS";
-        lenses["02 20 10"] = "Lumix G Vario 12-32mm f/3.5-5.6 Asph. Mega OIS";
-        lenses["02 21 10"] = "Leica DG Nocticron 42.5mm f/1.2 Asph. Power OIS";
-        lenses["02 22 10"] = "Leica DG Summilux 15mm f/1.7 Asph.";
-        lenses["02 23 10"] = "Lumix G Vario 35-100mm f/4.0-5.6 Asph. Mega OIS";
-        lenses["02 24 10"] = "Lumix G Macro 30mm f/2.8 Asph. Mega OIS";
-        lenses["02 25 10"] = "Lumix G 42.5mm f/1.7 Asph. Power OIS";
-        lenses["02 26 10"] = "Lumix G 25mm f/1.7 Asph.";
-        lenses["02 27 10"] = "Leica DG Vario-Elmar 100-400mm f/4.0-6.3 Asph. Power OIS";
-        lenses["02 28 10"] = "Lumix G Vario 12-60mm f/3.5-5.6 Asph. Power OIS";
-        lenses["02 29 10"] = "Leica DG Summilux 12mm f/1.4 Asph.";
-        lenses["02 30 10"] = "Leica DG Vario-Elmarit 12-60mm f/2.8-4 Asph. Power OIS";
-        lenses["02 31 10"] = "Lumix G Vario 45-200mm f/4.0-5.6 II";
-        lenses["02 32 10"] = "Lumix G Vario 100-300mm f/4.0-5.6 II";
-        lenses["02 33 10"] = "Lumix G X Vario 12-35mm f/2.8 II Asph. Power OIS";
-        lenses["02 34 10"] = "Lumix G Vario 35-100mm f/2.8 II";
-        lenses["02 35 10"] = "Leica DG Vario-Elmarit 8-18mm f/2.8-4 Asph.";
-        lenses["02 36 10"] = "Leica DG Elmarit 200mm f/2.8 Power OIS";
-        lenses["02 37 10"] = "Leica DG Vario-Elmarit 50-200mm f/2.8-4 Asph. Power OIS";
-        lenses["02 38 10"] = "Leica DG Vario-Summilux 10-25mm f/1.7 Asph.";
-        lenses["02 40 10"] = "Leica DG Vario-Summilux 25-50mm f/1.7 Asph.";
-        lenses["03 01 00"] = "Leica D Vario Elmarit 14-50mm f/2.8-3.5 Asph.";
-        lenses["03 02 00"] = "Leica D Summilux 25mm f/1.4 Asph.";
-        lenses["05 01 10"] = "Tamron 14-150mm f/3.5-5.8 Di III";
-        lenses["024 01 10"] = "Venus Optics Laowa 50mm f/2.8 2x Macro";
-    }
-    std::string toString (const Tag* t) const override
-    {
-        std::ostringstream lid;
-        lid.setf (std::ios_base::hex, std::ios_base::basefield);
-        lid.setf (std::ios_base::uppercase);
-        lid << std::setw (2) << std::setfill ('0') << t->toInt (0) << ' '; //maker
-        lid << std::setw (2) << std::setfill ('0') << t->toInt (2) << ' '; //model
-        lid << std::setw (2) << std::setfill ('0') << t->toInt (3); // submodel
-
-        std::map<std::string, std::string>::const_iterator r = lenses.find (lid.str());
-
-        if (r != lenses.end()) {
-            return r->second;
-        } else {
-            return "Unknown";
-        }
-    }
-};
-OLLensTypeInterpreter olLensTypeInterpreter;
-
-class OLFlashTypeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    OLFlashTypeInterpreter ()
-    {
-        choices[0]      = "None";
-        choices[2]      = "Simple E-System";
-        choices[3]      = "E-System";
-    }
-};
-OLFlashTypeInterpreter olFlashTypeInterpreter;
-
-class OLExposureModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    OLExposureModeInterpreter ()
-    {
-        choices[1] = "Manual";
-        choices[2] = "Program";
-        choices[3] = "Aperture-priority AE";
-        choices[4] = "Shutter speed priority AE";
-        choices[5] = "Program-shift";
-    }
-};
-OLExposureModeInterpreter olExposureModeInterpreter;
-
-class OLMeteringModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    OLMeteringModeInterpreter ()
-    {
-        choices[2] = "Center-weighted average";
-        choices[3] = "Spot";
-        choices[5] = "ESP";
-        choices[261] = "Pattern+AF";
-        choices[515] = "Spot+Highlight control";
-        choices[1027] = "Spot+Shadow control";
-    }
-};
-OLMeteringModeInterpreter olMeteringModeInterpreter;
-
-class OLFocusModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    OLFocusModeInterpreter ()
-    {
-        choices[0] = "Single AF";
-        choices[1] = "Sequential shooting AF";
-        choices[2] = "Continuous AF";
-        choices[3] = "Multi AF";
-        choices[4] = "Face detect";
-        choices[10] = "MF";
-    }
-};
-OLFocusModeInterpreter olFocusModeInterpreter;
-
-class OLWhitebalance2Interpreter : public ChoiceInterpreter<>
-{
-public:
-    OLWhitebalance2Interpreter ()
-    {
-        choices[0] = "Auto";
-        choices[1] = "Auto (Keep Warm Color Off)";
-        choices[16] = "7500K (Fine Weather with Shade)";
-        choices[17] = "6000K (Cloudy)";
-        choices[18] = "5300K (Fine Weather)";
-        choices[20] = "3000K (Tungsten light)";
-        choices[21] = "3600K (Tungsten light-like)";
-        choices[22] = "Auto Setup";
-        choices[23] = "5500K (Flash)";
-        choices[33] = "6600K (Daylight fluorescent)";
-        choices[34] = "4500K (Neutral white fluorescent)";
-        choices[35] = "4000K (Cool white fluorescent)";
-        choices[36] = "White Fluorescent";
-        choices[48] = "3600K (Tungsten light-like)";
-        choices[67] = "Underwater";
-        choices[256] = "One Touch WB 1";
-        choices[257] = "One Touch WB 2";
-        choices[258] = "One Touch WB 3";
-        choices[259] = "One Touch WB 4";
-        choices[512] = "Custom WB 1";
-        choices[513] = "Custom WB 2";
-        choices[514] = "Custom WB 3";
-        choices[515] = "Custom WB 4";
-    }
-};
-OLWhitebalance2Interpreter olWhitebalance2Interpreter;
-
-class OLSceneModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    OLSceneModeInterpreter ()
-    {
-        choices[0] = "Standard";
-        choices[6] = "Auto";
-        choices[7] = "Sport";
-        choices[8] = "Portrait";
-        choices[9] = "Landscape+Portrait";
-        choices[10] = "Landscape";
-        choices[11] = "Night Scene";
-        choices[12] = "Self Portrait";
-        choices[13] = "Panorama";
-        choices[14] = "2 in 1";
-        choices[15] = "Movie";
-        choices[16] = "Landscape+Portrait";
-        choices[17] = "Night+Portrait";
-        choices[18] = "Indoor";
-        choices[19] = "Fireworks";
-        choices[20] = "Sunset";
-        choices[21] = "Beauty Skin";
-        choices[22] = "Macro";
-        choices[23] = "Super Macro";
-        choices[24] = "Food";
-        choices[25] = "Documents";
-        choices[26] = "Museum";
-        choices[27] = "Shoot & Select";
-        choices[28] = "Beach & Snow";
-        choices[29] = "Self Portrait+Timer";
-        choices[30] = "Candle";
-        choices[31] = "Available Light";
-        choices[32] = "Behind Glass";
-        choices[33] = "My Mode";
-        choices[34] = "Pet";
-        choices[35] = "Underwater Wide1";
-        choices[36] = "Underwater Macro";
-        choices[37] = "Shoot & Select1";
-        choices[38] = "Shoot & Select2";
-        choices[39] = "High Key";
-        choices[40] = "Digital Image Stabilization";
-        choices[41] = "Auction";
-        choices[42] = "Beach";
-        choices[43] = "Snow";
-        choices[44] = "Underwater Wide2";
-        choices[45] = "Low Key";
-        choices[46] = "Children";
-        choices[47] = "Vivid";
-        choices[48] = "Nature Macro";
-        choices[49] = "Underwater Snapshot";
-        choices[50] = "Shooting Guide";
-        choices[54] = "Face Portrait";
-        choices[57] = "Bulb";
-        choices[59] = "Smile Shot";
-        choices[60] = "Quick Shutter";
-        choices[63] = "Slow Shutter";
-        choices[64] = "Bird Watching";
-        choices[65] = "Multiple Exposure";
-        choices[66] = "e-Portrait";
-        choices[67] = "Soft Background Shot";
-        choices[142] = "Hand-held Starlight";
-        choices[154] = "HDR";
-    }
-};
-OLSceneModeInterpreter olSceneModeInterpreter;
-
-class OLPictureModeBWFilterInterpreter : public ChoiceInterpreter<>
-{
-public:
-    OLPictureModeBWFilterInterpreter ()
-    {
-        choices[0] = "n/a";
-        choices[1] = "Neutral";
-        choices[2] = "Yellow";
-        choices[3] = "Orange";
-        choices[4] = "Red";
-        choices[5] = "Green";
-    }
-};
-OLPictureModeBWFilterInterpreter olPictureModeBWFilterInterpreter;
-
-class OLPictureModeToneInterpreter : public ChoiceInterpreter<>
-{
-public:
-    OLPictureModeToneInterpreter ()
-    {
-        choices[0] = "n/a";
-        choices[1] = "Neutral";
-        choices[2] = "Sepia";
-        choices[3] = "Blue";
-        choices[4] = "Purple";
-        choices[5] = "Green";
-    }
-};
-OLPictureModeToneInterpreter olPictureModeToneInterpreter;
-
-class OLImageQuality2Interpreter : public ChoiceInterpreter<>
-{
-public:
-    OLImageQuality2Interpreter ()
-    {
-        choices[1] = "SQ";
-        choices[2] = "HQ";
-        choices[3] = "SHQ";
-        choices[4] = "RAW";
-        choices[5] = "SQ (5)";
-    }
-};
-OLImageQuality2Interpreter olImageQuality2Interpreter;
-
-class OLDevEngineInterpreter : public ChoiceInterpreter<>
-{
-public:
-    // RawDevEngine
-    OLDevEngineInterpreter ()
-    {
-        choices[0] = "High Speed";
-        choices[1] = "High Function";
-        choices[2] = "Advanced High Speed";
-        choices[3] = "Advanced High Function";
-    }
-};
-OLDevEngineInterpreter olDevEngineInterpreter;
-
-class OLPictureModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    OLPictureModeInterpreter ()
-    {
-        choices[1] = "Vivid";
-        choices[2] = "Natural";
-        choices[3] = "Muted";
-        choices[4] = "Portrait";
-        choices[5] = "i-Enhance";
-        choices[7] = "Color Creator";
-        choices[9] = "Color Profile 1";
-        choices[10] = "Color Profile 2";
-        choices[11] = "Color Profile 3";
-        choices[12] = "Monochrome Profile 1";
-        choices[13] = "Monochrome Profile 2";
-        choices[14] = "Monochrome Profile 3";
-        choices[256] = "Monotone";
-        choices[512] = "Sepia";
-    }
-};
-OLPictureModeInterpreter olPictureModeInterpreter;
-
-class OLColorSpaceInterpreter : public ChoiceInterpreter<>
-{
-public:
-    OLColorSpaceInterpreter ()
-    {
-        choices[0] = "sRGB";
-        choices[1] = "Adobe RGB";
-        choices[2] = "Pro Photo RGB";
-    }
-};
-OLColorSpaceInterpreter olColorSpaceInterpreter;
-
-class OLNoiseFilterInterpreter : public Interpreter
-{
-public:
-    OLNoiseFilterInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        int a = t->toInt (0);
-        int b = t->toInt (2);
-        int c = t->toInt (4);
-
-        if (a == -1 && b == -2 && c == 1) {
-            return "Low";
-        } else if (a == -2 && b == -2 && c == 1) {
-            return "Off";
-        } else if (a == 0 && b == -2 && c == 1) {
-            return "Standard";
-        } else if (a == 1 && b == -2 && c == 1) {
-            return "High";
-        } else {
-            return "Unknown";
-        }
-    }
-};
-OLNoiseFilterInterpreter olNoiseFilterInterpreter;
-
-class OLFlashModeInterpreter : public Interpreter
-{
-public:
-    OLFlashModeInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        std::ostringstream str;
-        int a = t->toInt ();
-        str << "Flash Used = " << ((a & 1) ? "Yes" : "No") << std::endl;
-        str << "Fill-in = " << ((a & 2) ? "On" : "Off") << std::endl;
-        str << "Red-eye = " << ((a & 4) ? "On" : "Off") << std::endl;
-        str << "Slow-sync = " << ((a & 8) ? "On" : "Off") << std::endl;
-        str << "Forced On = " << ((a & 16) ? "On" : "Off") << std::endl;
-        str << "2nd Curtain = " << ((a & 32) ? "On" : "Off");
-        return str.str();
-    }
-};
-OLFlashModeInterpreter olFlashModeInterpreter;
-
-class OLNoiseReductionInterpreter : public Interpreter
-{
-public:
-    OLNoiseReductionInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        std::ostringstream str;
-        int a = t->toInt ();
-        str << "Noise Reduction = " << ((a & 1) ? "On" : "Off") << std::endl;
-        str << "Noise Filter = " << ((a & 2) ? "On" : "Off") << std::endl;
-        str << "Noise Filter (ISO Boost) = " << ((a & 4) ? "On" : "Off") << std::endl;
-        str << "Auto = " << ((a & 8) ? "On" : "Off");
-        return str.str();
-    }
-};
-OLNoiseReductionInterpreter olNoiseReductionInterpreter;
-
-class OLFlashModelInterpreter : public ChoiceInterpreter<>
-{
-public:
-    OLFlashModelInterpreter ()
-    {
-        choices[0]  = "None";
-        choices[1]  = "FL-20";
-        choices[2]  = "FL-50";
-        choices[3]  = "RF-11";
-        choices[4]  = "TF-22";
-        choices[5]  = "FL-36";
-        choices[6]  = "FL-50R";
-        choices[7]  = "FL-36R";
-        choices[9]  = "FL-14";
-        choices[11] = "FL-600R";
-    }
-};
-OLFlashModelInterpreter olFlashModelInterpreter;
-
-const TagAttrib olyFocusInfoAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0000, AUTO, "FocusInfoVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0209, AUTO, "AutoFocus", &olOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0210, AUTO, "SceneDetect", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0211, AUTO, "SceneArea", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0212, AUTO, "SceneDetectData", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0300, AUTO, "ZoomStepCount", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0301, AUTO, "FocusStepCount", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0303, AUTO, "FocusStepInfinity", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0304, AUTO, "FocusStepNear", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0305, AUTO, "FocusDistance", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0308, AUTO, "AFPoint", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1201, AUTO, "ExternalFlash", &olOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1203, AUTO, "ExternalFlashGuideNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1204, AUTO, "ExternalFlashBounce", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1205, AUTO, "ExternalFlashZoom", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1208, AUTO, "InternalFlash", &olOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1209, AUTO, "ManualFlash", &olOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1500, AUTO, "SensorTemperature", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1600, AUTO, "ImageStabilization", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib olyImageProcessingAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0000, AUTO, "ImageProcessingVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0100, AUTO, "WB_RBLevels", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0102, AUTO, "WB_RBLevels3000K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0103, AUTO, "WB_RBLevels3300K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0104, AUTO, "WB_RBLevels3600K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0105, AUTO, "WB_RBLevels3900K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0106, AUTO, "WB_RBLevels4000K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0107, AUTO, "WB_RBLevels4300K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0108, AUTO, "WB_RBLevels4500K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0109, AUTO, "WB_RBLevels4800K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010a, AUTO, "WB_RBLevels5300K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010b, AUTO, "WB_RBLevels6000K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010c, AUTO, "WB_RBLevels6600K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010d, AUTO, "WB_RBLevels7500K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010e, AUTO, "WB_RBLevelsCWB1", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010f, AUTO, "WB_RBLevelsCWB2", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0110, AUTO, "WB_RBLevelsCWB3", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0111, AUTO, "WB_RBLevelsCWB4", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0113, AUTO, "WB_GLevel3000K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0114, AUTO, "WB_GLevel3300K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0115, AUTO, "WB_GLevel3600K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0116, AUTO, "WB_GLevel3900K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0117, AUTO, "WB_GLevel4000K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0118, AUTO, "WB_GLevel4300K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0119, AUTO, "WB_GLevel4500K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x011a, AUTO, "WB_GLevel4800K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x011b, AUTO, "WB_GLevel5300K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x011c, AUTO, "WB_GLevel6000K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x011d, AUTO, "WB_GLevel6600K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x011e, AUTO, "WB_GLevel7500K", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x011f, AUTO, "WB_GLevel", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0200, AUTO, "ColorMatrix", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0300, AUTO, "Enhancer", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0301, AUTO, "EnhancerValues", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0310, AUTO, "CoringFilter", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0311, AUTO, "CoringValues", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0600, AUTO, "BlackLevel2", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0610, AUTO, "GainBase", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0611, AUTO, "ValidBits", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0612, AUTO, "CropLeft", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0613, AUTO, "CropTop", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0614, AUTO, "CropWidth", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0615, AUTO, "CropHeight", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1010, AUTO, "NoiseReduction2", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1011, AUTO, "DistortionCorrection2", &olOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1012, AUTO, "ShadingCompensation2", &olOnOffInterpreter},
-    {1, AC_WRITE, 0, nullptr, 0x1103, AUTO, "UnknownBlock", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1200, AUTO, "FaceDetect", &olOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1201, AUTO, "FaceDetectArea", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib olyRawDevelopmentAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0000, AUTO, "RawDevVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0100, AUTO, "RawDevExposureBiasValue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0101, AUTO, "RawDevWhiteBalanceValue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0102, AUTO, "RawDevWBFineAdjustment", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0103, AUTO, "RawDevGrayPoint", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0104, AUTO, "RawDevSaturationEmphasis", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0105, AUTO, "RawDevMemoryColorEmphasis", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0106, AUTO, "RawDevContrastValue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0107, AUTO, "RawDevSharpnessValue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0108, AUTO, "RawDevColorSpace", &olColorSpaceInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0109, AUTO, "RawDevEngine", &olDevEngineInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010a, AUTO, "RawDevNoiseReduction", &olNoiseReductionInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010b, AUTO, "RawDevEditStatus", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010c, AUTO, "RawDevSettings", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib olyRawDevelopment2Attribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0000, AUTO, "RawDevVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0100, AUTO, "RawDevExposureBiasValue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0101, AUTO, "RawDevWhiteBalance", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0102, AUTO, "RawDevWhiteBalanceValue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0103, AUTO, "RawDevWBFineAdjustment", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0104, AUTO, "RawDevGrayPoint", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0105, AUTO, "RawDevContrastValue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0106, AUTO, "RawDevSharpnessValue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0107, AUTO, "RawDevSaturationEmphasis", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0108, AUTO, "RawDevMemoryColorEmphasis", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0109, AUTO, "RawDevColorSpace", &olColorSpaceInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010a, AUTO, "RawDevNoiseReduction", &olNoiseReductionInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010b, AUTO, "RawDevEngine", &olDevEngineInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010c, AUTO, "RawDevPictureMode", &olPictureModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010d, AUTO, "RawDevPMSaturation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010e, AUTO, "RawDevPMContrast", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010f, AUTO, "RawDevPMSharpness", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0110, AUTO, "RawDevPM_BWFilter", &olPictureModeBWFilterInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0111, AUTO, "RawDevPMPictureTone", &olPictureModeToneInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0112, AUTO, "RawDevGradation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0113, AUTO, "RawDevSaturation3", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0119, AUTO, "RawDevAutoGradation", &olOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0120, AUTO, "RawDevPMNoiseFilter", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib olyCameraSettingsAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0000, AUTO, "CameraSettingsVersion", &stdInterpreter},
-    {1, AC_WRITE, 0, nullptr, 0x0100, AUTO, "PreviewImageValid", &olYesNoInterpreter},
-    {1, AC_WRITE, 0, nullptr, 0x0101, AUTO, "PreviewImageStart", &stdInterpreter},
-    {1, AC_WRITE, 0, nullptr, 0x0102, AUTO, "PreviewImageLength", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0200, AUTO, "ExposureMode", &olExposureModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0201, AUTO, "AELock", &olOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0202, AUTO, "MeteringMode", &olMeteringModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0300, AUTO, "MacroMode", &olOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0301, AUTO, "FocusMode", &olFocusModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0302, AUTO, "FocusProcess", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0303, AUTO, "AFSearch", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0304, AUTO, "AFAreas", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0400, AUTO, "FlashMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0401, AUTO, "FlashExposureComp", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0500, AUTO, "WhiteBalance2", &olWhitebalance2Interpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0501, AUTO, "WhiteBalanceTemperature", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0502, AUTO, "WhiteBalanceBracket", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0503, AUTO, "CustomSaturation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0504, AUTO, "ModifiedSaturation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0505, AUTO, "ContrastSetting", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0506, AUTO, "SharpnessSetting", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0507, AUTO, "ColorSpace", &olColorSpaceInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0509, AUTO, "SceneMode", &olSceneModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x050a, AUTO, "NoiseReduction", &olNoiseReductionInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x050b, AUTO, "DistortionCorrection", &olOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x050c, AUTO, "ShadingCompensation", &olOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x050d, AUTO, "CompressionFactor", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x050f, AUTO, "Gradation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0520, AUTO, "PictureMode", &olPictureModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0521, AUTO, "PictureModeSaturation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0522, AUTO, "PictureModeHue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0523, AUTO, "PictureModeContrast", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0524, AUTO, "PictureModeSharpness", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0525, AUTO, "PictureModeBWFilter", &olPictureModeBWFilterInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0526, AUTO, "PictureModeTone", &olPictureModeToneInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0527, AUTO, "NoiseFilter", &olNoiseFilterInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0600, AUTO, "DriveMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0601, AUTO, "PanoramaMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0603, AUTO, "ImageQuality2", &olImageQuality2Interpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0900, AUTO, "ManometerPressure", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0901, AUTO, "ManometerReading", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0902, AUTO, "ExtendedWBDetect", &olOnOffInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib olyEquipmentAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0000, AUTO, "EquipmentVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0100, AUTO, "CameraType2", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0101, AUTO, "SerialNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0102, AUTO, "InternalSerialNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0103, AUTO, "FocalPlaneDiagonal", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0104, AUTO, "BodyFirmwareVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0201, AUTO, "LensType", &olLensTypeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0202, AUTO, "LensSerialNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0204, AUTO, "LensFirmwareVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0205, AUTO, "MaxApertureAtMinFocal", &olApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0206, AUTO, "MaxApertureAtMaxFocal", &olApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0207, AUTO, "MinFocalLength", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0208, AUTO, "MaxFocalLength", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x020a, AUTO, "MaxApertureAtCurrentFocal", &olApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x020b, AUTO, "LensProperties", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0301, AUTO, "Extender", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0302, AUTO, "ExtenderSerialNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0303, AUTO, "ExtenderModel", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0304, AUTO, "ExtenderFirmwareVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1000, AUTO, "FlashType", &olFlashTypeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1001, AUTO, "FlashModel", &olFlashModelInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1002, AUTO, "FlashFirmwareVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x1003, AUTO, "FlashSerialNumber", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib olympusAttribs[] = {
-    {0, AC_WRITE,  0, nullptr, 0x0104, AUTO, "BodyFirmwareVersion", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0200, AUTO, "SpecialMode", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0201, AUTO, "Quality", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0202, AUTO, "Macro", &olOnOffInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0203, AUTO, "BWMode", &olOnOffInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0204, AUTO, "DigitalZoom", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0205, AUTO, "FocalPlaneDiagonal", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0206, AUTO, "LensDistortionParams", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0207, AUTO, "CameraType", &stdInterpreter},
-    {1, AC_WRITE,  0, nullptr, 0x0208, AUTO, "TextInfo", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0209, AUTO, "CameraID", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x020b, AUTO, "EpsonImageWidth", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x020c, AUTO, "EpsonImageHeight", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x020d, AUTO, "EpsonSoftware", &stdInterpreter},
-    {0, AC_SYSTEM, 0, nullptr, 0x0280, AUTO, "PreviewImage", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0300, AUTO, "PreCaptureFrames", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0301, AUTO, "WhiteBoard", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0302, AUTO, "OneTouchWB", &olOnOffInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0303, AUTO, "WhiteBalanceBracket", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0304, AUTO, "WhiteBalanceBias", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0403, AUTO, "SceneMode", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0404, AUTO, "SerialNumber", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0405, AUTO, "Firmware", &stdInterpreter},
-    {1, AC_WRITE,  0, nullptr, 0x0e00, AUTO, "PrintIM", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0f00, AUTO, "DataDump", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0f01, AUTO, "DataDump2", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1000, AUTO, "ShutterSpeedValue", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1001, AUTO, "ISOValue", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1002, AUTO, "ApertureValue", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1003, AUTO, "BrightnessValue", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1004, AUTO, "FlashMode", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1005, AUTO, "FlashDevice", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1006, AUTO, "ExposureCompensation", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1007, AUTO, "SensorTemperature", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1008, AUTO, "LensTemperature", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1009, AUTO, "LightCondition", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x100a, AUTO, "FocusRange", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x100b, AUTO, "FocusMode", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x100c, AUTO, "ManualFocusDistance", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x100d, AUTO, "ZoomStepCount", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x100e, AUTO, "FocusStepCount", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x100f, AUTO, "Sharpness", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1010, AUTO, "FlashChargeLevel", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1011, AUTO, "ColorMatrix", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1012, AUTO, "BlackLevel", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1013, AUTO, "ColorTemperatureBG", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1014, AUTO, "ColorTemperatureRG", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1015, AUTO, "WBMode", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1017, AUTO, "RedBalance", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1018, AUTO, "BlueBalance", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1019, AUTO, "ColorMatrixNumber", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x101a, AUTO, "SerialNumber", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x101b, AUTO, "ExternalFlashAE1_0", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x101c, AUTO, "ExternalFlashAE2_0", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x101d, AUTO, "InternalFlashAE1_0", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x101e, AUTO, "InternalFlashAE2_0", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x101f, AUTO, "ExternalFlashAE1", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1020, AUTO, "ExternalFlashAE2", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1021, AUTO, "InternalFlashAE1", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1022, AUTO, "InternalFlashAE2", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1023, AUTO, "FlashExposureComp", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1024, AUTO, "InternalFlashTable", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1025, AUTO, "ExternalFlashGValue", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1026, AUTO, "ExternalFlashBounce", &olYesNoInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1027, AUTO, "ExternalFlashZoom", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1028, AUTO, "ExternalFlashMode", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1029, AUTO, "Contrast", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x102a, AUTO, "SharpnessFactor", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x102b, AUTO, "ColorControl", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x102c, AUTO, "ValidBits", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x102d, AUTO, "CoringFilter", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x102e, AUTO, "OlympusImageWidth", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x102f, AUTO, "OlympusImageHeight", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1030, AUTO, "SceneDetect", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1031, AUTO, "SceneArea", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1033, AUTO, "SceneDetectData", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1034, AUTO, "CompressionRatio", &stdInterpreter},
-    {1, AC_WRITE,  0, nullptr, 0x1035, AUTO, "PreviewImageValid", &olYesNoInterpreter},
-    {1, AC_WRITE,  0, nullptr, 0x1036, AUTO, "PreviewImageStart", &stdInterpreter},
-    {1, AC_WRITE,  0, nullptr, 0x1037, AUTO, "PreviewImageLength", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1038, AUTO, "AFResult", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x1039, AUTO, "CCDScanMode", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x103a, AUTO, "NoiseReduction", &olOnOffInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x103b, AUTO, "InfinityLensStep", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x103c, AUTO, "NearLensStep", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x103d, AUTO, "LightValueCenter", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x103e, AUTO, "LightValuePeriphery", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x103f, AUTO, "FieldCount", &stdInterpreter},
-    {0, AC_WRITE,  0, olyEquipmentAttribs, 0x2010, AUTO, "Equipment", &stdInterpreter},
-    {0, AC_WRITE,  0, olyCameraSettingsAttribs, 0x2020, AUTO, "CameraSettings", &stdInterpreter},
-    {0, AC_WRITE,  0, olyRawDevelopmentAttribs, 0x2030, AUTO, "RawDevelopment", &stdInterpreter},
-    {0, AC_WRITE,  0, olyRawDevelopment2Attribs, 0x2031, AUTO, "RawDev2", &stdInterpreter},
-    {0, AC_WRITE,  0, olyImageProcessingAttribs, 0x2040, AUTO, "ImageProcessing", &stdInterpreter},
-    {0, AC_WRITE,  0, olyFocusInfoAttribs, 0x2050, AUTO, "FocusInfo", &stdInterpreter},
-    {1, AC_WRITE,  0, nullptr, 0x2100, AUTO, "Olympus2100", &stdInterpreter},
-    {1, AC_WRITE,  0, nullptr, 0x2300, AUTO, "Olympus2300", &stdInterpreter},
-    {1, AC_WRITE,  0, nullptr, 0x2400, AUTO, "Olympus2400", &stdInterpreter},
-    {1, AC_WRITE,  0, nullptr, 0x2500, AUTO, "Olympus2500", &stdInterpreter},
-    {1, AC_WRITE,  0, nullptr, 0x2600, AUTO, "Olympus2600", &stdInterpreter},
-    {1, AC_WRITE,  0, nullptr, 0x2700, AUTO, "Olympus2700", &stdInterpreter},
-    {1, AC_WRITE,  0, nullptr, 0x2800, AUTO, "Olympus2800", &stdInterpreter},
-    {1, AC_WRITE,  0, nullptr, 0x2900, AUTO, "Olympus2900", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x3000, AUTO, "RawInfo", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-}
diff --git a/rtexif/panasonicattribs.cc b/rtexif/panasonicattribs.cc
deleted file mode 100644
index 4ebcf2447..000000000
--- a/rtexif/panasonicattribs.cc
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- *  This file is part of RawTherapee.
- */
-
-#include <string.h>
-#include "rtexif.h"
-
-namespace rtexif
-{
-
-// TODO: write interpreters
-
-const TagAttrib panasonicAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0001, AUTO, "Quality", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0002, AUTO, "FirmwareVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0003, AUTO, "WhiteBalance", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0007, AUTO, "FocusMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000f, AUTO, "AFMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x001a, AUTO, "ImageStabilization", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x001c, AUTO, "Macro", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x001f, AUTO, "ShootingMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0020, AUTO, "Audio", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0023, AUTO, "WhiteBalanceBias", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0024, AUTO, "FlashBias", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0025, AUTO, "InternalSerialNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0026, AUTO, "ExifVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0028, AUTO, "ColorEffect", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0029, AUTO, "TimeSincePowerOn", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x002a, AUTO, "BurstMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x002b, AUTO, "SequenceNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x002c, AUTO, "Contrast", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x002d, AUTO, "NoiseReduction", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x002e, AUTO, "SelfTimer", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0030, AUTO, "Rotation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0031, AUTO, "AFAssistLamp", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0032, AUTO, "ColorMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0033, AUTO, "BabyAge1", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0034, AUTO, "OpticalZoomMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0035, AUTO, "ConversionLens", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0036, AUTO, "TravelDay", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0039, AUTO, "Contrast", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x003a, AUTO, "WorldTimeLocation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x003b, AUTO, "TextStamp1", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x003c, AUTO, "ProgramISO", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x003d, AUTO, "AdvancedSceneType", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x003e, AUTO, "TextStamp2", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x003f, AUTO, "FacesDetected", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0040, AUTO, "Saturation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0041, AUTO, "Sharpness", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0042, AUTO, "FilmMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0044, AUTO, "ColorTempKelvin", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0045, AUTO, "BracketSettings", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0046, AUTO, "WBAdjustAB", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0047, AUTO, "WBAdjustGM", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0048, AUTO, "FlashCurtain", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0049, AUTO, "LongShutterNoiseReduction", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x004b, AUTO, "ImageWidth", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x004c, AUTO, "ImageHeight", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x004d, AUTO, "AFPointPosition", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x004e, AUTO, "FaceDetInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0051, AUTO, "LensType", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0052, AUTO, "LensSerialNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0053, AUTO, "AccessoryType", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0054, AUTO, "AccessorySerialNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0059, AUTO, "Transform1", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x005d, AUTO, "IntelligentExposure", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0060, AUTO, "LensFirmwareVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0061, AUTO, "FaceRecInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0062, AUTO, "FlashWarning", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0065, AUTO, "Title", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0066, AUTO, "BabyName", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0067, AUTO, "Location", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0069, AUTO, "Country", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x006b, AUTO, "State", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x006d, AUTO, "City", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x006f, AUTO, "Landmark", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0070, AUTO, "IntelligentResolution", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0077, AUTO, "BurstSheed", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0079, AUTO, "IntelligentDRange", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x007c, AUTO, "ClearRetouch", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0080, AUTO, "City2", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0086, AUTO, "ManometerPressure", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0089, AUTO, "PhotoStyle", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x008a, AUTO, "ShadingCompensation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x008c, AUTO, "AccelerometerZ", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x008d, AUTO, "AccelerometerX", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x008e, AUTO, "AccelerometerY", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x008f, AUTO, "CameraOrientation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0090, AUTO, "RollAngle", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0091, AUTO, "PitchAngle", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0093, AUTO, "SweepPanoramaDirection", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0094, AUTO, "PanoramaFieldOfView", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0096, AUTO, "TimerRecording", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x009d, AUTO, "InternalNDFilter", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x009e, AUTO, "HDR", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x009f, AUTO, "ShutterType", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00a3, AUTO, "ClearRetouchValue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x00ab, AUTO, "TouchAE", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0e00, AUTO, "PrintIM", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x8000, AUTO, "MakerNoteVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x8001, AUTO, "SceneMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x8004, AUTO, "WBRedLevel", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x8005, AUTO, "WBGreenLevel", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x8006, AUTO, "WBBlueLevel", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x8007, AUTO, "FlashFired", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x8008, AUTO, "TextStamp3", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x8009, AUTO, "TextStamp4", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x8010, AUTO, "BabyAge2", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x8012, AUTO, "Transform2", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr }
-};
-
-const TagAttrib panasonicRawAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0001, AUTO, "Version", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0002, AUTO, "SensorWidth", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0003, AUTO, "SensorHeight", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0004, AUTO, "SensorTopBorder", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0005, AUTO, "SensorLeftBorder", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0006, AUTO, "ImageHeight", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0007, AUTO, "ImageWidth", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0011, AUTO, "RedBalance", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0012, AUTO, "BlueBalance", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0017, AUTO, "ISOSpeed", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0024, AUTO, "WBRedLevel", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0025, AUTO, "WBGreenLevel", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0026, AUTO, "WBBlueLevel", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x002e, AUTO, "PreviewImage", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010f, AUTO, "Make", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0110, AUTO, "Model", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0111, AUTO, "StripOffsets", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0112, AUTO, "Orientation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0116, AUTO, "RowsPerStrip", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0117, AUTO, "StripByteCounts", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0118, AUTO, "RawDataOffset", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr }
-};
-
-}
diff --git a/rtexif/pentaxattribs.cc b/rtexif/pentaxattribs.cc
deleted file mode 100644
index bf17941f8..000000000
--- a/rtexif/pentaxattribs.cc
+++ /dev/null
@@ -1,2226 +0,0 @@
-/*
- *  This file is part of RawTherapee.
- *
- *  Copyright (c) 2004-2010 Gabor Horvath <hgabor@rawtherapee.com>
- *
- *  RawTherapee is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  RawTherapee is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-#include <cmath>
-#include <cstdio>
-#include <cstring> /* memcpy() */
-#include <string>
-#include <sstream>
-
-#include "rtexif.h"
-
-namespace rtexif
-{
-
-
-class PAQualityInterpreter : public ChoiceInterpreter<>
-{
-public:
-    PAQualityInterpreter ()
-    {
-        choices[0] = "Good";
-        choices[1] = "Better";
-        choices[2] = "Best";
-        choices[3] = "TIFF";
-        choices[4] = "RAW";
-        choices[5] = "Premium";
-        choices[6] = "RAW (HDR enabled)";
-        choices[7] = "RAW (pixel shift enabled)";
-        choices[8] = "RAW (pixel shift handheld mode enabled)";
-        choices[65535] = "n/a";
-    }
-};
-PAQualityInterpreter paQualityInterpreter;
-
-class PAOnOffInterpreter : public ChoiceInterpreter<>
-{
-public:
-    PAOnOffInterpreter ()
-    {
-        choices[0]      = "Off";
-        choices[1]      = "On";
-    }
-};
-PAOnOffInterpreter paOnOffInterpreter;
-
-class PAShakeReductionInterpreter : public ChoiceInterpreter<>
-{
-public:
-    PAShakeReductionInterpreter ()
-    {
-        choices[  0] = "Off";
-        choices[  1] = "On";
-        choices[  4] = "On (4)";
-        choices[  5] = "On but Disabled";
-        choices[  6] = "On (Video)";
-        choices[  7] = "On (7)";
-        choices[ 15] = "On (15)";
-        choices[ 39] = "On (mode 2)";
-        choices[135] = "On (135)";
-        choices[167] = "On (mode 1)";
-    }
-};
-PAShakeReductionInterpreter paShakeReductionInterpreter;
-
-class PAShakeReduction2Interpreter : public ChoiceInterpreter<>
-{
-public:
-    // ShakeReduction
-    PAShakeReduction2Interpreter ()
-    {
-        choices[ 0] = "Off";
-        choices[ 1] = "On";
-        choices[ 4] = "Off (AA simulation off)";
-        choices[ 5] = "On but Disabled";
-        choices[ 6] = "On (Video)";
-        choices[ 7] = "On (AA simulation off)";
-        choices[12] = "Off (AA simulation type 1)";
-        choices[15] = "On (AA simulation type 1)";
-        choices[20] = "Off (AA simulation type 2)";
-        choices[23] = "On (AA simulation type 2)";
-    }
-};
-PAShakeReduction2Interpreter paShakeReduction2Interpreter;
-
-class PAPictureModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    PAPictureModeInterpreter ()
-    {
-        choices[0] = "Program";
-        choices[1] = "Shutter Speed Priority";
-        choices[2] = "Program AE";
-        choices[3] = "Manual";
-        choices[5] = "Portrait";
-        choices[6] = "Landscape";
-        choices[8] = "Sport";
-        choices[9] = "Night Scene";
-        choices[11] = "Soft";
-        choices[12] = "Surf & Snow";
-        choices[13] = "Candlelight";
-        choices[14] = "Autumn";
-        choices[15] = "Macro";
-        choices[17] = "Fireworks";
-        choices[18] = "Text";
-        choices[19] = "Panorama";
-        choices[20] = "3-D";
-        choices[21] = "Black & White";
-        choices[22] = "Sepia";
-        choices[23] = "Red";
-        choices[24] = "Pink";
-        choices[25] = "Purple";
-        choices[26] = "Blue";
-        choices[27] = "Green";
-        choices[28] = "Yellow";
-        choices[30] = "Self Portrait";
-        choices[31] = "Illustrations";
-        choices[33] = "Digital Filter";
-        choices[35] = "Night Scene Portrait";
-        choices[37] = "Museum";
-        choices[38] = "Food";
-        choices[39] = "Underwater";
-        choices[40] = "Green Mode";
-        choices[49] = "Light Pet";
-        choices[50] = "Dark Pet";
-        choices[51] = "Medium Pet";
-        choices[53] = "Underwater";
-        choices[54] = "Candlelight";
-        choices[55] = "Natural Skin Tone";
-        choices[56] = "Synchro Sound Record";
-        choices[58] = "Frame Composite";
-        choices[59] = "Report";
-        choices[60] = "Kids";
-        choices[61] = "Blur Reduction";
-        choices[63] = "Panorama 2";
-        choices[65] = "Half-length Portrait";
-        choices[66] = "Portrait 2";
-        choices[74] = "Digital Microscope";
-        choices[75] = "Blue Sky";
-        choices[80] = "Miniature";
-        choices[81] = "HDR";
-        choices[83] = "Fisheye";
-        choices[85] = "Digital Filter 4";
-        choices[221] = "P";
-        choices[255] = "PICT";
-    }
-};
-PAPictureModeInterpreter paPictureModeInterpreter;
-
-class PASceneModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    PASceneModeInterpreter ()
-    {
-        choices[0] = "Off";
-        choices[1] = "HDR";
-        choices[4] = "Auto PICT";
-        choices[5] = "Portrait";
-        choices[6] = "Landscape";
-        choices[7] = "Macro";
-        choices[8] = "Sport";
-        choices[9] = "Night Scene Portrait";
-        choices[10] = "No Flash";
-        choices[11] = "Night Scene";
-        choices[12] = "Surf & Snow";
-        choices[14] = "Sunset";
-        choices[15] = "Kids";
-        choices[16] = "Pet";
-        choices[17] = "Candlelight";
-        choices[18] = "Museum";
-        choices[20] = "Food";
-        choices[21] = "Stage Lighting";
-        choices[22] = "Night Snap";
-        choices[25] = "Night Scene HDR";
-        choices[26] = "Blue Sky";
-        choices[27] = "Forest";
-        choices[29] = "Backlight Silhouette";
-    }
-};
-PASceneModeInterpreter paSceneModeInterpreter;
-
-class PAAEProgramModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    PAAEProgramModeInterpreter ()
-    {
-        choices[0] = "M, P or TAv";
-        choices[1] = "Av, B or X";
-        choices[2] = "Tv";
-        choices[3] = "Sv or Green Mode";
-        choices[8] = "Hi-speed Program";
-        choices[11] = "Hi-speed Program (P-Shift)";
-        choices[16] = "DOF Program";
-        choices[19] = "DOF Program (P-Shift)";
-        choices[24] = "MTF Program";
-        choices[27] = "MTF Program (P-Shift)";
-        choices[35] = "Standard";
-        choices[43] = "Portrait";
-        choices[51] = "Landscape";
-        choices[59] = "Macro";
-        choices[67] = "Sport";
-        choices[75] = "Night Scene Portrait";
-        choices[83] = "No Flash";
-        choices[91] = "Night Scene";
-        choices[99] = "Surf & Snow";
-        choices[104] = "Night Snap";
-        choices[107] = "Text";
-        choices[115] = "Sunset";
-        choices[123] = "Kids";
-        choices[131] = "Pet";
-        choices[139] = "Candlelight";
-        choices[144] = "SCN";
-        choices[147] = "Museum";
-        choices[160] = "Program";
-        choices[184] = "Shallow DOF Program";
-        choices[216] = "HDR";
-    }
-};
-PAAEProgramModeInterpreter paAEProgramModeInterpreter;
-
-class PAFlashModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    PAFlashModeInterpreter ()
-    {
-        choices[0] = "Auto, Did not fire";
-        choices[1] = "Off, Did not fire";
-        choices[2] = "On, Did not fire";
-        choices[3] = "Auto, Did not fire, Red-eye reduction";
-        choices[5] = "On, Did not fire, Wireless (Master)";
-        choices[256] = "Auto, Fired";
-        choices[258] = "On, Fired";
-        choices[259] = "Auto, Fired, Red-eye reduction";
-        choices[260] = "On, Red-eye reduction";
-        choices[261] = "On, Wireless (Master)";
-        choices[262] = "On, Wireless (Control)";
-        choices[264] = "On, Soft";
-        choices[265] = "On, Slow-sync";
-        choices[266] = "On, Slow-sync, Red-eye reduction";
-        choices[267] = "On, Trailing-curtain Sync";
-    }
-};
-PAFlashModeInterpreter paFlashModeInterpreter;
-
-class PAFocusModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    PAFocusModeInterpreter ()
-    {
-        choices[0] = "Normal";
-        choices[1] = "Macro";
-        choices[2] = "Infinity";
-        choices[3] = "Manual";
-        choices[4] = "Super Macro";
-        choices[5] = "Pan Focus";
-        choices[16] = "AF-S (Focus-priority)";
-        choices[17] = "AF-C (Focus-priority)";
-        choices[18] = "AF-A (Focus-priority)";
-        choices[32] = "Contrast-detect (Focus-priority)";
-        choices[33] = "Tracking Contrast-detect (Focus-priority)";
-        choices[272] = "AF-S (Release-priority)";
-        choices[273] = "AF-C (Release-priority)";
-        choices[274] = "AF-A (Release-priority)";
-        choices[288] = "Contrast-detect (Release-priority)";
-    }
-};
-PAFocusModeInterpreter paFocusModeInterpreter;
-
-class PAAFPointInterpreter : public ChoiceInterpreter<>
-{
-public:
-    // AFPointSelected
-    PAAFPointInterpreter        ()
-    {
-        choices[0] = "None";
-        choices[1] = "Upper-left";
-        choices[2] = "Top";
-        choices[3] = "Upper-right";
-        choices[4] = "Left";
-        choices[5] = "Mid-left";
-        choices[6] = "Center";
-        choices[7] = "Mid-right";
-        choices[8] = "Right";
-        choices[9] = "Lower-left";
-        choices[10] = "Bottom";
-        choices[11] = "Lower-right";
-        choices[65531] = "AF Select";
-        choices[65532] = "Face Detect AF";
-        choices[65533] = "Automatic Tracking AF";
-        choices[65534] = "Fixed Center";
-        choices[65535] = "Auto";
-    }
-};
-PAAFPointInterpreter paAFPointInterpreter;
-
-class PAAFFocusInterpreter : public ChoiceInterpreter<>
-{
-public:
-    // AFPointsInFocus
-    PAAFFocusInterpreter        ()
-    {
-        choices[0] = "Fixed Center or Multiple";
-        choices[1] = "Top-left";
-        choices[2] = "Top-center";
-        choices[3] = "Top-right";
-        choices[4] = "Left";
-        choices[5] = "Center";
-        choices[6] = "Right";
-        choices[7] = "Bottom-left";
-        choices[8] = "Bottom-center";
-        choices[9] = "Bottom-right";
-        choices[65535] = "None";
-    }
-};
-PAAFFocusInterpreter paAFFocusInterpreter;
-
-class PAISOInterpreter : public ChoiceInterpreter<>
-{
-public:
-    PAISOInterpreter        ()
-    {
-        choices[3] = "50";
-        choices[4] = "64";
-        choices[5] = "80";
-        choices[6] = "100";
-        choices[7] = "125";
-        choices[8] = "160";
-        choices[9] = "200";
-        choices[10] = "250";
-        choices[11] = "320";
-        choices[12] = "400";
-        choices[13] = "500";
-        choices[14] = "640";
-        choices[15] = "800";
-        choices[16] = "1000";
-        choices[17] = "1250";
-        choices[18] = "1600";
-        choices[19] = "2000";
-        choices[20] = "2500";
-        choices[21] = "3200";
-        choices[22] = "4000";
-        choices[23] = "5000";
-        choices[24] = "6400";
-        choices[25] = "8000";
-        choices[26] = "10000";
-        choices[27] = "12800";
-        choices[28] = "16000";
-        choices[29] = "20000";
-        choices[30] = "25600";
-        choices[31] = "32000";
-        choices[32] = "40000";
-        choices[33] = "51200";
-        choices[34] = "64000";
-        choices[35] = "80000";
-        choices[36] = "102400";
-        choices[37] = "128000";
-        choices[38] = "160000";
-        choices[39] = "204800";
-        choices[40] = "256000";
-        choices[41] = "320000";
-        choices[42] = "409600";
-        choices[43] = "512000";
-        choices[44] = "640000";
-        choices[45] = "819200";
-        choices[50] = "50";
-        choices[100] = "100";
-        choices[200] = "200";
-        choices[258] = "50";
-        choices[259] = "70";
-        choices[260] = "100";
-        choices[261] = "140";
-        choices[262] = "200";
-        choices[263] = "280";
-        choices[264] = "400";
-        choices[265] = "560";
-        choices[266] = "800";
-        choices[267] = "1100";
-        choices[268] = "1600";
-        choices[269] = "2200";
-        choices[270] = "3200";
-        choices[271] = "4500";
-        choices[272] = "6400";
-        choices[273] = "9000";
-        choices[274] = "12800";
-        choices[275] = "18000";
-        choices[276] = "25600";
-        choices[277] = "36000";
-        choices[278] = "51200";
-        choices[400] = "400";
-        choices[800] = "800";
-        choices[1600] = "1600";
-        choices[3200] = "3200";
-    }
-};
-PAISOInterpreter paISOInterpreter;
-
-class PAFNumberInterpreter: public Interpreter
-{
-public:
-    PAFNumberInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        double v = t->toDouble() / 10;
-
-        if ( v < 0. || v > 1000. ) {
-            return "undef";
-        }
-
-        snprintf(buffer, sizeof(buffer), "%.1f", v );
-        return buffer;
-    }
-};
-PAFNumberInterpreter paFNumberInterpreter;
-
-class PAMeteringModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    PAMeteringModeInterpreter ()
-    {
-        choices[0] = "Multi-segment";
-        choices[1] = "Center-weighted average";
-        choices[2] = "Spot";
-    }
-};
-PAMeteringModeInterpreter paMeteringModeInterpreter;
-
-class PAWhiteBalanceInterpreter : public ChoiceInterpreter<>
-{
-public:
-    PAWhiteBalanceInterpreter ()
-    {
-        choices[0] = "Auto";
-        choices[1] = "Daylight";
-        choices[2] = "Shade";
-        choices[3] = "Fluorescent";
-        choices[4] = "Tungsten";
-        choices[5] = "Manual";
-        choices[6] = "Daylight Fluorescent";
-        choices[7] = "Day White Fluorescent";
-        choices[8] = "White Fluorescent";
-        choices[9] = "Flash";
-        choices[10] = "Cloudy";
-        choices[11] = "Warm White Fluorescent";
-        choices[14] = "Multi Auto";
-        choices[15] = "Color Temperature Enhancement";
-        choices[17] = "Kelvin";
-        choices[65534] = "Unknown";
-        choices[65535] = "User-Selected";
-    }
-};
-PAWhiteBalanceInterpreter paWhiteBalanceInterpreter;
-
-class PAWhiteBalanceModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    PAWhiteBalanceModeInterpreter ()
-    {
-        choices[1] = "Auto (Daylight)";
-        choices[2] = "Auto (Shade)";
-        choices[3] = "Auto (Flash)";
-        choices[4] = "Auto (Tungsten)";
-        choices[6] = "Auto (Daylight Fluorescent)";
-        choices[7] = "Auto (Day White Fluorescent)";
-        choices[8] = "Auto (White Fluorescent)";
-        choices[10] = "Auto (Cloudy)";
-        choices[65534] = "Unknown";
-        choices[65535] = "User-Selected";
-    }
-};
-PAWhiteBalanceModeInterpreter paWhiteBalanceModeInterpreter;
-
-class PASaturationInterpreter : public ChoiceInterpreter<>
-{
-public:
-    PASaturationInterpreter ()
-    {
-        choices[0] = "-2 (low)";
-        choices[1] = "0 (normal)";
-        choices[2] = "+2 (high)";
-        choices[3] = "-1 (med low)";
-        choices[4] = "+1 (med high)";
-        choices[5] = "-3 (very low)";
-        choices[6] = "+3 (very high)";
-        choices[7] = "-4 (minimum)";
-        choices[8] = "+4 (maximum)";
-        choices[65535] = "None";
-    }
-};
-PASaturationInterpreter paSaturationInterpreter;
-
-class PAContrastInterpreter : public ChoiceInterpreter<>
-{
-public:
-    PAContrastInterpreter ()
-    {
-        choices[0] = "-2 (low)";
-        choices[1] = "0 (normal)";
-        choices[2] = "+2 (high)";
-        choices[3] = "-1 (med low)";
-        choices[4] = "+1 (med high)";
-        choices[5] = "-3 (very low)";
-        choices[6] = "+3 (very high)";
-        choices[7] = "-4 (minimum)";
-        choices[8] = "+4 (maximum)";
-        choices[65535] = "n/a";
-    }
-};
-PAContrastInterpreter paContrastInterpreter;
-
-class PASharpnessInterpreter : public ChoiceInterpreter<>
-{
-public:
-    PASharpnessInterpreter ()
-    {
-        choices[0] = "-2 (soft)";
-        choices[1] = "0 (normal)";
-        choices[2] = "+2 (hard)";
-        choices[3] = "-1 (med soft)";
-        choices[4] = "+1 (med hard)";
-        choices[5] = "-3 (very soft)";
-        choices[6] = "+3 (very hard)";
-        choices[7] = "-4 (minimum)";
-        choices[8] = "+4 (maximum)";
-    }
-};
-PASharpnessInterpreter paSharpnessInterpreter;
-
-class PAPictureModeInterpreter2: public ChoiceInterpreter<>
-{
-public:
-    PAPictureModeInterpreter2()
-    {
-        choices[256 *   0 +   0] = "Program";
-        choices[256 *   0 +   1] = "Hi-speed Program";
-        choices[256 *   0 +   2] = "DOF Program";
-        choices[256 *   0 +   3] = "MTF Program";
-        choices[256 *   0 +   4] = "Standard";
-        choices[256 *   0 +   5] = "Portrait";
-        choices[256 *   0 +   6] = "Landscape";
-        choices[256 *   0 +   7] = "Macro";
-        choices[256 *   0 +   8] = "Sport";
-        choices[256 *   0 +   9] = "Night Scene Portrait";
-        choices[256 *   0 +  10] = "No Flash";
-        choices[256 *   0 +  11] = "Night Scene";
-        choices[256 *   0 +  12] = "Surf & Snow";
-        choices[256 *   0 +  13] = "Text";
-        choices[256 *   0 +  14] = "Sunset";
-        choices[256 *   0 +  15] = "Kids";
-        choices[256 *   0 +  16] = "Pet";
-        choices[256 *   0 +  17] = "Candlelight";
-        choices[256 *   0 +  18] = "Museum";
-        choices[256 *   0 +  19] = "Food";
-        choices[256 *   0 +  20] = "Stage Lighting";
-        choices[256 *   0 +  21] = "Night Snap";
-        choices[256 *   0 +  23] = "Blue Sky";
-        choices[256 *   0 +  24] = "Sunset";
-        choices[256 *   0 +  26] = "Night Scene HDR";
-        choices[256 *   0 +  27] = "HDR";
-        choices[256 *   0 +  28] = "Quick Macro";
-        choices[256 *   0 +  29] = "Forest";
-        choices[256 *   0 +  30] = "Backlight Silhouette";
-        choices[256 *   1 +   4] = "Auto PICT (Standard)";
-        choices[256 *   1 +   5] = "Auto PICT (Portrait)";
-        choices[256 *   1 +   6] = "Auto PICT (Landscape)";
-        choices[256 *   1 +   7] = "Auto PICT (Macro)";
-        choices[256 *   1 +   8] = "Auto PICT (Sport)";
-        choices[256 *   2 +   0] = "Program (HyP)";
-        choices[256 *   2 +   1] = "Hi-speed Program (HyP)";
-        choices[256 *   2 +   2] = "DOF Program (HyP)";
-        choices[256 *   2 +   3] = "MTF Program (HyP)";
-        choices[256 *   2 +  22] = "Shallow DOF (HyP)";
-        choices[256 *   3 +   0] = "Green Mode";
-        choices[256 *   4 +   0] = "Shutter Speed Priority";
-        choices[256 *   5 +   0] = "Aperture Priority";
-        choices[256 *   6 +   0] = "Program Tv Shift";
-        choices[256 *   7 +   0] = "Program Av Shift";
-        choices[256 *   8 +   0] = "Manual";
-        choices[256 *   9 +   0] = "Bulb";
-        choices[256 *  10 +   0] = "Aperture Priority, Off-Auto-Aperture";
-        choices[256 *  11 +   0] = "Manual, Off-Auto-Aperture";
-        choices[256 *  12 +   0] = "Bulb, Off-Auto-Aperture";
-        choices[256 *  13 +   0] = "Shutter & Aperture Priority AE";
-        choices[256 *  15 +   0] = "Sensitivity Priority AE";
-        choices[256 *  16 +   0] = "Flash X-Sync Speed AE";
-        choices[256 *  18 +   0] = "Auto Program (Normal)";
-        choices[256 *  18 +   1] = "Auto Program (Hi-speed)";
-        choices[256 *  18 +   2] = "Auto Program (DOF)";
-        choices[256 *  18 +   3] = "Auto Program (MTF)";
-        choices[256 *  18 +  22] = "Auto Program (Shallow DOF)";
-        choices[256 *  20 +  22] = "Blur Control";
-        choices[256 * 254 +   0] = "Video";
-        choices[256 * 255 +   0] = "Video (Auto Aperture)";
-        choices[256 * 255 +   4] = "Video (4)";
-    }
-    std::string toString (const Tag* t) const override
-    {
-        int c = 256 * t->toInt (0, BYTE) + t->toInt (1, BYTE);
-        const ChoicesIterator r = choices.find (c);
-
-        if (r != choices.end()) {
-            std::ostringstream s;
-            s << r->second;
-
-            if ( t->toInt (1, BYTE) == 0 ) {
-                s << "\n1/2 EV steps";
-            } else {
-                s << "\n1/3 EV steps";
-            }
-
-            return s.str();
-        } else {
-            char buffer[1024];
-            t->toString (buffer, sizeof(buffer));
-            return std::string (buffer);
-        }
-    }
-};
-PAPictureModeInterpreter2 paPictureModeInterpreter2;
-
-class PADriveModeInterpreter : public ChoiceInterpreter<>
-{
-    std::map<int, std::string> choices1;
-    std::map<int, std::string> choices2;
-    std::map<int, std::string> choices3;
-public:
-    PADriveModeInterpreter()
-    {
-        choices[0]    = "Single-frame";
-        choices[1]    = "Continuous";
-        choices[2]    = "Continuous (Lo)";
-        choices[3]    = "Burst";
-        choices[4]    = "Continuous (Medium)";
-        choices[255]  = "Video";
-        choices1[0]   = "No Timer";
-        choices1[1]   = "Self-timer (12 s)";
-        choices1[2]   = "Self-timer (2 s)";
-        choices1[15]  = "Video";
-        choices1[16]  = "Mirror Lock-up";
-        choices1[255] = "n/a";
-        choices2[0]   = "Shutter Button";
-        choices2[1]   = "Remote Control (3 s delay)";
-        choices2[2]   = "Remote Control";
-        choices2[4]   = "Remote Continuous Shooting";
-        choices3[0]   = "Single Exposure";
-        choices3[1]   = "Multiple Exposure";
-        choices3[15]  = "Interval Movie";
-        choices3[16]  = "HDR";
-        choices3[32]  = "HDR Strong 1";
-        choices3[48]  = "HDR Strong 2";
-        choices3[64]  = "HDR Strong 3";
-        choices3[224] = "HDR Auto";
-        choices3[255] = "Video";
-    }
-    std::string toString (const Tag* t) const override
-    {
-        const ChoicesIterator r  = choices.find (t->toInt (0, BYTE));
-        std::map<int, std::string>::const_iterator r1 = choices1.find (t->toInt (1, BYTE));
-        std::map<int, std::string>::const_iterator r2 = choices2.find (t->toInt (2, BYTE));
-        std::map<int, std::string>::const_iterator r3 = choices3.find (t->toInt (3, BYTE));
-        std::ostringstream s;
-        s << ((r != choices.end()) ? r->second : "");
-        s << ((r1 != choices1.end()) ? r1->second : "") << " ";
-        s << ((r2 != choices2.end()) ? r2->second : "") << " ";
-        s << ((r3 != choices3.end()) ? r3->second : "") << " ";
-        return s.str();
-    }
-};
-PADriveModeInterpreter paDriveModeInterpreter;
-
-class PAColorSpaceInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PAColorSpaceInterpreter()
-    {
-        choices[0] = "sRGB";
-        choices[1] = "Adobe RGB";
-    }
-};
-PAColorSpaceInterpreter paColorSpaceInterpreter;
-
-class PALensTypeInterpreter final: public IntLensInterpreter< int >
-{
-public:
-    PALensTypeInterpreter ()
-    {
-        choices.insert (p_t (256 * 0 + 0, "M-42 or No Lens"));
-        choices.insert (p_t (256 * 1 + 0, "K or M Lens"));
-        choices.insert (p_t (256 * 2 + 0, "A Series Lens"));
-        choices.insert (p_t (256 * 3 + 0, "Sigma"));
-        choices.insert (p_t (256 * 3 + 17, "smc PENTAX-FA SOFT 85mm f/2.8"));
-        choices.insert (p_t (256 * 3 + 18, "smc PENTAX-F 1.7X AF ADAPTER"));
-        choices.insert (p_t (256 * 3 + 19, "smc PENTAX-F 24-50mm f/4"));
-        choices.insert (p_t (256 * 3 + 20, "smc PENTAX-F 35-80mm f/4-5.6"));
-        choices.insert (p_t (256 * 3 + 21, "smc PENTAX-F 80-200mm f/4.7-5.6"));
-        choices.insert (p_t (256 * 3 + 22, "smc PENTAX-F FISH-EYE 17-28mm f/3.5-4.5"));
-        choices.insert (p_t (256 * 3 + 23, "smc PENTAX-F 100-300mm f/4.5-5.6 or Sigma Lens"));
-        choices.insert (p_t (256 * 3 + 23, "Sigma AF 28-300mm f/3.5-5.6 DL IF"));
-        choices.insert (p_t (256 * 3 + 23, "Sigma AF 28-300mm f/3.5-6.3 DG IF Macro"));
-        choices.insert (p_t (256 * 3 + 23, "Tokina 80-200mm f/2.8 ATX-Pro"));
-        choices.insert (p_t (256 * 3 + 24, "smc PENTAX-F 35-135mm f/3.5-4.5"));
-        choices.insert (p_t (256 * 3 + 25, "smc PENTAX-F 35-105mm f/4-5.6 or Sigma or Tokina Lens"));
-        choices.insert (p_t (256 * 3 + 25, "Sigma 55-200mm f/4-5.6 DC"));
-        choices.insert (p_t (256 * 3 + 25, "Sigma AF 28-300mm f/3.5-5.6 DL IF"));
-        choices.insert (p_t (256 * 3 + 25, "Sigma AF 28-300mm f/3.5-6.3 DL IF"));
-        choices.insert (p_t (256 * 3 + 25, "Sigma AF 28-300mm f/3.5-6.3 DG IF Macro"));
-        choices.insert (p_t (256 * 3 + 25, "Tokina 80-200mm f/2.8 ATX-Pro"));
-        choices.insert (p_t (256 * 3 + 26, "smc PENTAX-F* 250-600mm f/5.6 ED[IF]"));
-        choices.insert (p_t (256 * 3 + 27, "smc PENTAX-F 28-80mm f/3.5-4.5 or Tokina Lens"));
-        choices.insert (p_t (256 * 3 + 27, "Tokina AT-X Pro AF 28-70mm f/2.6-2.8"));
-        choices.insert (p_t (256 * 3 + 28, "smc PENTAX-F 35-70mm f/3.5-4.5 or Tokina Lens"));
-        choices.insert (p_t (256 * 3 + 28, "Tokina 19-35mm f/3.5-4.5 AF"));
-        choices.insert (p_t (256 * 3 + 28, "Tokina AT-X AF 400mm f/5.6"));
-        choices.insert (p_t (256 * 3 + 29, "PENTAX-F 28-80mm f/3.5-4.5 or Sigma or Tokina Lens"));
-        choices.insert (p_t (256 * 3 + 29, "Sigma AF 18-125mm f/3.5-5.6 DC"));
-        choices.insert (p_t (256 * 3 + 29, "Tokina AT-X PRO 28-70mm f/2.6-2.8"));
-        choices.insert (p_t (256 * 3 + 30, "PENTAX-F 70-200mm f/4-5.6"));
-        choices.insert (p_t (256 * 3 + 31, "smc PENTAX-F 70-210mm f/4-5.6 or Tokina or Takumar Lens"));
-        choices.insert (p_t (256 * 3 + 31, "Tokina AF 730 75-300mm f/4.5-5.6"));
-        choices.insert (p_t (256 * 3 + 31, "Takumar-F 70-210mm f/4-5.6"));
-        choices.insert (p_t (256 * 3 + 32, "smc PENTAX-F 50mm f/1.4"));
-        choices.insert (p_t (256 * 3 + 33, "smc PENTAX-F 50mm f/1.7"));
-        choices.insert (p_t (256 * 3 + 34, "smc PENTAX-F 135mm f/2.8 [IF]"));
-        choices.insert (p_t (256 * 3 + 35, "smc PENTAX-F 28mm f/2.8"));
-        choices.insert (p_t (256 * 3 + 36, "Sigma 20mm f/1.8 EX DG Aspherical RF"));
-        choices.insert (p_t (256 * 3 + 38, "smc PENTAX-F* 300mm f/4.5 ED[IF]"));
-        choices.insert (p_t (256 * 3 + 39, "smc PENTAX-F* 600mm f/4 ED[IF]"));
-        choices.insert (p_t (256 * 3 + 40, "smc PENTAX-F Macro 100mm f/2.8"));
-        choices.insert (p_t (256 * 3 + 41, "smc PENTAX-F Macro 50mm f/2.8 or Sigma Lens"));
-        choices.insert (p_t (256 * 3 + 41, "Sigma 50mm f/2.8 Macro"));
-        choices.insert (p_t (256 * 3 + 42, "Sigma 300mm f/2.8 EX DG APO IF"));
-        choices.insert (p_t (256 * 3 + 44, "Sigma or Tamron Lens (3 44)"));
-        choices.insert (p_t (256 * 3 + 44, "Sigma AF 10-20mm f/4-5.6 EX DC"));
-        choices.insert (p_t (256 * 3 + 44, "Sigma 12-24mm f/4.5-5.6 EX DG"));
-        choices.insert (p_t (256 * 3 + 44, "Sigma 17-70mm f/2.8-4.5 DC Macro"));
-        choices.insert (p_t (256 * 3 + 44, "Sigma 18-50mm f/3.5-5.6 DC"));
-        choices.insert (p_t (256 * 3 + 44, "Sigma 17-35mm f/2.8-4 EX DG"));
-        choices.insert (p_t (256 * 3 + 44, "Tamron 35-90mm f/4-5.6 AF"));
-        choices.insert (p_t (256 * 3 + 44, "Sigma AF 18-35mm f/3.5-4.5 Aspherical"));
-        choices.insert (p_t (256 * 3 + 46, "Sigma or Samsung Lens (3 46)"));
-        choices.insert (p_t (256 * 3 + 46, "Sigma APO 70-200mm f/2.8 EX"));
-        choices.insert (p_t (256 * 3 + 46, "Sigma EX APO 100-300mm f/4 IF"));
-        choices.insert (p_t (256 * 3 + 46, "Samsung/Schneider D-XENON 50-200mm f/4-5.6 ED"));
-        choices.insert (p_t (256 * 3 + 50, "smc PENTAX-FA 28-70mm f/4 AL"));
-        choices.insert (p_t (256 * 3 + 51, "Sigma 28mm f/1.8 EX DG Aspherical Macro"));
-        choices.insert (p_t (256 * 3 + 52, "smc PENTAX-FA 28-200mm f/3.8-5.6 AL[IF] or Tamron Lens"));
-        choices.insert (p_t (256 * 3 + 52, "Tamron AF LD 28-200mm f/3.8-5.6 [IF] Aspherical (171D)"));
-        choices.insert (p_t (256 * 3 + 53, "smc PENTAX-FA 28-80mm f/3.5-5.6 AL"));
-        choices.insert (p_t (256 * 3 + 247, "smc PENTAX-DA FISH-EYE 10-17mm f/3.5-4.5 ED[IF]"));
-        choices.insert (p_t (256 * 3 + 248, "smc PENTAX-DA 12-24mm f/4 ED AL[IF]"));
-        choices.insert (p_t (256 * 3 + 250, "smc PENTAX-DA 50-200mm f/4-5.6 ED"));
-        choices.insert (p_t (256 * 3 + 251, "smc PENTAX-DA 40mm f/2.8 Limited"));
-        choices.insert (p_t (256 * 3 + 252, "smc PENTAX-DA 18-55mm f/3.5-5.6 AL"));
-        choices.insert (p_t (256 * 3 + 253, "smc PENTAX-DA 14mm f/2.8 ED[IF]"));
-        choices.insert (p_t (256 * 3 + 254, "smc PENTAX-DA 16-45mm f/4 ED AL"));
-        choices.insert (p_t (256 * 3 + 255, "Sigma Lens (3 255)"));
-        choices.insert (p_t (256 * 3 + 255, "Sigma 18-200mm f/3.5-6.3 DC"));
-        choices.insert (p_t (256 * 3 + 255, "Sigma DL-II 35-80mm f/4-5.6"));
-        choices.insert (p_t (256 * 3 + 255, "Sigma DL Zoom 75-300mm f/4-5.6"));
-        choices.insert (p_t (256 * 3 + 255, "Sigma DF EX Aspherical 28-70mm f/2.8"));
-        choices.insert (p_t (256 * 3 + 255, "Sigma AF Tele 400mm f/5.6 Multi-coated"));
-        choices.insert (p_t (256 * 3 + 255, "Sigma 24-60mm f/2.8 EX DG"));
-        choices.insert (p_t (256 * 3 + 255, "Sigma 70-300mm f/4-5.6 Macro"));
-        choices.insert (p_t (256 * 3 + 255, "Sigma 55-200mm f/4-5.6 DC"));
-        choices.insert (p_t (256 * 3 + 255, "Sigma 18-50mm f/2.8 EX DC"));
-        choices.insert (p_t (256 * 4 + 1, "smc PENTAX-FA SOFT 28mm f/2.8"));
-        choices.insert (p_t (256 * 4 + 2, "smc PENTAX-FA 80-320mm f/4.5-5.6"));
-        choices.insert (p_t (256 * 4 + 3, "smc PENTAX-FA 43mm f/1.9 Limited"));
-        choices.insert (p_t (256 * 4 + 6, "smc PENTAX-FA 35-80mm f/4-5.6"));
-        choices.insert (p_t (256 * 4 + 8, "Irix 150mm f/2.8 Macro"));
-        choices.insert (p_t (256 * 4 + 9, "Irix 11mm f/4 Firefly"));
-        choices.insert (p_t (256 * 4 + 10, "Irix 15mm f/2.4"));
-        choices.insert (p_t (256 * 4 + 12, "smc PENTAX-FA 50mm f/1.4"));
-        choices.insert (p_t (256 * 4 + 15, "smc PENTAX-FA 28-105mm f/4-5.6 [IF]"));
-        choices.insert (p_t (256 * 4 + 16, "Tamron AF 80-210mm f/4-5.6 (178D)"));
-        choices.insert (p_t (256 * 4 + 19, "Tamron SP AF 90mm f/2.8 (172E)"));
-        choices.insert (p_t (256 * 4 + 20, "smc PENTAX-FA 28-80mm f/3.5-5.6"));
-        choices.insert (p_t (256 * 4 + 21, "Cosina AF 100-300mm f/5.6-6.7"));
-        choices.insert (p_t (256 * 4 + 22, "Tokina 28-80mm f/3.5-5.6"));
-        choices.insert (p_t (256 * 4 + 23, "smc PENTAX-FA 20-35mm f/4 AL"));
-        choices.insert (p_t (256 * 4 + 24, "smc PENTAX-FA 77mm f/1.8 Limited"));
-        choices.insert (p_t (256 * 4 + 25, "Tamron SP AF 14mm f/2.8"));
-        choices.insert (p_t (256 * 4 + 26, "smc PENTAX-FA Macro 100mm f/3.5 or Cosina Lens"));
-        choices.insert (p_t (256 * 4 + 26, "Cosina 100mm f/3.5 Macro"));
-        choices.insert (p_t (256 * 4 + 27, "Tamron AF 28-300mm f/3.5-6.3 LD Aspherical[IF] Macro (185D/285D)"));
-        choices.insert (p_t (256 * 4 + 28, "smc PENTAX-FA 35mm f/2 AL"));
-        choices.insert (p_t (256 * 4 + 29, "Tamron AF 28-200mm f/3.8-5.6 LD Super II Macro (371D)"));
-        choices.insert (p_t (256 * 4 + 34, "smc PENTAX-FA 24-90mm f/3.5-4.5 AL[IF]"));
-        choices.insert (p_t (256 * 4 + 35, "smc PENTAX-FA 100-300mm f/4.7-5.8"));
-        choices.insert (p_t (256 * 4 + 36, "Tamron AF 70-300mm f/4-5.6 LD Macro 1:2"));
-        choices.insert (p_t (256 * 4 + 37, "Tamron SP AF 24-135mm f/3.5-5.6 AD AL (190D)"));
-        choices.insert (p_t (256 * 4 + 38, "smc PENTAX-FA 28-105mm f/3.2-4.5 AL[IF]"));
-        choices.insert (p_t (256 * 4 + 39, "smc PENTAX-FA 31mm f/1.8 AL Limited"));
-        choices.insert (p_t (256 * 4 + 41, "Tamron AF 28-200mm Super Zoom f/3.8-5.6 Aspherical XR [IF] Macro (A03)"));
-        choices.insert (p_t (256 * 4 + 43, "smc PENTAX-FA 28-90mm f/3.5-5.6"));
-        choices.insert (p_t (256 * 4 + 44, "smc PENTAX-FA J 75-300mm f/4.5-5.8 AL"));
-        choices.insert (p_t (256 * 4 + 45, "Tamron Lens (4 45)"));
-        choices.insert (p_t (256 * 4 + 45, "Tamron 28-300mm f/3.5-6.3 Ultra zoom XR"));
-        choices.insert (p_t (256 * 4 + 45, "Tamron AF 28-300mm f/3.5-6.3 XR Di LD Aspherical [IF] Macro"));
-        choices.insert (p_t (256 * 4 + 46, "smc PENTAX-FA J 28-80mm f/3.5-5.6 AL"));
-        choices.insert (p_t (256 * 4 + 47, "smc PENTAX-FA J 18-35mm f/4-5.6 AL"));
-        choices.insert (p_t (256 * 4 + 49, "Tamron SP AF 28-75mm f/2.8 XR Di LD Aspherical [IF] Macro"));
-        choices.insert (p_t (256 * 4 + 51, "smc PENTAX-D FA 50mm f/2.8 Macro"));
-        choices.insert (p_t (256 * 4 + 52, "smc PENTAX-D FA 100mm f/2.8 Macro"));
-        choices.insert (p_t (256 * 4 + 55, "Samsung/Schneider D-XENOGON 35mm f/2"));
-        choices.insert (p_t (256 * 4 + 56, "Samsung/Schneider D-XENON 100mm f/2.8 Macro"));
-        choices.insert (p_t (256 * 4 + 75, "Tamron SP AF 70-200mm f/2.8 Di LD [IF] Macro (A001)"));
-        choices.insert (p_t (256 * 4 + 214, "smc PENTAX-DA 35mm f/2.4 AL"));
-        choices.insert (p_t (256 * 4 + 229, "smc PENTAX-DA 18-55mm f/3.5-5.6 AL II"));
-        choices.insert (p_t (256 * 4 + 230, "Tamron SP AF 17-50mm f/2.8 XR Di II"));
-        choices.insert (p_t (256 * 4 + 231, "smc PENTAX-DA 18-250mm f/3.5-6.3 ED AL [IF]"));
-        choices.insert (p_t (256 * 4 + 237, "Samsung/Schneider D-XENOGON 10-17mm f/3.5-4.5"));
-        choices.insert (p_t (256 * 4 + 239, "Samsung/Schneider D-XENON 12-24mm f/4 ED AL [IF]"));
-        choices.insert (p_t (256 * 4 + 242, "smc PENTAX-DA* 16-50mm f/2.8 ED AL [IF] SDM (SDM unused)"));
-        choices.insert (p_t (256 * 4 + 243, "smc PENTAX-DA 70mm f/2.4 Limited"));
-        choices.insert (p_t (256 * 4 + 244, "smc PENTAX-DA 21mm f/3.2 AL Limited"));
-        choices.insert (p_t (256 * 4 + 245, "Samsung/Schneider D-XENON 50-200mm f/4-5.6"));
-        choices.insert (p_t (256 * 4 + 246, "Samsung/Schneider D-XENON 18-55mm f/3.5-5.6"));
-        choices.insert (p_t (256 * 4 + 247, "smc PENTAX-DA FISH-EYE 10-17mm f/3.5-4.5 ED[IF]"));
-        choices.insert (p_t (256 * 4 + 248, "smc PENTAX-DA 12-24mm f/4 ED AL [IF]"));
-        choices.insert (p_t (256 * 4 + 249, "Tamron XR DiII 18-200mm f/3.5-6.3 (A14)"));
-        choices.insert (p_t (256 * 4 + 250, "smc PENTAX-DA 50-200mm f/4-5.6 ED"));
-        choices.insert (p_t (256 * 4 + 251, "smc PENTAX-DA 40mm f/2.8 Limited"));
-        choices.insert (p_t (256 * 4 + 252, "smc PENTAX-DA 18-55mm f/3.5-5.6 AL"));
-        choices.insert (p_t (256 * 4 + 253, "smc PENTAX-DA 14mm f/2.8 ED[IF]"));
-        choices.insert (p_t (256 * 4 + 254, "smc PENTAX-DA 16-45mm f/4 ED AL"));
-        choices.insert (p_t (256 * 5 + 1, "smc PENTAX-FA* 24mm f/2 AL[IF]"));
-        choices.insert (p_t (256 * 5 + 2, "smc PENTAX-FA 28mm f/2.8 AL"));
-        choices.insert (p_t (256 * 5 + 3, "smc PENTAX-FA 50mm f/1.7"));
-        choices.insert (p_t (256 * 5 + 4, "smc PENTAX-FA 50mm f/1.4"));
-        choices.insert (p_t (256 * 5 + 5, "smc PENTAX-FA* 600mm f/4 ED[IF]"));
-        choices.insert (p_t (256 * 5 + 6, "smc PENTAX-FA* 300mm f/4.5 ED[IF]"));
-        choices.insert (p_t (256 * 5 + 7, "smc PENTAX-FA 135mm f/2.8 [IF]"));
-        choices.insert (p_t (256 * 5 + 8, "smc PENTAX-FA Macro 50mm f/2.8"));
-        choices.insert (p_t (256 * 5 + 9, "smc PENTAX-FA Macro 100mm f/2.8"));
-        choices.insert (p_t (256 * 5 + 10, "smc PENTAX-FA* 85mm f/1.4 [IF]"));
-        choices.insert (p_t (256 * 5 + 11, "smc PENTAX-FA* 200mm f/2.8 ED[IF]"));
-        choices.insert (p_t (256 * 5 + 12, "smc PENTAX-FA 28-80mm f/3.5-4.7"));
-        choices.insert (p_t (256 * 5 + 13, "smc PENTAX-FA 70-200mm f/4-5.6"));
-        choices.insert (p_t (256 * 5 + 14, "smc PENTAX-FA* 250-600mm f/5.6 ED[IF]"));
-        choices.insert (p_t (256 * 5 + 15, "smc PENTAX-FA 28-105mm f/4-5.6"));
-        choices.insert (p_t (256 * 5 + 16, "smc PENTAX-FA 100-300mm f/4.5-5.6"));
-        choices.insert (p_t (256 * 5 + 98, "smc PENTAX-FA 100-300mm f/4.5-5.6"));
-        choices.insert (p_t (256 * 6 + 1, "smc PENTAX-FA* 85mm f/1.4 [IF]"));
-        choices.insert (p_t (256 * 6 + 2, "smc PENTAX-FA* 200mm f/2.8 ED[IF]"));
-        choices.insert (p_t (256 * 6 + 3, "smc PENTAX-FA* 300mm f/2.8 ED[IF]"));
-        choices.insert (p_t (256 * 6 + 4, "smc PENTAX-FA* 28-70mm f/2.8 AL"));
-        choices.insert (p_t (256 * 6 + 5, "smc PENTAX-FA* 80-200mm f/2.8 ED[IF]"));
-        choices.insert (p_t (256 * 6 + 6, "smc PENTAX-FA* 28-70mm f/2.8 AL"));
-        choices.insert (p_t (256 * 6 + 7, "smc PENTAX-FA* 80-200mm f/2.8 ED[IF]"));
-        choices.insert (p_t (256 * 6 + 8, "smc PENTAX-FA 28-70mm f/4AL"));
-        choices.insert (p_t (256 * 6 + 9, "smc PENTAX-FA 20mm f/2.8"));
-        choices.insert (p_t (256 * 6 + 10, "smc PENTAX-FA* 400mm f/5.6 ED[IF]"));
-        choices.insert (p_t (256 * 6 + 13, "smc PENTAX-FA* 400mm f/5.6 ED[IF]"));
-        choices.insert (p_t (256 * 6 + 14, "smc PENTAX-FA* Macro 200mm f/4 ED[IF]"));
-        choices.insert (p_t (256 * 7 + 0, "smc PENTAX-DA 21mm f/3.2 AL Limited"));
-        choices.insert (p_t (256 * 7 + 58, "smc PENTAX-D FA Macro 100mm f/2.8 WR"));
-        choices.insert (p_t (256 * 7 + 75, "Tamron SP AF 70-200mm f/2.8 Di LD [IF] Macro (A001)"));
-        choices.insert (p_t (256 * 7 + 201, "smc Pentax-DA L 50-200mm f/4-5.6 ED WR"));
-        choices.insert (p_t (256 * 7 + 202, "smc PENTAX-DA L 18-55mm f/3.5-5.6 AL WR"));
-        choices.insert (p_t (256 * 7 + 203, "HD PENTAX-DA 55-300mm f/4-5.8 ED WR"));
-        choices.insert (p_t (256 * 7 + 204, "HD PENTAX-DA 15mm f/4 ED AL Limited"));
-        choices.insert (p_t (256 * 7 + 205, "HD PENTAX-DA 35mm f/2.8 Macro Limited"));
-        choices.insert (p_t (256 * 7 + 206, "HD PENTAX-DA 70mm f/2.4 Limited"));
-        choices.insert (p_t (256 * 7 + 207, "HD PENTAX-DA 21mm f/3.2 ED AL Limited"));
-        choices.insert (p_t (256 * 7 + 208, "HD PENTAX-DA 40mm f/2.8 Limited"));
-        choices.insert (p_t (256 * 7 + 212, "smc PENTAX-DA 50mm f/1.8"));
-        choices.insert (p_t (256 * 7 + 213, "smc PENTAX-DA 40mm f/2.8 XS"));
-        choices.insert (p_t (256 * 7 + 214, "smc PENTAX-DA 35mm f/2.4 AL"));
-        choices.insert (p_t (256 * 7 + 216, "smc PENTAX-DA L 55-300mm f/4-5.8 ED"));
-        choices.insert (p_t (256 * 7 + 217, "smc PENTAX-DA 50-200mm f/4-5.6 ED WR"));
-        choices.insert (p_t (256 * 7 + 218, "smc PENTAX-DA 18-55mm f/3.5-5.6 AL WR"));
-        choices.insert (p_t (256 * 7 + 220, "Tamron SP AF 10-24mm f/3.5-4.5 Di II LD Aspherical [IF]"));
-        choices.insert (p_t (256 * 7 + 221, "smc PENTAX-DA L 50-200mm f/4-5.6 ED"));
-        choices.insert (p_t (256 * 7 + 222, "smc PENTAX-DA L 18-55mm f/3.5-5.6"));
-        choices.insert (p_t (256 * 7 + 223, "Samsung/Schneider D-XENON 18-55mm f/3.5-5.6 II"));
-        choices.insert (p_t (256 * 7 + 224, "smc PENTAX-DA 15mm f/4 ED AL Limited"));
-        choices.insert (p_t (256 * 7 + 225, "Samsung/Schneider D-XENON 18-250mm f/3.5-6.3"));
-        choices.insert (p_t (256 * 7 + 226, "smc PENTAX-DA* 55mm f/1.4 SDM (SDM unused)"));
-        choices.insert (p_t (256 * 7 + 227, "smc PENTAX-DA* 60-250mm f/4 [IF] SDM (SDM unused)"));
-        choices.insert (p_t (256 * 7 + 228, "Samsung 16-45mm f/4 ED"));
-        choices.insert (p_t (256 * 7 + 229, "smc PENTAX-DA 18-55mm f/3.5-5.6 AL II"));
-        choices.insert (p_t (256 * 7 + 230, "Tamron AF 17-50mm f/2.8 XR Di-II LD (Model A16)"));
-        choices.insert (p_t (256 * 7 + 231, "smc PENTAX-DA 18-250mm f/3.5-6.3 ED AL [IF]"));
-        choices.insert (p_t (256 * 7 + 233, "smc PENTAX-DA 35mm f/2.8 Macro Limited"));
-        choices.insert (p_t (256 * 7 + 234, "smc PENTAX-DA* 300mm f/4 ED [IF] SDM (SDM unused)"));
-        choices.insert (p_t (256 * 7 + 235, "smc PENTAX-DA* 200mm f/2.8 ED [IF] SDM (SDM unused)"));
-        choices.insert (p_t (256 * 7 + 236, "smc PENTAX-DA 55-300mm f/4-5.8 ED"));
-        choices.insert (p_t (256 * 7 + 238, "Tamron AF 18-250mm f/3.5-6.3 Di II LD Aspherical [IF] Macro"));
-        choices.insert (p_t (256 * 7 + 241, "smc PENTAX-DA* 50-135mm f/2.8 ED [IF] SDM (SDM unused)"));
-        choices.insert (p_t (256 * 7 + 242, "smc PENTAX-DA* 16-50mm f/2.8 ED AL [IF] SDM (SDM unused)"));
-        choices.insert (p_t (256 * 7 + 243, "smc PENTAX-DA 70mm f/2.4 Limited"));
-        choices.insert (p_t (256 * 7 + 244, "smc PENTAX-DA 21mm f/3.2 AL Limited"));
-        choices.insert (p_t (256 * 8 + 0, "Sigma 50-150mm f/2.8 II APO EX DC HSM"));
-        choices.insert (p_t (256 * 8 + 3, "Sigma 18-125mm f/3.8-5.6 DC HSM"));
-        choices.insert (p_t (256 * 8 + 4, "Sigma 50mm f/1.4 EX DG HSM"));
-        choices.insert (p_t (256 * 8 + 6, "Sigma 4.5mm f/2.8 EX DC Fisheye"));
-        choices.insert (p_t (256 * 8 + 7, "Sigma 24-70mm f/2.8 IF EX DG HSM"));
-        choices.insert (p_t (256 * 8 + 8, "Sigma 18-250mm f/3.5-6.3 DC OS HSM"));
-        choices.insert (p_t (256 * 8 + 11, "Sigma 10-20mm f/3.5 EX DC HSM"));
-        choices.insert (p_t (256 * 8 + 12, "Sigma 70-300mm f/4-5.6 DG OS"));
-        choices.insert (p_t (256 * 8 + 13, "Sigma 120-400mm f/4.5-5.6 APO DG OS HSM"));
-        choices.insert (p_t (256 * 8 + 14, "Sigma 17-70mm f/2.8-4.0 DC Macro OS HSM"));
-        choices.insert (p_t (256 * 8 + 15, "Sigma 150-500mm f/5-6.3 APO DG OS HSM"));
-        choices.insert (p_t (256 * 8 + 16, "Sigma 70-200mm f/2.8 EX DG Macro HSM II"));
-        choices.insert (p_t (256 * 8 + 17, "Sigma 50-500mm f/4.5-6.3 DG OS HSM"));
-        choices.insert (p_t (256 * 8 + 18, "Sigma 8-16mm f/4.5-5.6 DC HSM"));
-        choices.insert (p_t (256 * 8 + 20, "Sigma 18-50mm f/2.8-4.5 DC HSM"));
-        choices.insert (p_t (256 * 8 + 21, "Sigma 17-50mm f/2.8 EX DC OS HSM"));
-        choices.insert (p_t (256 * 8 + 22, "Sigma 85mm f/1.4 EX DG HSM"));
-        choices.insert (p_t (256 * 8 + 23, "Sigma 70-200mm f/2.8 APO EX DG OS HSM"));
-        choices.insert (p_t (256 * 8 + 24, "Sigma 17-70mm f/2.8-4 DC Macro OS HSM"));
-        choices.insert (p_t (256 * 8 + 25, "Sigma 17-50mm f/2.8 EX DC HSM"));
-        choices.insert (p_t (256 * 8 + 27, "Sigma 18-200mm f/3.5-6.3 II DC HSM"));
-        choices.insert (p_t (256 * 8 + 28, "Sigma 18-250mm f/3.5-6.3 DC Macro HSM"));
-        choices.insert (p_t (256 * 8 + 29, "Sigma 35mm f/1.4 DG HSM"));
-        choices.insert (p_t (256 * 8 + 30, "Sigma 17-70mm f/2.8-4 DC Macro HSM | C"));
-        choices.insert (p_t (256 * 8 + 31, "Sigma 18-35mm f/1.8 DC HSM"));
-        choices.insert (p_t (256 * 8 + 32, "Sigma 30mm f/1.4 DC HSM | A"));
-        choices.insert (p_t (256 * 8 + 33, "Sigma 18-200mm f/3.5-6.3 DC Macro HSM"));
-        choices.insert (p_t (256 * 8 + 34, "Sigma 18-300mm f/3.5-6.3 DC Macro HSM"));
-        choices.insert (p_t (256 * 8 + 59, "HD PENTAX-D FA 150-450mm f/4.5-5.6 ED DC AW"));
-        choices.insert (p_t (256 * 8 + 60, "HD PENTAX-D FA* 70-200mm f/2.8 ED DC AW"));
-        choices.insert (p_t (256 * 8 + 61, "HD PENTAX-D FA 28-105mm f/3.5-5.6 ED DC WR"));
-        choices.insert (p_t (256 * 8 + 62, "HD PENTAX-D FA 24-70mm f/2.8 ED SDM WR"));
-        choices.insert (p_t (256 * 8 + 63, "HD PENTAX-D FA 15-30mm f/2.8 ED SDM WR"));
-        choices.insert (p_t (256 * 8 + 64, "HD PENTAX-D FA* 50mm f/1.4 SDM AW"));
-        choices.insert (p_t (256 * 8 + 65, "HD PENTAX-D FA 70-210mm f/4 ED SDM WR"));
-        choices.insert (p_t (256 * 8 + 66, "HD PENTAX-D FA 85mm f/1.4 ED SDM AW"));
-        choices.insert (p_t (256 * 8 + 67, "HD PENTAX-D FA 21mm f/2.4 ED Limited DC WR"));
-        choices.insert (p_t (256 * 8 + 195, "HD PENTAX DA* 16-50mm f/2.8 ED PLM AW"));
-        choices.insert (p_t (256 * 8 + 196, "HD PENTAX-DA* 11-18mm f/2.8 ED DC AW"));
-        choices.insert (p_t (256 * 8 + 197, "HD PENTAX-DA 55-300mm f/4.5-6.3 ED PLM WR RE"));
-        choices.insert (p_t (256 * 8 + 198, "smc PENTAX-DA L 18-50mm f/4-5.6 DC WR RE"));
-        choices.insert (p_t (256 * 8 + 199, "HD PENTAX-DA 18-50mm f/4-5.6 DC WR RE"));
-        choices.insert (p_t (256 * 8 + 200, "HD PENTAX-DA 16-85mm f/3.5-5.6 ED DC WR"));
-        choices.insert (p_t (256 * 8 + 209, "HD PENTAX-DA 20-40mm f/2.8-4 ED Limited DC WR"));
-        choices.insert (p_t (256 * 8 + 210, "smc PENTAX-DA 18-270mm f/3.5-6.3 ED SDM"));
-        choices.insert (p_t (256 * 8 + 211, "HD PENTAX-DA 560mm f/5.6 ED AW"));
-        choices.insert (p_t (256 * 8 + 215, "smc PENTAX-DA 18-135mm f/3.5-5.6 ED AL [IF] DC WR"));
-        choices.insert (p_t (256 * 8 + 226, "smc PENTAX-DA* 55mm f/1.4 SDM"));
-        choices.insert (p_t (256 * 8 + 227, "smc PENTAX-DA* 60-250mm f/4 [IF] SDM"));
-        choices.insert (p_t (256 * 8 + 232, "smc PENTAX-DA 17-70mm f/4 AL [IF] SDM"));
-        choices.insert (p_t (256 * 8 + 234, "smc PENTAX-DA* 300mm f/4 ED [IF] SDM"));
-        choices.insert (p_t (256 * 8 + 235, "smc PENTAX-DA* 200mm f/2.8 ED [IF] SDM"));
-        choices.insert (p_t (256 * 8 + 241, "smc PENTAX-DA* 50-135mm f/2.8 ED [IF] SDM"));
-        choices.insert (p_t (256 * 8 + 242, "smc PENTAX-DA* 16-50mm f/2.8 ED AL [IF] SDM"));
-        choices.insert (p_t (256 * 8 + 255, "Sigma Lens (8 255)"));
-        choices.insert (p_t (256 * 8 + 255, "Sigma 70-200mm f/2.8 EX DG Macro HSM II"));
-        choices.insert (p_t (256 * 8 + 255, "Sigma 150-500mm f/5-6.3 DG APO [OS] HSM"));
-        choices.insert (p_t (256 * 8 + 255, "Sigma 50-150mm f/2.8 II APO EX DC HSM"));
-        choices.insert (p_t (256 * 8 + 255, "Sigma 4.5mm f/2.8 EX DC HSM Circular Fisheye"));
-        choices.insert (p_t (256 * 8 + 255, "Sigma 50-200mm f/4-5.6 DC OS"));
-        choices.insert (p_t (256 * 8 + 255, "Sigma 24-70mm f/2.8 EX DG HSM"));
-        choices.insert (p_t (256 * 9 + 0, "645 Manual Lens"));
-        choices.insert (p_t (256 * 10 + 0, "645 A Series Lens"));
-        choices.insert (p_t (256 * 11 + 1, "smc PENTAX-FA 645 75mm f/2.8"));
-        choices.insert (p_t (256 * 11 + 2, "smc PENTAX-FA 645 45mm f/2.8"));
-        choices.insert (p_t (256 * 11 + 3, "smc PENTAX-FA* 645 300mm f/4 ED [IF]"));
-        choices.insert (p_t (256 * 11 + 4, "smc PENTAX-FA 645 45-85mm f/4.5"));
-        choices.insert (p_t (256 * 11 + 5, "smc PENTAX-FA 645 400mm f/5.6 ED [IF]"));
-        choices.insert (p_t (256 * 11 + 7, "smc PENTAX-FA 645 Macro 120mm f/4"));
-        choices.insert (p_t (256 * 11 + 8, "smc PENTAX-FA 645 80-160mm f/4.5"));
-        choices.insert (p_t (256 * 11 + 9, "smc PENTAX-FA 645 200mm f/4 [IF]"));
-        choices.insert (p_t (256 * 11 + 10, "smc PENTAX-FA 645 150mm f/2.8 [IF]"));
-        choices.insert (p_t (256 * 11 + 11, "smc PENTAX-FA 645 35mm f/3.5 AL [IF]"));
-        choices.insert (p_t (256 * 11 + 12, "smc PENTAX-FA 645 300mm f/5.6 ED [IF]"));
-        choices.insert (p_t (256 * 11 + 14, "smc PENTAX-FA 645 55-110mm f/5.6"));
-        choices.insert (p_t (256 * 11 + 16, "smc PENTAX-FA 645 33-55mm f/4.5 AL"));
-        choices.insert (p_t (256 * 11 + 17, "smc PENTAX-FA 645 150-300mm f/5.6 ED [IF]"));
-        choices.insert (p_t (256 * 11 + 21, "HD PENTAX-D FA 645 35mm f/3.5 AL [IF]"));
-        choices.insert (p_t (256 * 13 + 18, "smc PENTAX-D FA 645 55mm f/2.8 AL [IF] SDM AW"));
-        choices.insert (p_t (256 * 13 + 19, "smc PENTAX-D FA 645 25mm f/4 AL [IF] SDM AW"));
-        choices.insert (p_t (256 * 13 + 20, "HD PENTAX-D FA 645 90mm f/2.8 ED AW SR"));
-        choices.insert (p_t (256 * 13 + 253, "HD PENTAX-DA 645 28-45mm f/4.5 ED AW SR"));
-        choices.insert (p_t (256 * 13 + 254, "smc PENTAX-DA 645 25mm f/4 AL [IF] SDM AW"));
-        choices.insert (p_t (256 * 21 + 0, "Pentax Q Manual Lens"));
-        choices.insert (p_t (256 * 21 + 1, "01 Standard Prime 8.5mm f/1.9"));
-        choices.insert (p_t (256 * 21 + 2, "02 Standard Zoom 5-15mm f/2.8-4.5"));
-        choices.insert (p_t (256 * 21 + 6, "06 Telephoto Zoom 15-45mm f/2.8"));
-        choices.insert (p_t (256 * 21 + 7, "07 Mount Shield 11.5mm f/9"));
-        choices.insert (p_t (256 * 21 + 8, "08 Wide Zoom 3.8-5.9mm f/3.7-4"));
-        choices.insert (p_t (256 * 21 + 233, "Adapter Q for K-mount Lens"));
-        choices.insert (p_t (256 * 22 + 3, "03 Fish-eye 3.2mm f/5.6"));
-        choices.insert (p_t (256 * 22 + 4, "04 Toy Lens Wide 6.3mm f/7.1"));
-        choices.insert (p_t (256 * 22 + 5, "05 Toy Lens Telephoto 18mm f/8"));
-        choices.insert (p_t (256 * 31 + 1, "GR Lens"));
-    }
-    std::string toString (const Tag* t) const override
-    {
-        double *liArray = nullptr;
-        double maxApertureAtFocal = 0.;
-        double focalLength = 0.;
-        int lensID = 256 * t->toInt (0, BYTE) + t->toInt (1, BYTE);
-        TagDirectory *root = t->getParent()->getRoot();
-
-        if (root) {
-
-            Tag *t1;
-            t1 = root->findTag ("FocalLength"); // Should get tag 0x920A (rational64u) from the standard Exif tag list
-
-            if ( t1) {
-                focalLength = t1->toDouble();    // Focal Length
-            }
-
-            t1 = root->findTag ("MaxAperture");
-
-            if (t1) {
-                double maxAperture = t1->toDouble(); // MaxApertureValue at focal Length
-
-                if (maxAperture != 0.) {
-                    maxApertureAtFocal = maxAperture;
-                } else {
-                    t1 = root->findTag ("NominalMaxAperture");
-
-                    if (t1) {
-                        maxApertureAtFocal = t1->toDouble();
-                    }
-                }
-            }
-
-            t1 = root->getTagP ("LensInfo");
-
-            if (t1) {
-                liArray = t1->toDoubleArray();
-            }
-
-            // Focal length below 10mm are set to 0 by the camera in the standard Exif tag, so we'll look into the makernotes
-            // This value will have decimals, which reflects more precision... or imprecision, due to the packed form of this value, who knows?
-            if (focalLength == 0.) {
-                rtexif::TagDirectory* mnote = root->findTag ("MakerNote")->getDirectory();
-                rtexif::Tag* flt = mnote->getTagP ("LensInfo/FocalLength");
-
-                if (flt) {
-                    focalLength = flt->toDouble ();
-                } else if ((flt = mnote->getTagP ("FocalLength"))) {
-                    focalLength = flt->toDouble();
-                }
-            }
-        }
-
-        std::string retval = guess ( lensID, focalLength, maxApertureAtFocal, liArray);
-
-        if (liArray) {
-            delete [] liArray;
-        }
-
-        return retval;
-    }
-};
-PALensTypeInterpreter paLensTypeInterpreter;
-
-class PASRResultInterpreter: public Interpreter
-{
-public:
-    PASRResultInterpreter() { }
-    std::string toString (const Tag* t) const override
-    {
-        std::ostringstream str;
-        int b = t->toInt (0, BYTE);
-
-        if (!b) {
-            str << "Not stabilized";
-        } else if (b & 1) {
-            str << "Stabilized";
-        } else if (b & 64) {
-            str << "Not Ready";
-        }
-
-        return str.str();
-    }
-};
-PASRResultInterpreter paSRResultInterpreter;
-
-class PAHighISONoiseInterpreter: public ChoiceInterpreter<>
-{
-public:
-    // HighISONoiseReduction
-    PAHighISONoiseInterpreter()
-    {
-        choices[0] = "Off";
-        choices[1] = "Weakest";
-        choices[2] = "Weak";
-        choices[3] = "Strong";
-        choices[4] = "Medium";
-        choices[255] = "Auto";
-    }
-};
-PAHighISONoiseInterpreter paHighISONoiseInterpreter;
-
-class PAMonochromeFilterEffectInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PAMonochromeFilterEffectInterpreter()
-    {
-        choices[1] = "Green";
-        choices[2] = "Yellow";
-        choices[3] = "Orange";
-        choices[4] = "Red";
-        choices[5] = "Magenta";
-        choices[6] = "Blue";
-        choices[7] = "Cyan";
-        choices[8] = "Infrared";
-        choices[65535] = "None";
-    }
-};
-PAMonochromeFilterEffectInterpreter paMonochromeFilterEffectInterpreter;
-
-class PAMonochromeToningInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PAMonochromeToningInterpreter()
-    {
-        choices[0] = "-4";
-        choices[1] = "-3";
-        choices[2] = "-2";
-        choices[3] = "-1";
-        choices[4] = "0";
-        choices[5] = "1";
-        choices[6] = "2";
-        choices[7] = "3";
-        choices[8] = "4";
-        choices[65535] = "None";
-    }
-};
-PAMonochromeToningInterpreter paMonochromeToningInterpreter;
-
-class PAShadowCorrectionInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PAShadowCorrectionInterpreter()
-    {
-        choices[        0 ] = "Off";
-        choices[        1 ] = "On";
-        choices[        2 ] = "Auto 2";
-        choices[ 1 << 8 | 1 ] = "Weak";
-        choices[ 1 << 8 | 2 ] = "Normal";
-        choices[ 1 << 8 | 3 ] = "Strong";
-        choices[ 2 << 8 | 4 ] = "Auto";
-    }
-
-    std::string toString (const Tag* t) const override
-    {
-        int idx = 0;
-
-        if (t->getCount() == 1) {
-            idx = t->toInt (0, BYTE);
-        } else if (t->getCount() == 2) {
-            idx = t->toInt (0, BYTE) << 8 | t->toInt (1, BYTE);
-        }
-
-        const ChoicesIterator r  = choices.find (idx);
-        std::ostringstream s;
-        s << ((r != choices.end()) ? r->second : "n/a");
-        return s.str();
-    }
-};
-PAShadowCorrectionInterpreter paShadowCorrectionInterpreter;
-
-class PAISOAutoParametersInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PAISOAutoParametersInterpreter()
-    {
-        choices[1] = "Slow";
-        choices[2] = "Standard";
-        choices[3] = "Fast";
-    }
-    std::string toString (const Tag* t) const override
-    {
-        const ChoicesIterator r  = choices.find (t->toInt (0, BYTE));
-        std::ostringstream s;
-        s << ((r != choices.end()) ? r->second : "n/a");
-        return s.str();
-    }
-};
-PAISOAutoParametersInterpreter paISOAutoParametersInterpreter;
-
-class PABleachBypassToningInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PABleachBypassToningInterpreter()
-    {
-        choices[1] = "Green";
-        choices[2] = "Yellow";
-        choices[3] = "Orange";
-        choices[4] = "Red";
-        choices[5] = "Magenta";
-        choices[6] = "Purple";
-        choices[7] = "Blue";
-        choices[8] = "Cyan";
-        choices[65535] = "Off";
-    }
-};
-PABleachBypassToningInterpreter paBleachBypassToningInterpreter;
-
-class PABlurControlInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PABlurControlInterpreter()
-    {
-        choices[0] = "Off";
-        choices[1] = "Low";
-        choices[2] = "Medium";
-        choices[3] = "High";
-    }
-    std::string toString (const Tag* t) const override
-    {
-        const ChoicesIterator r  = choices.find (t->toInt (0, BYTE));
-        std::ostringstream s;
-        s << ((r != choices.end()) ? r->second : "n/a");
-        return s.str();
-    }
-};
-PABlurControlInterpreter paBlurControlInterpreter;
-
-class PAHDRInterpreter: public ChoiceInterpreter<>
-{
-    std::map<int, std::string> choices1;
-    std::map<int, std::string> choices2;
-public:
-    PAHDRInterpreter()
-    {
-        choices[0]    = "Off";
-        choices[1]    = "HDR Auto";
-        choices[2]    = "HDR 1";
-        choices[3]    = "HDR 2";
-        choices[4]    = "HDR 3";
-        choices[5]    = "Advanced";
-
-        choices1[0]   = "Auto-align Off";
-        choices1[1]   = "Auto-align On";
-
-        choices2[0]   = "n/a";
-        choices2[4]   = "1 EV";
-        choices2[8]   = "2 EV";
-        choices2[12]  = "3 EV";
-    }
-    std::string toString (const Tag* t) const override
-    {
-        const ChoicesIterator r  = choices.find  (t->toInt (0, BYTE));
-        std::map<int, std::string>::const_iterator r1 = choices1.find (t->toInt (1, BYTE));
-        std::map<int, std::string>::const_iterator r2 = choices2.find (t->toInt (2, BYTE));
-        std::ostringstream s;
-        s << ((r != choices.end() ) ?  r->second : "") << std::endl;
-        s << ((r1 != choices1.end()) ? r1->second : "") << std::endl;
-        s << ((r2 != choices2.end()) ? r2->second : "");
-        return s.str();
-    }
-};
-PAHDRInterpreter paHDRInterpreter;
-
-class PACrossProcessInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PACrossProcessInterpreter()
-    {
-        choices[ 0] = "Off";
-        choices[ 1] = "Randow";
-        choices[ 2] = "Preset 1";
-        choices[ 3] = "Preset 2";
-        choices[ 4] = "Preset 3";
-        choices[33] = "Favorite 1";
-        choices[34] = "Favorite 2";
-        choices[35] = "Favorite 3";
-    }
-};
-PACrossProcessInterpreter paCrossProcessInterpreter;
-
-class PAPowerSourceInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PAPowerSourceInterpreter()
-    {
-        choices[2] = "Body Battery";
-        choices[3] = "Grip Battery ";
-        choices[4] = "External Power Supply";
-    }
-};
-PAPowerSourceInterpreter paPowerSourceInterpreter;
-
-class PALensModelQInterpreter: public Interpreter
-{
-public:
-    PALensModelQInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[31];
-        buffer[0] = 0;  //
-        return buffer;  // TODO: how to get the string content!?
-
-//        // normal path below (copy the content of the string), but has to be bug fixed
-//        memcpy (buffer, t->getValue(), 30);
-//        buffer[30] = 0;
-//        return buffer;
-    }
-};
-PALensModelQInterpreter paLensModelQInterpreter;
-
-class PALensInfoQInterpreter: public Interpreter
-{
-public:
-    PALensInfoQInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[21];
-        buffer[0] = 0;
-        return buffer;  // TODO: how to get the string content!?
-
-//        // normal path below (copy the content of the string), but has to be bug fixed
-//        memcpy (buffer, t->getValue(), 20);
-//        buffer[20] = 0;
-//        return buffer;
-    }
-};
-PALensInfoQInterpreter paLensInfoQInterpreter;
-
-class PAFlashExposureCompInterpreter: public Interpreter
-{
-public:
-    PAFlashExposureCompInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        int a;
-
-        if (t->getCount() == 1) {
-            a = t->toInt (0, SLONG) / 256;   // int32u
-        } else {
-            a = t->toInt (0, SBYTE) / 6;   // int8u[2]
-        }
-
-        char buffer[32];
-        snprintf(buffer, sizeof(buffer), "%d", a );
-        return buffer;
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        int a;
-
-        if (t->getCount() == 1) {
-            a = t->toInt (0, SLONG) / 256;   // int32u
-        } else {
-            a = t->toInt (0, SBYTE) / 6;   // int8u[2]
-        }
-
-        return double (a);
-    }
-};
-PAFlashExposureCompInterpreter paFlashExposureCompInterpreter;
-
-class PAFocalLengthInterpreter: public Interpreter
-{
-public:
-    PAFocalLengthInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        double a = double (t->toInt (0, LONG));
-
-        if (a > 1.) {
-            char buffer[32];
-            snprintf(buffer, sizeof(buffer), "%.2f", a / 100. );
-            return buffer;
-        } else {
-            return "n/a";
-        }
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        double a = double (t->toInt (0, LONG));
-
-        if (a > 1.) {
-            return a / 100.;
-        } else {
-            return 0.;
-        }
-    }
-};
-PAFocalLengthInterpreter paFocalLengthInterpreter;
-
-class PALensDataFocalLengthInterpreter: public Interpreter
-{
-public:
-    PALensDataFocalLengthInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        int a = t->toInt (0, BYTE);
-        double b = static_cast<double>(10 * (a >> 2)) * std::pow(4.0, static_cast<double>((a & 0x03) - 2));
-
-        if (b > 1.0) {
-            char buffer[32];
-            snprintf(buffer, sizeof(buffer), "%.2f", b );
-            return buffer;
-        } else {
-            return "n/a";
-        }
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        int a = t->toInt (ofs, BYTE);
-        double b = static_cast<double>(10 * (a >> 2)) * std::pow(4.0, static_cast<double>((a & 0x03) - 2));
-
-        if (b > 1.0) {
-            return b;
-        } else {
-            return 0.;
-        }
-    }
-};
-PALensDataFocalLengthInterpreter paLensDataFocalLengthInterpreter;
-
-class PAISOfInterpreter: public Interpreter
-{
-public:
-    PAISOfInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        int a = t->toInt (0, BYTE);
-        char buffer[32];
-        double v = 100.*exp (double (a - 32) * log (2.) / 8.);
-        snprintf(buffer, sizeof(buffer), "%.1f", v );
-        return buffer;
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        int a = t->toInt (0, BYTE);
-        return 100.*exp (double (a - 32) * log (2.) / 8.);
-    }
-};
-PAISOfInterpreter paISOfInterpreter;
-
-class PAMaxApertureInterpreter: public Interpreter
-{
-public:
-    PAMaxApertureInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        int a = t->toInt (0, BYTE);
-        a &= 0x7F;
-
-        if (a > 1) {
-            char buffer[32];
-            double v = pow (2.0, (a - 1) / 32.0);
-
-            if ( v < 0. || v > 1000. ) {
-                return "undef";
-            }
-
-            snprintf(buffer, sizeof(buffer), "%.1f", v );
-            return buffer;
-        } else {
-            return "n/a";
-        }
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        int a = t->toInt (0, BYTE);
-        a &= 0x7F;
-
-        if (a > 1) {
-            return pow (2.0, double (a - 1) / 32.0);
-        } else {
-            return 0.;
-        }
-    }
-};
-PAMaxApertureInterpreter paMaxApertureInterpreter;
-
-class PAAEXvInterpreter: public Interpreter
-{
-public:
-    PAAEXvInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        int a = t->toInt (0, BYTE);
-        char buffer[32];
-        double v = double (a - 64) / 8.;
-        snprintf(buffer, sizeof(buffer), "%.1f", v );
-        return buffer;
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        int a = t->toInt (0, BYTE);
-        return double (a - 64) / 8.;
-    }
-};
-PAAEXvInterpreter paAEXvInterpreter;
-
-class PAAEBXvInterpreter: public Interpreter
-{
-public:
-    PAAEBXvInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        int a = t->toInt (0, SBYTE);
-        char buffer[32];
-        double v = double (a) / 8.;
-        snprintf(buffer, sizeof(buffer), "%.1f", v );
-        return buffer;
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        int a = t->toInt (0, SBYTE);
-        return double (a) / 8.;
-    }
-};
-PAAEBXvInterpreter paAEBXvInterpreter;
-
-class PAApertureInterpreter: public Interpreter
-{
-public:
-    PAApertureInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        int a = t->toInt (0, BYTE);
-        char buffer[32];
-        double v = exp ((double (a) - 68.) * log (2.) / 16.);
-        snprintf(buffer, sizeof(buffer), "%.1f", v );
-        return buffer;
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        int a = t->toInt (0, BYTE);
-        return exp ((double (a) - 68.) * log (2.) / 16.);
-    }
-};
-PAApertureInterpreter paApertureInterpreter;
-
-class PAExposureTimeInterpreter: public Interpreter
-{
-public:
-    PAExposureTimeInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        int a = t->toInt (0, BYTE);
-        char buffer[32];
-        double v = 24.*exp (- (double (a) - 32.) * log (2.) / 8.);
-        snprintf(buffer, sizeof(buffer), "%.6f", v );
-        return buffer;
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        int a = t->toInt (0, BYTE);
-        return 24.*exp (- (double (a) - 32.) * log (2.) / 8.);
-    }
-};
-PAExposureTimeInterpreter paExposureTimeInterpreter;
-
-class PANominalMinApertureInterpreter: public Interpreter
-{
-public:
-    PANominalMinApertureInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        int a = t->toInt (0, BYTE);
-        int mina = a & 0x0F;
-        snprintf(buffer, sizeof(buffer), "%.1f", double (int (pow (2.0, double (mina + 10) / 4.0) + 0.2)));
-        return buffer;
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        int a = t->toInt (0, BYTE) & 0x0F;
-        return double (int (pow (2.0, double (a + 10) / 4.0) + 0.2));
-    }
-};
-PANominalMinApertureInterpreter paNominalMinApertureInterpreter;
-
-class PANominalMaxApertureInterpreter: public Interpreter
-{
-public:
-    PANominalMaxApertureInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        int a = t->toInt (0, BYTE);
-        int maxa = (a & 0xF0) >> 4;
-        snprintf(buffer, sizeof(buffer), "%.1f", double (int (pow (2.0, double (maxa) / 4.0) + 0.2)) );
-        return buffer;
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        int a = ( t->toInt (0, BYTE) & 0xF0) >> 4;
-        return double (int (pow (2.0, double (a) / 4.0) + 0.2));
-    }
-};
-PANominalMaxApertureInterpreter paNominalMaxApertureInterpreter;
-
-class PAFlashStatusInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PAFlashStatusInterpreter()
-    {
-        choices[0] = "Off";
-        choices[1] = "Off (1)";
-        choices[2] = "External, Did not fire";
-        choices[6] = "External, Fired";
-        choices[8] = "Internal, Did not fire (0x08)";
-        choices[9] = "Internal, Did not fire";
-        choices[13] = "Internal, Fired";
-    }
-};
-PAFlashStatusInterpreter paFlashStatusInterpreter;
-
-class PAInternalFlashModeInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PAInternalFlashModeInterpreter()
-    {
-        choices[0] = "n/a - Off-Auto-Aperture";
-        choices[134] = "Fired, Wireless (Control)";
-        choices[149] = "Fired, Wireless (Master)";
-        choices[192] = "Fired";
-        choices[193] = "Fired, Red-eye reduction";
-        choices[194] = "Fired, Auto";
-        choices[195] = "Fired, Auto, Red-eye reduction";
-        choices[198] = "Fired, Wireless (Control), Fired normally not as control";
-        choices[200] = "Fired, Slow-sync";
-        choices[201] = "Fired, Slow-sync, Red-eye reduction";
-        choices[202] = "Fired, Trailing-curtain Sync";
-        choices[240] = "Did not fire, Normal";
-        choices[241] = "Did not fire, Red-eye reduction";
-        choices[242] = "Did not fire, Auto";
-        choices[243] = "Did not fire, Auto, Red-eye reduction";
-        choices[244] = "Did not fire, (Unknown 0xf4)";
-        choices[245] = "Did not fire, Wireless (Master)";
-        choices[246] = "Did not fire, Wireless (Control)";
-        choices[248] = "Did not fire, Slow-sync";
-        choices[249] = "Did not fire, Slow-sync, Red-eye reduction";
-        choices[250] = "Did not fire, Trailing-curtain Sync";
-    }
-};
-PAInternalFlashModeInterpreter paInternalFlashModeInterpreter;
-
-class PAExternalFlashModeInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PAExternalFlashModeInterpreter()
-    {
-        choices[0] = "n/a - Off-Auto-Aperture";
-        choices[63] = "Off";
-        choices[64] = "On, Auto";
-        choices[191] = "On, Flash Problem";
-        choices[192] = "On, Manual";
-        choices[196] = "On, P-TTL Auto";
-        choices[197] = "On, Contrast-control Sync";
-        choices[198] = "On, High-speed Sync";
-        choices[204] = "On, Wireless";
-        choices[205] = "On, Wireless, High-speed Sync";
-        choices[240] = "Not Connected";
-    }
-};
-PAExternalFlashModeInterpreter paExternalFlashModeInterpreter;
-
-class PAExternalFlashExposureCompInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PAExternalFlashExposureCompInterpreter()
-    {
-        choices[0] = "n/a";
-        choices[144] = "n/a (Manual Mode)";
-        choices[164] = "-3.0";
-        choices[167] = "-2.5";
-        choices[168] = "-2.0";
-        choices[171] = "-1.5";
-        choices[172] = "-1.0";
-        choices[175] = "-0.5";
-        choices[176] = "0.0";
-        choices[179] = "0.5";
-        choices[180] = "1.0";
-    }
-};
-PAExternalFlashExposureCompInterpreter paExternalFlashExposureCompInterpreter;
-
-class PAExternalFlashBounceInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PAExternalFlashBounceInterpreter()
-    {
-        choices[0] = "n/a";
-        choices[16] = "Direct";
-        choices[48] = "Bonce";
-    }
-};
-PAExternalFlashBounceInterpreter paExternalFlashBounceInterpreter;
-
-class PAExternalFlashGNInterpreter: public Interpreter
-{
-public:
-    PAExternalFlashGNInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        int b = t->toInt (0, BYTE) & 0x1F;
-        snprintf(buffer, sizeof(buffer), "%.0f", pow (2., b / 16. + 4) );
-        return buffer;
-    }
-};
-PAExternalFlashGNInterpreter paExternalFlashGNInterpreter;
-
-class PAEVStepsInterpreter: public Interpreter
-{
-public:
-    PAEVStepsInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        std::ostringstream str;
-
-        if ( t->toInt (0, BYTE) & 0x20 ) {
-            str << "1/3 EV steps";
-        } else {
-            str << "1/2 EV steps";
-        }
-
-        return str.str();
-    }
-};
-PAEVStepsInterpreter paEVStepsInterpreter;
-
-class PAEDialinInterpreter: public Interpreter
-{
-public:
-    PAEDialinInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        std::ostringstream str;
-
-        if (  t->toInt (0, BYTE) & 0x40 ) {
-            str << "P Shift";
-        } else {
-            str << "Tv or Av";
-        }
-
-        return str.str();
-    }
-};
-PAEDialinInterpreter paEDialinInterpreter;
-
-class PAApertureRingUseInterpreter: public Interpreter
-{
-public:
-    PAApertureRingUseInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        std::ostringstream str;
-
-        if (  t->toInt (0, BYTE) & 0x80 ) {
-            str << "Permitted";
-        } else {
-            str << "Prohibited";
-        }
-
-        return str.str();
-    }
-};
-PAApertureRingUseInterpreter paApertureRingUseInterpreter;
-
-class PAFlashOptionInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PAFlashOptionInterpreter()
-    {
-        choices[0] = "Normal";
-        choices[1] = "Red-eye reduction";
-        choices[2] = "Auto";
-        choices[3] = "Auto, Red-eye reduction";
-        choices[5] = "Wireless (Master)";
-        choices[6] = "Wireless (Control)";
-        choices[8] = "Slow-sync";
-        choices[9] = "Slow-sync, Red-eye reduction";
-        choices[10] = "Trailing-curtain Sync";
-    }
-    std::string toString (const Tag* t) const override
-    {
-        const ChoicesIterator r = choices.find (t->toInt (0, BYTE) >> 4);
-
-        if (r != choices.end()) {
-            return r->second;
-        } else {
-            char buffer[1024];
-            t->toString (buffer, sizeof(buffer));
-            return std::string (buffer);
-        }
-    }
-};
-PAFlashOptionInterpreter paFlashOptionInterpreter;
-
-class PAMeteringMode2Interpreter: public Interpreter
-{
-public:
-    PAMeteringMode2Interpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        std::ostringstream str;
-        int v = (t->toInt (0, BYTE) & 0xF);
-
-        if (!v) {
-            str << "Multi-segment";
-        } else if (v & 1) {
-            str << "Center-weighted average";
-        } else if (v & 2) {
-            str << "Spot";
-        }
-
-        return str.str();
-    }
-};
-PAMeteringMode2Interpreter paMeteringMode2Interpreter;
-
-class PAExposureBracketStepSizeInterpreter: public ChoiceInterpreter<>
-{
-public:
-    PAExposureBracketStepSizeInterpreter()
-    {
-        choices[3] = "0.3";
-        choices[4] = "0.5";
-        choices[5] = "0.7";
-        choices[8] = "1.0";
-        choices[11] = "1.3";
-        choices[12] = "1.5";
-        choices[13] = "1.7";
-        choices[16] = "2.0";
-    }
-};
-PAExposureBracketStepSizeInterpreter paExposureBracketStepSizeInterpreter;
-
-class PAPictureMode2Interpreter: public ChoiceInterpreter<>
-{
-public:
-    PAPictureMode2Interpreter()
-    {
-        choices[0] = "Scene Mode";
-        choices[1] = "Auto PICT";
-        choices[2] = "Program AE";
-        choices[3] = "Green Mode";
-        choices[4] = "Shutter Speed Priority";
-        choices[5] = "Aperture Priority";
-        choices[6] = "Program Tv Shift";
-        choices[7] = "Program Av Shift";
-        choices[8] = "Manual";
-        choices[9] = "Bulb";
-        choices[10] = "Aperture Priority, Off-Auto-Aperture";
-        choices[11] = "Manual, Off-Auto-Aperture";
-        choices[12] = "Bulb, Off-Auto-Aperture";
-        choices[13] = "Shutter & Aperture Priority AE";
-        choices[15] = "Sensitivity Priority AE";
-        choices[16] = "Flash X-Sync Speed AE";
-    }
-};
-PAPictureMode2Interpreter paPictureMode2Interpreter;
-
-class PAProgramLineInterpreter: public Interpreter
-{
-public:
-    PAProgramLineInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        std::ostringstream str;
-        int c = t->toInt (0, BYTE);
-
-        switch (c & 0xf) {
-            case 0:
-                str << "Manual";
-                break;
-
-            case 1:
-                str << "AF-S";
-                break;
-
-            case 2:
-                str << "AF-C";
-                break;
-
-            case 3:
-                str << "AF-A";
-                break;
-        }
-
-        if ( (c & 0xF0) == 0) {
-            str << ", Point Selection Auto";
-        } else if ( c & 0x20 ) {
-            str << ", Fixed Center Point Selected";
-        } else if ( c & 0x10 ) {
-            str << ", Point Selected";
-        }
-
-        return str.str();
-    }
-};
-PAProgramLineInterpreter paProgramLineInterpreter;
-
-class PAAFModeInterpreter: public Interpreter
-{
-public:
-    PAAFModeInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        switch (t->toInt (0, BYTE) & 0x3) {
-            case 0:
-                return "Normal";
-
-            case 1:
-                return "Hi Speed";
-
-            case 2:
-                return "Depth";
-
-            case 3:
-                return "MTF";
-        }
-
-        return"Normal";
-    }
-
-};
-PAAFModeInterpreter paAFModeInterpreter;
-
-class PAAFPointSelectedInterpreter: public Interpreter
-{
-public:
-    PAAFPointSelectedInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        int c = t->toInt (0, SHORT);
-
-        if ( !c ) {
-            return "Auto";
-        } else {
-            const char *ps[] = {"Upper-left", "Top", "Upper-right", "Left", "Mid-left", "Center", "Mid-right", "Right", "Lower-left", "Bottom", "Lower-right"};
-
-            for ( int iBit = 0; iBit < 11; iBit++)
-                if ( c & (1 << iBit) ) {
-                    return ps[iBit];
-                }
-
-            return "n/a";
-        }
-    }
-};
-PAAFPointSelectedInterpreter paAFPointSelectedInterpreter;
-
-class PADriveMode2Interpreter: public Interpreter
-{
-public:
-    PADriveMode2Interpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        int c = t->toInt (0, BYTE);
-
-        if ( !c ) {
-            return "Single-frame";
-        } else if ( c & 0x01) {
-            return "Continuous";
-        } else if ( c & 0x02) {
-            return "Continuous (Lo)";
-        } else if ( c & 0x04) {
-            return "Self-timer (12 s)";
-        } else if ( c & 0x08) {
-            return "Self-timer (2 s)";
-        } else if ( c & 0x10 ) {
-            return "Remote Control (3 s delay)";
-        } else if ( c & 0x20) {
-            return "Remote Control";
-        } else if ( c & 0x40) {
-            return "Exposure Bracket";
-        } else if ( c & 0x80) {
-            return "Multiple Exposure";
-        } else {
-            return "Unknown";
-        }
-    }
-};
-PADriveMode2Interpreter paDriveMode2Interpreter;
-
-const TagAttrib pentaxAttribs[] = {
-    {0, AC_WRITE,  0, nullptr, 0x0000, AUTO, "PentaxVersion", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0001, AUTO, "PentaxModelType", &stdInterpreter},
-    {0, AC_SYSTEM, 0, nullptr, 0x0002, AUTO, "PreviewImageSize", &stdInterpreter},
-    {0, AC_SYSTEM, 0, nullptr, 0x0003, AUTO, "PreviewImageLength", &stdInterpreter},
-    {0, AC_SYSTEM, 0, nullptr, 0x0004, AUTO, "PreviewImageStart", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0005, AUTO, "PentaxModelID", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0006, AUTO, "Date", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0007, AUTO, "Time", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0008, AUTO, "Quality", &paQualityInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0009, AUTO, "PentaxImageSize", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x000b, AUTO, "PictureMode", &paPictureModeInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x000c, AUTO, "FlashMode", &paFlashModeInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x000d, AUTO, "FocusMode", &paFocusModeInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x000e, AUTO, "AFPointSelected", &paAFPointInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x000f, AUTO, "AFPointsInFocus", &paAFFocusInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0010, AUTO, "FocusPosition", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0012, AUTO, "ExposureTime", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0013, AUTO, "FNumber", &paFNumberInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0014, AUTO, "ISO", &paISOInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0015, AUTO, "LightReading", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0016, AUTO, "ExposureCompensation", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0017, AUTO, "MeteringMode", &paMeteringModeInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0018, AUTO, "AutoBracketing", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0019, AUTO, "WhiteBalance", &paWhiteBalanceInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x001a, AUTO, "WhiteBalanceMode", &paWhiteBalanceModeInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x001b, AUTO, "BlueBalance", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x001c, AUTO, "RedBalance", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x001d, AUTO, "FocalLength", &paFocalLengthInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x001e, AUTO, "DigitalZoom", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x001f, AUTO, "Saturation", &paSaturationInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0020, AUTO, "Contrast", &paContrastInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0021, AUTO, "Sharpness", &paSharpnessInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0022, AUTO, "WorldTimeLocation", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0023, AUTO, "HometownCity", &stdInterpreter},
-    {0, AC_NEW,    0, nullptr, 0x0024, AUTO, "DestinationCity", &stdInterpreter},
-    {0, AC_NEW,    0, nullptr, 0x0025, AUTO, "HometownDST", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0026, AUTO, "DestinationDST", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0027, AUTO, "DSPFirmwareVersion", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0028, AUTO, "CPUFirmwareVersion", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0029, AUTO, "FrameNumber", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x002d, AUTO, "EffectiveLV", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0032, AUTO, "ImageProcessing", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0033, AUTO, "PictureMode", &paPictureModeInterpreter2},
-    {0, AC_WRITE,  0, nullptr, 0x0034, AUTO, "DriveMode", &paDriveModeInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0037, AUTO, "ColorSpace", &paColorSpaceInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0038, AUTO, "ImageAreaOffset", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0039, AUTO, "RawImageSize", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x003c, AUTO, "AFPointsInFocus", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x003e, AUTO, "PreviewImageBorders", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x003f, AUTO, "LensType", &paLensTypeInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0040, AUTO, "SensitivityAdjust", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0041, AUTO, "ImageProcessingCount", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0047, AUTO, "CameraTemperature", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0048, AUTO, "AELock", &paOnOffInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0049, AUTO, "NoiseReduction", &paOnOffInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x004d, AUTO, "FlashExposureComp", &paFlashExposureCompInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x004f, AUTO, "ImageTone", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0050, AUTO, "ColorTemperature", &stdInterpreter},
-    {0, AC_WRITE,  0, pentaxSRInfoAttribs, 0x005c, AUTO, "ShakeReductionInfo", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x005d, AUTO, "ShutterCount", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0069, AUTO, "DynamicRangeExpansion", &paOnOffInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0071, AUTO, "HighISONoiseReduction", &paHighISONoiseInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0072, AUTO, "AFAdjustment", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0073, AUTO, "MonochromeFilterEffect", &paMonochromeFilterEffectInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0074, AUTO, "MonochromeToning", &paMonochromeToningInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0076, AUTO, "FaceDetect", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0077, AUTO, "FaceDetectFrameSize", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0079, AUTO, "ShadowCorrection", &paShadowCorrectionInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x007a, AUTO, "ISOAutoParameters", &paISOAutoParametersInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x007b, AUTO, "CrossProcess", &paCrossProcessInterpreter},
-    {0, AC_WRITE,  0, pentaxLensCorrAttribs, 0x007d, AUTO, "LensCorr", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x007f, AUTO, "BleachBypassToning", &paBleachBypassToningInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0082, AUTO, "BlurControl", &paBlurControlInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0085, AUTO, "HDR", &paHDRInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0088, AUTO, "NeutralDensityFilter", &paOnOffInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x008b, AUTO, "ISO", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0200, AUTO, "BlackPoint", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0201, AUTO, "WhitePoint", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0203, AUTO, "ColorMatrixA", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0204, AUTO, "ColorMatrixB", &stdInterpreter},
-    {0, AC_WRITE,  0, pentaxCameraSettingsAttribs, 0x0205, AUTO, "CameraSettings", &stdInterpreter},
-    {0, AC_WRITE,  0, pentaxAEInfoAttribs, 0x0206, AUTO, "AEInfo", &stdInterpreter},
-    {0, AC_WRITE,  0, pentaxLensDataAttribs, 0x0207, AUTO, "LensInfo", &stdInterpreter},
-    {0, AC_WRITE,  0, pentaxFlashInfoAttribs, 0x0208, AUTO, "FlashInfo", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0209, AUTO, "AEMeteringSegments", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x020a, AUTO, "FlashADump", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x020b, AUTO, "FlashBDump", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x020d, AUTO, "WB_RGGBLevelsDaylight", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x020e, AUTO, "WB_RGGBLevelsShade", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x020f, AUTO, "WB_RGGBLevelsCloudy", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0210, AUTO, "WB_RGGBLevelsTungsten", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0211, AUTO, "WB_RGGBLevelsFluorescentD", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0212, AUTO, "WB_RGGBLevelsFluorescentN", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0213, AUTO, "WB_RGGBLevelsFluorescentW", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0214, AUTO, "WB_RGGBLevelsFlash", &stdInterpreter},
-    {0, AC_WRITE,  0, pentaxCameraInfoAttribs, 0x0215, AUTO, "CameraInfo", &stdInterpreter},
-    {0, AC_WRITE,  0, pentaxBatteryInfoAttribs, 0x0216, AUTO, "BatteryInfo", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x021f, AUTO, "AFInfo", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0222, AUTO, "ColorInfo", &stdInterpreter},
-    {0, AC_WRITE,  0, pentaxLensInfoQAttribs, 0x0239, AUTO, "LensInfoQ", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x03fe, AUTO, "DataDump", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x03ff, AUTO, "UnknownInfo", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0402, AUTO, "ToneCurve", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0403, AUTO, "ToneCurves", &stdInterpreter},
-    {0, AC_WRITE,  0, nullptr, 0x0e00, AUTO, "PrintIM", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib pentaxSRInfoAttribs[] = {
-    {0, AC_WRITE, 0, nullptr,  0, AUTO, "SRResult", &paSRResultInterpreter},
-    {0, AC_WRITE, 0, nullptr,  1, AUTO, "ShakeReduction", &paShakeReductionInterpreter},
-    {0, AC_WRITE, 0, nullptr,  2, AUTO, "SRHalfPressTime", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr,  3, AUTO, "SRFocalLength", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib pentaxSRInfo2Attribs[] = {
-    {0, AC_WRITE, 0, nullptr,  0, AUTO, "SRResult", &paSRResultInterpreter},    // assuming it's the same interpreter, but that's not sure
-    {0, AC_WRITE, 0, nullptr,  1, AUTO, "ShakeReduction", &paShakeReduction2Interpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib pentaxLensDataAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 9,  AUTO, "FocalLength", &paLensDataFocalLengthInterpreter},
-    {0, AC_WRITE, 0, nullptr, 10, AUTO, "NominalMaxAperture", &paNominalMaxApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 10, AUTO, "NominalMinAperture", &paNominalMinApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 14, AUTO, "MaxAperture", &paMaxApertureInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib pentaxLensInfoQAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 12, AUTO, "LensModel", &paLensModelQInterpreter},
-    {0, AC_WRITE, 0, nullptr, 42, AUTO, "LensInfo", &paLensInfoQInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib pentaxLensCorrAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0, AUTO, "DistortionCorrection", &paOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 1, AUTO, "ChromaticAberrationCorrection", &paOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 2, AUTO, "VignettingCorrection", &paOnOffInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib pentaxCameraSettingsAttribs[] = {
-    {0, AC_WRITE, 0, nullptr,  0, AUTO, "PictureMode2", &paPictureMode2Interpreter},
-    {0, AC_WRITE, 0, nullptr,  1, AUTO, "ProgramLine", &paProgramLineInterpreter},
-    {0, AC_WRITE, 0, nullptr,  1, AUTO, "EVSteps", &paEVStepsInterpreter},
-    {0, AC_WRITE, 0, nullptr,  1, AUTO, "E-DialinProgram", &paEDialinInterpreter},
-    {0, AC_WRITE, 0, nullptr,  1, AUTO, "ApertureRing", &paApertureRingUseInterpreter},
-    {0, AC_WRITE, 0, nullptr,  2, AUTO, "FlashOptions", &paFlashOptionInterpreter},
-    {0, AC_WRITE, 0, nullptr,  2, AUTO, "MeteringMode2", &paMeteringMode2Interpreter},
-    {0, AC_WRITE, 0, nullptr,  3, AUTO, "AFMode", &paAFModeInterpreter},
-    {0, AC_WRITE, 0, nullptr,  4, AUTO, "AFPointSelected2", &paAFPointSelectedInterpreter},
-    {0, AC_WRITE, 0, nullptr,  7, AUTO, "DriveMode2", &paDriveMode2Interpreter},
-    {0, AC_WRITE, 0, nullptr,  8, AUTO, "ExposureBracketStepSize", &paExposureBracketStepSizeInterpreter},
-    {0, AC_WRITE, 0, nullptr,  9, AUTO, "BracketShotNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 10, AUTO, "WhiteBalanceSet", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib pentaxAEInfoAttribs[] = {
-    {0, AC_WRITE, 0, nullptr,  0, AUTO, "AEExposureTime", &paExposureTimeInterpreter},
-    {0, AC_WRITE, 0, nullptr,  1, AUTO, "AEAperture", &paApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr,  2, AUTO, "AE_ISO", &paISOfInterpreter},
-    {0, AC_WRITE, 0, nullptr,  3, AUTO, "AEXv", &paAEXvInterpreter},
-    {0, AC_WRITE, 0, nullptr,  4, SBYTE, "AEBXv", &paAEBXvInterpreter},
-    {0, AC_WRITE, 0, nullptr,  5, AUTO, "AEMinExposureTime", &paExposureTimeInterpreter},
-    {0, AC_WRITE, 0, nullptr,  6, AUTO, "AEProgramMode", &paAEProgramModeInterpreter},
-    {0, AC_WRITE, 0, nullptr,  9, AUTO, "AEMaxAperture", &paApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 10, AUTO, "AEMaxAperture2", &paApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 11, AUTO, "AEMinAperture", &paApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 12, AUTO, "AEMeteringMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 14, SBYTE, "FlashExposureCompSet", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib pentaxAEInfo2Attribs[] = {
-    {0, AC_WRITE, 0, nullptr,  2, AUTO, "AEExposureTime", &paExposureTimeInterpreter},
-    {0, AC_WRITE, 0, nullptr,  3, AUTO, "AEAperture", &paApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr,  4, AUTO, "AE_ISO", &paISOfInterpreter},
-    {0, AC_WRITE, 0, nullptr,  5, AUTO, "AEXv", &paAEXvInterpreter},
-    {0, AC_WRITE, 0, nullptr,  6, SBYTE, "AEBXv", &paAEBXvInterpreter},
-    {0, AC_WRITE, 0, nullptr,  8, SBYTE, "AEError", &stdInterpreter},
-//{0, AC_WRITE, 0, 0, 11, AUTO, "AEApertureSteps", &},
-    {0, AC_WRITE, 0, nullptr, 15, AUTO, "SceneMode", &paSceneModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 16, AUTO, "AEMaxAperture", &paApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 17, AUTO, "AEMaxAperture2", &paApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 18, AUTO, "AEMinAperture", &paApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 19, AUTO, "AEMinExposureTime", &paExposureTimeInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib pentaxAEInfo3Attribs[] = {
-    {0, AC_WRITE, 0, nullptr, 16, AUTO, "AEExposureTime", &paExposureTimeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 17, AUTO, "AEAperture", &paApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 18, AUTO, "AE_ISO", &paISOfInterpreter},
-    {0, AC_WRITE, 0, nullptr, 28, AUTO, "AEMaxAperture", &paApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 29, AUTO, "AEMaxAperture2", &paApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 30, AUTO, "AEMinAperture", &paApertureInterpreter},
-    {0, AC_WRITE, 0, nullptr, 31, AUTO, "AEMinExposureTime", &paExposureTimeInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib pentaxFlashInfoAttribs[] = {
-    {0, AC_WRITE, 0, nullptr,  0, AUTO, "FlashStatus", &paFlashStatusInterpreter},
-    {0, AC_WRITE, 0, nullptr,  1, AUTO, "InternalFlashMode", &paInternalFlashModeInterpreter},
-    {0, AC_WRITE, 0, nullptr,  2, AUTO, "ExternalFlashMode", &paExternalFlashModeInterpreter},
-    {0, AC_WRITE, 0, nullptr,  3, AUTO, "InternalFlashStrength", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 24, AUTO, "ExternalFlashGuideNumber", &paExternalFlashGNInterpreter},
-    {0, AC_WRITE, 0, nullptr, 25, AUTO, "ExternalFlashExposureComp", &paExternalFlashExposureCompInterpreter},
-    {0, AC_WRITE, 0, nullptr, 26, AUTO, "ExternalFlashBounce", &paExternalFlashBounceInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib pentaxBatteryInfoAttribs[] = {
-    {0, AC_WRITE, 0, nullptr,  0, AUTO, "PowerSource", &paPowerSourceInterpreter},
-    {0, AC_WRITE, 0, nullptr,  1, AUTO, "BatteryStates", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr,  2, AUTO, "BatteryADBodyNoLoad", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr,  3, AUTO, "BatteryADBodyLoad", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr,  4, AUTO, "BatteryADGripNoLoad", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr,  5, AUTO, "BatteryADGripLoad", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib pentaxCameraInfoAttribs[] = {
-    {0, AC_WRITE, 0, nullptr,  0, AUTO, "PentaxModelID", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr,  1, AUTO, "ManufactureDate", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr,  2, AUTO, "ProductionCode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr,  4, AUTO, "InternalSerialNumber", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-}
-
-
-
-
diff --git a/rtexif/rtexif.cc b/rtexif/rtexif.cc
deleted file mode 100644
index a7125fb9a..000000000
--- a/rtexif/rtexif.cc
+++ /dev/null
@@ -1,3553 +0,0 @@
-/*
- *  This file is part of RawTherapee.
- *
- *  Copyright (c) 2004-2010 Gabor Horvath <hgabor@rawtherapee.com>
- *  Some parts of the source code (e.g. ciff support) are taken from dcraw
- *  that is copyrighted by Dave Coffin
- *
- *  RawTherapee is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  RawTherapee is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
- */
-#include <cstdio>
-#include <iostream>
-#include <cmath>
-#include <cstring>
-#include <ctime>
-#include <sstream>
-#include <stdint.h>
-#include <tiff.h>
-
-#include <glib/gstdio.h>
-#include <glib/gunicode.h>
-#include <glibmm/keyfile.h>
-
-#include "rtexif.h"
-
-#include "../rtengine/procparams.h"
-
-#include "../rtgui/cacheimagedata.h"
-#include "../rtgui/version.h"
-#include "../rtgui/ppversion.h"
-
-// see end of ExifManager::parse(bool, bool)
-#define PRINT_METADATA_TREE 0
-
-using namespace std;
-
-namespace rtexif
-{
-
-Interpreter stdInterpreter;
-
-//--------------- class TagDirectory ------------------------------------------
-// this class is a collection (an array) of tags
-//-----------------------------------------------------------------------------
-
-TagDirectory::TagDirectory ()
-    : attribs (ifdAttribs), order (HOSTORDER), parent (nullptr), parseJPEG(true) {}
-
-TagDirectory::TagDirectory (TagDirectory* p, const TagAttrib* ta, ByteOrder border)
-    : attribs (ta), order (border), parent (p), parseJPEG(true) {}
-
-TagDirectory::TagDirectory (TagDirectory* p, FILE* f, int base, const TagAttrib* ta, ByteOrder border, bool skipIgnored, bool parseJpeg)
-    : attribs (ta), order (border), parent (p), parseJPEG(parseJpeg)
-{
-
-    int numOfTags = get2 (f, order);
-
-    if (numOfTags <= 0 || numOfTags > 1000) { // KodakIfd has lots of tags, thus 1000 as the limit
-        return;
-    }
-
-    bool thumbdescr = false;
-
-    for (int i = 0; i < numOfTags; i++) {
-
-        Tag* newTag = new Tag (this, f, base);
-
-        // filter out tags with unknown type
-        if ((int)newTag->getType() == 0) {
-            delete newTag;
-            continue;
-        }
-
-        if (skipIgnored) {
-            int id = newTag->getID();
-
-            // detect and possibly ignore tags of directories belonging to the embedded thumbnail image
-            if (attribs == ifdAttribs && id == TIFFTAG_SUBFILETYPE && newTag->toInt() != 0) {
-                thumbdescr = true;
-            }
-
-            const TagAttrib* attrib = getAttrib (id);
-
-            if (!attrib || attrib->ignore == 1 || (thumbdescr && attrib->ignore == 2)) {
-                delete newTag;
-            } else {
-                addTag (newTag);
-            }
-        } else {
-            addTag (newTag);
-        }
-    }
-}
-
-TagDirectory::~TagDirectory ()
-{
-
-    for (size_t i = 0; i < tags.size(); i++) {
-        delete tags[i];
-    }
-}
-
-class CompareTags
-{
-public:
-    int operator() (Tag* const& a, Tag* const& b) const
-    {
-        return a->getID() < b->getID();
-    }
-};
-
-void TagDirectory::sort ()
-{
-
-    std::sort (tags.begin(), tags.end(), CompareTags());
-
-    for (size_t i = 0; i < tags.size(); i++)
-        if (tags[i]->isDirectory())
-            for (int j = 0; tags[i]->getDirectory (j); j++) {
-                tags[i]->getDirectory (j)->sort ();
-            }
-}
-TagDirectory*  TagDirectory::getRoot()
-{
-    if (parent) {
-        return parent->getRoot();
-    } else {
-        return this;
-    }
-}
-
-const TagAttrib* TagDirectory::getAttrib (int id) const
-{
-
-    if (attribs)
-        for (int i = 0; attribs[i].ignore != -1; i++)
-            if (attribs[i].ID == id) {
-                return &attribs[i];
-            }
-
-    return nullptr;
-}
-
-const TagAttrib* TagDirectory::getAttrib (const char* name)
-{
-
-    if (attribs)
-        for (int i = 0; attribs[i].ignore != -1; i++)
-            if (!strcmp (attribs[i].name, name)) {
-                return &attribs[i];
-            }
-
-    return nullptr;
-}
-
-const TagAttrib* TagDirectory::getAttribP (const char* name)
-{
-
-    if (attribs)
-        for (int i = 0; attribs[i].ignore != -1; i++) {
-            // Yeah, self made comparison!
-            const char *n = name;
-            const char *a = attribs[i].name;
-
-            while (*n && *a && *n == *a) {
-                n++;
-                a++;
-            };
-
-            if (!*a && (!*n || *n == '/')) {
-                // we reached the end of the subpart of name and the end of attribs->name, so they match
-                if (*n == '/') {
-                    Tag* tag = getTag (attribs[i].ID);
-                    TagDirectory *tagDir;
-
-                    if (attribs[i].subdirAttribs && tag && (tagDir = tag->getDirectory())) {
-                        return tagDir->getAttribP (n + 1);
-                    } else {
-                        return nullptr;
-                    }
-                } else {
-                    return &attribs[i];
-                }
-            }
-        }
-
-    return nullptr;
-}
-
-void TagDirectory::printAll (unsigned int level) const
-{
-
-    // set the spacer prefix string
-    char prefixStr[level * 4 + 1];
-    unsigned int i;
-
-    for (i = 0; i < level * 4; i++) {
-        prefixStr[i] = ' ';
-    }
-
-    prefixStr[i] = '\0';
-
-    // recursively iterate over the tag list
-    for (size_t i = 0; i < tags.size(); i++) {
-        std::string name = tags[i]->nameToString ();
-
-        TagDirectory* currTagDir;
-        if (tags[i]->isDirectory()) {
-            for (int j = 0; (currTagDir = tags[i]->getDirectory (j)) != nullptr; j++) {
-                printf ("%s+-- DIRECTORY %s[%d]:\n", prefixStr, name.c_str(), j);
-                currTagDir->printAll (level + 1);
-            }
-        } else {
-            printf ("%s- %s\n", prefixStr, name.c_str());
-        }
-    }
-}
-
-/** @brief Dump the TagDirectory and its sub-directories to the file 'fname'
- *
- * This method has been created to dump the metadata for the Custom Profile Builders.
- * It contains an [RT General] section to communicate some parameters, then the TagDirectory follows.
- *
- * The key is composed as follow: "010F_Make", i.e. "tag number or ID _ tag name"
- * Entries like:
- *
- * 927C_MakerNotesSony=$subdir
- *
- * indicates that this tag refer to a sub-directory. RT's Keywords begins with $, where & is the first char of the value.
- * $subdir is the only keyword so far.
- *
- * You'll have then to check for the [EXIF/927C_MakerNotesSony] section, given that the root section
- * is named [EXIF].
- *
- * WARNING: Some string will be sanitized, i.e. the new line char will be replaced by "\n". You'll
- * have to check for this escape string if you want a correct display of the value, but your KeyFile module
- * will most likely handle that automatically for you.
- *
- * @param commFNname Absolute path of the temporary communication file's name
- * @param commFNname Absolute path of the image's file name
- * @param commFNname Absolute path of the output profiles's file name
- * @param defaultPParams absolute or relative path (to the application's folder) of the default ProcParams to use
- * @param cfs pointer to a CacheImageData object that will contain common values
- * @param flagMode will tell whether the Custom Profile Builder is called for on flagging event or for real development
- * @param keyfile The KeyFile object to dump to. Has to be NULL (default value) on first call!
- * @param tagDirName Name of the current TagDirectory (full path, i.e. "EXIF/MakerNotes/LensInfo"). Can be empty on first call, "EXIF" will then be used
- *
- * @return True if everything went fine, false otherwise
- */
-bool TagDirectory::CPBDump (const Glib::ustring &commFName, const Glib::ustring &imageFName, const Glib::ustring &profileFName, const Glib::ustring &defaultPParams,
-                            const CacheImageData* cfs, const bool flagMode, Glib::KeyFile *keyFile, Glib::ustring tagDirName) const
-{
-    const auto kf = keyFile ? keyFile : new Glib::KeyFile;
-
-    if (!kf) {
-        return false;
-    }
-
-    if (!keyFile || tagDirName.empty()) {
-        tagDirName = "EXIF";
-    }
-
-    std::vector<const TagDirectory *> tagDirList;
-    std::vector<Glib::ustring> tagDirPaths;
-
-    FILE *f = nullptr;
-
-    if (!keyFile) {
-        // open the file in write mode
-        f = g_fopen (commFName.c_str (), "wt");
-
-        if (f == nullptr) {
-            printf ("TagDirectory::keyFileDump(\"%s\") >>> Error: unable to open file with write access!\n", commFName.c_str());
-            delete kf;
-            return false;
-        }
-
-        try {
-
-            kf->set_string ("RT General", "CachePath", options.cacheBaseDir);
-            kf->set_string ("RT General", "AppVersion", RTVERSION);
-            kf->set_integer ("RT General", "ProcParamsVersion", PPVERSION);
-            kf->set_string ("RT General", "ImageFileName", imageFName);
-            kf->set_string ("RT General", "OutputProfileFileName", profileFName);
-            kf->set_string ("RT General", "DefaultProcParams", defaultPParams);
-            kf->set_boolean ("RT General", "FlaggingMode", flagMode);
-
-            kf->set_integer ("Common Data", "FrameCount", cfs->frameCount);
-            kf->set_integer ("Common Data", "SampleFormat", cfs->sampleFormat);
-            kf->set_boolean ("Common Data", "IsHDR", cfs->isHDR);
-            kf->set_boolean ("Common Data", "IsPixelShift", cfs->isPixelShift);
-            kf->set_double ("Common Data", "FNumber", cfs->fnumber);
-            kf->set_double ("Common Data", "Shutter", cfs->shutter);
-            kf->set_double ("Common Data", "FocalLength", cfs->focalLen);
-            kf->set_integer ("Common Data", "ISO", cfs->iso);
-            kf->set_string ("Common Data", "Lens", cfs->lens);
-            kf->set_string ("Common Data", "Make", cfs->camMake);
-            kf->set_string ("Common Data", "Model", cfs->camModel);
-
-        } catch (Glib::KeyFileError&) {}
-    }
-
-    // recursively iterate over the tag list
-    for (size_t i = 0; i < tags.size(); i++) {
-        std::string tagName = tags[i]->nameToString ();
-
-        if (tags[i]->isDirectory())
-            for (int j = 0; tags[i]->getDirectory (j); j++) {
-                // Accumulating the TagDirectories to dump later
-                tagDirPaths.push_back ( Glib::ustring ( tagDirName + "/" + getDumpKey (tags[i]->getID(), tagName) ) );
-                tagDirList.push_back (tags[i]->getDirectory (j));
-
-                try {
-                    kf->set_string (tagDirName, getDumpKey (tags[i]->getID(), tagName), "$subdir");
-                } catch (Glib::KeyFileError&) {}
-            } else {
-            try {
-                kf->set_string (tagDirName, getDumpKey (tags[i]->getID(), tagName), tags[i]->valueToString());
-            } catch (Glib::KeyFileError&) {}
-        }
-    }
-
-    // dumping the sub-directories
-    for (size_t i = 0; i < tagDirList.size(); i++) {
-        tagDirList.at (i)->CPBDump (commFName, imageFName, profileFName, defaultPParams, cfs, flagMode, kf, tagDirPaths.at (i));
-    }
-
-    if (!keyFile) {
-        try {
-            fprintf (f, "%s", kf->to_data().c_str());
-        } catch (Glib::KeyFileError&) {}
-
-        fclose (f);
-        delete kf;
-    }
-
-    return true;
-}
-
-Glib::ustring TagDirectory::getDumpKey (int tagID, const Glib::ustring &tagName)
-{
-    Glib::ustring key;
-
-    if (options.CPBKeys == CPBKT_TID || options.CPBKeys == CPBKT_TID_NAME) {
-        key = Glib::ustring (Glib::ustring::format (std::fixed, std::hex, std::setfill (L'0'), std::setw (4), tagID));
-    }
-
-    if (options.CPBKeys == CPBKT_TID_NAME) {
-        key += Glib::ustring ("_");
-    }
-
-    if (options.CPBKeys == CPBKT_TID_NAME || options.CPBKeys == CPBKT_NAME) {
-        key += Glib::ustring (tagName);
-    }
-
-    return key;
-}
-void TagDirectory::addTag (Tag* &tag)
-{
-
-    // look up if it already exists:
-    if (getTag (tag->getID())) {
-        delete tag;
-        tag = nullptr;
-    } else {
-        tags.push_back (tag);
-    }
-}
-
-void TagDirectory::addTagFront (Tag* &tag)
-{
-
-    // look up if it already exists:
-    if (getTag (tag->getID())) {
-        delete tag;
-        tag = nullptr;
-    } else {
-        tags.insert (tags.begin(), tag);
-    }
-}
-
-void TagDirectory::replaceTag (Tag* tag)
-{
-
-    // look up if it already exists:
-    for (size_t i = 0; i < tags.size(); i++)
-        if (tags[i]->getID() == tag->getID()) {
-            delete tags[i];
-            tags[i] = tag;
-            return;
-        }
-
-    tags.push_back (tag);
-}
-
-Tag* TagDirectory::getTag (int ID) const
-{
-
-    for (size_t i = 0; i < tags.size(); i++)
-        if (tags[i]->getID() == ID) {
-            return tags[i];
-        }
-
-    return nullptr;
-}
-
-Tag* TagDirectory::getTag (const char* name) const
-{
-
-    if (attribs) {
-        for (int i = 0; attribs[i].ignore != -1; i++)
-            if (!strcmp (attribs[i].name, name)) {
-                return getTag (attribs[i].ID);
-            }
-    }
-
-    return nullptr;
-}
-
-Tag* TagDirectory::getTagP (const char* name) const
-{
-
-    if (attribs)
-        for (int i = 0; attribs[i].ignore != -1; i++) {
-            // Yeah, self made comparison!
-            const char *n = name;
-            const char *a = attribs[i].name;
-
-            while (*n && *a && *n == *a) {
-                n++;
-                a++;
-            };
-
-            if (!*a && (!*n || *n == '/')) {
-                // we reached the end of the subpart of name and the end of attribs->name, so they match
-                if (*n == '/') {
-                    Tag* tag = getTag (attribs[i].ID);
-                    TagDirectory *tagDir;
-
-                    if (attribs[i].subdirAttribs && tag && (tagDir = tag->getDirectory())) {
-                        return tagDir->getTagP (n + 1);
-                    } else {
-                        return nullptr;
-                    }
-                } else {
-                    return getTag (attribs[i].ID);
-                }
-            }
-        }
-
-    return nullptr;
-}
-
-Tag* TagDirectory::findTag (const char* name, bool lookUpward) const
-{
-    Tag* t = getTag(name);
-    if (t) {
-        return t;
-    }
-
-    Tag* foundTag = nullptr;
-    int tagDistance = 10000;
-
-    for (auto tag : tags) {
-        if (tag->isDirectory()) {
-            TagDirectory *dir;
-            int i = 0;
-            // Find the shortest path to that tag
-            while ((dir = tag->getDirectory(i)) != nullptr) {
-                TagDirectory *dir = tag->getDirectory();
-                Tag* t = dir->findTag (name);
-
-                if (t) {
-                    int currTagDistance = t->getDistanceFrom(this);
-                    if (currTagDistance < tagDistance) {
-                        tagDistance = currTagDistance;
-                        foundTag = t;
-                    }
-                }
-                ++i;
-            }
-        }
-    }
-
-    if (foundTag) {
-        return foundTag;
-    }
-
-    if (lookUpward && parent) {
-        Tag* t = parent->findTagUpward(name);
-
-        if (t) {
-            return t;
-        }
-    }
-
-    return nullptr;
-}
-
-std::vector<const Tag*> TagDirectory::findTags (int ID)
-{
-
-    std::vector<const Tag*> tagList;
-
-    //assuming that an entry can only exist once
-    Tag* t = getTag(ID);
-    if (t) {
-        tagList.push_back(t);
-    }
-
-    for (auto tag : tags) {
-        if (tag->isDirectory()) {
-            TagDirectory *dir;
-            int i = 0;
-            while ((dir = tag->getDirectory(i)) != nullptr) {
-                std::vector<const Tag*> subTagList = dir->findTags (ID);
-
-                if (!subTagList.empty()) {
-                    // concatenating the 2 vectors
-                    // not really optimal in a memory efficiency pov
-                    for (auto tag2 : subTagList) {
-                        tagList.push_back(tag2);
-                    }
-                }
-                ++i;
-            }
-        }
-    }
-
-    return tagList;
-}
-
-std::vector<const Tag*> TagDirectory::findTags (const char* name)
-{
-
-    std::vector<const Tag*> tagList;
-
-    //assuming that an entry can only exist once
-    Tag* t = getTag(name);
-    if (t) {
-        tagList.push_back(t);
-    }
-
-    for (auto tag : tags) {
-        if (tag->isDirectory()) {
-            TagDirectory *dir;
-            int i = 0;
-            while ((dir = tag->getDirectory(i)) != nullptr) {
-                std::vector<const Tag*> subTagList = dir->findTags (name);
-
-                if (!subTagList.empty()) {
-                    // concatenating the 2 vectors
-                    // not really optimal in a memory efficiency pov, but adding 10 items should be a maximum
-                    for (auto tag2 : subTagList) {
-                        tagList.push_back(tag2);
-                    }
-                }
-                ++i;
-            }
-        }
-    }
-
-    return tagList;
-}
-
-
-Tag* TagDirectory::findTagUpward (const char* name) const
-{
-    Tag* t = findTag(name);
-    if (t) {
-        return t;
-    }
-
-    if (parent) {
-        Tag* t = parent->findTagUpward(name);
-
-        if (t) {
-            return t;
-        }
-    }
-
-    return nullptr;
-}
-
-
-// Searches a simple value, as either attribute or element
-// only for simple values, not for entries with special chars or free text
-bool TagDirectory::getXMPTagValue (const char* name, char* value) const
-{
-    *value = 0;
-
-    if (!getTag ("ApplicationNotes")) {
-        return false;
-    }
-
-    char *sXMP = (char*)getTag ("ApplicationNotes")->getValue();
-
-    // Check for full word
-    char *pos = sXMP;
-
-    bool found = false;
-
-    do {
-        pos = strstr (pos, name);
-
-        if (pos) {
-            char nextChar = * (pos + strlen (name));
-
-            if (nextChar == ' ' || nextChar == '>' || nextChar == '=') {
-                found = true;
-            } else {
-                pos += strlen (name);
-            }
-        }
-    } while (pos && !found);
-
-    if (!found) {
-        return false;
-    }
-
-    char *posTag = strchr (pos, '>');
-    char *posAttr = strchr (pos, '"');
-
-    if (!posTag && !posAttr) {
-        return false;
-    }
-
-    if (posTag && (!posAttr || posTag < posAttr)) {
-        // Tag
-        pos = strchr (posTag + 1, '<');
-        strncpy (value, posTag + 1, pos - posTag - 1);
-        value[pos - posTag - 1] = 0;
-        return true;
-    } else if (posAttr && (!posTag || posAttr < posTag)) {
-        // Attribute
-        pos = strchr (posAttr + 1, '"');
-        strncpy (value, posAttr + 1, pos - posAttr - 1);
-        value[pos - posAttr - 1] = 0;
-        return true;
-    } else {
-        return false;
-    }
-}
-
-void TagDirectory::keepTag (int ID)
-{
-    for (size_t i = 0; i < tags.size(); i++)
-        if (tags[i]->getID() == ID) {
-            tags[i]->setKeep (true);
-        }
-}
-
-int TagDirectory::calculateSize ()
-{
-
-    int size = 2; // space to store the number of tags
-
-    for (size_t i = 0; i < tags.size(); i++)
-        if (tags[i]->getKeep()) {
-            size += 12 + tags[i]->calculateSize ();
-        }
-
-    size += 4; // next ifd pointer
-    return size;
-}
-
-TagDirectory* TagDirectory::clone (TagDirectory* parent) const
-{
-
-    TagDirectory* td = new TagDirectory (parent, attribs, order);
-
-    for (size_t i = 0; i < tags.size(); i++) {
-        td->tags.push_back (tags[i]->clone (td));
-    }
-
-    return td;
-}
-
-int TagDirectory::write (int start, unsigned char* buffer)
-{
-
-    int size = calculateSize ();
-    int tagnum = 0;
-    int nondirspace = 0;
-
-    for (size_t i = 0; i < tags.size(); i++)
-        if (tags[i]->getKeep()) {
-            tagnum++;
-
-            if (!tags[i]->isDirectory()) {
-                nondirspace += tags[i]->calculateSize();
-            }
-        }
-
-    int nextValOffs = start + 2 + tagnum * 12 + 4;
-    int nextDirOffs = nextValOffs + nondirspace;
-    int pos = start;
-    sset2 (tagnum, buffer + start, order);
-    pos += 2;
-    int maxPos = start + size;
-
-    for (size_t i = 0; i < tags.size(); i++) {
-        if (tags[i]->getKeep()) {
-            if (!tags[i]->isDirectory()) {
-                nextValOffs = tags[i]->write (pos, nextValOffs, buffer);    // pos: where to put the tag, dataoffset: the place where the value can be put. return: next data offset
-            } else {
-                nextDirOffs = tags[i]->write (pos, nextDirOffs, buffer);    // pos: where to put the tag, dataoffset: the place where the value can be put. return: next data offset
-            }
-
-            pos += 12;
-        }
-    }
-
-    sset4 (0, buffer + pos, order);
-    return maxPos;
-}
-
-void TagDirectory::applyChange (const std::string &name, const Glib::ustring &value)
-{
-
-    std::string::size_type dp = name.find_first_of ('.');
-    std::string fseg = name.substr (0, dp);
-
-    // this is a final segment: apply change
-    if (dp == std::string::npos) {
-
-        Tag* t = nullptr;
-
-        for (size_t i = 0; i < tags.size(); i++)
-            if (tags[i]->nameToString() == fseg) {
-                t = tags[i];
-                break;
-            }
-
-        if (value == "#keep" && t) {
-            t->setKeep (true);
-        } else if (value == "#delete" && t) {
-            t->setKeep (false);
-        } else if (t && !t->isDirectory()) {
-            if (name == "UserComment") {
-                // UserComment can be Unicode
-                t->userCommentFromString (value);
-            } else {
-                t->valueFromString (value);
-            }
-        } else {
-            const TagAttrib* attrib = nullptr;
-
-            for (int i = 0; attribs[i].ignore != -1; i++) {
-                if (!strcmp (attribs[i].name, fseg.c_str())) {
-                    attrib = &attribs[i];
-                    break;
-                }
-            }
-
-            if (attrib) {
-                Tag* nt = new Tag (this, attrib);
-                if (name == "UserComment") {
-                    // UserComment can be Unicode
-                    nt->initUserComment (value);
-                } else {
-                    nt->initString (value.c_str());
-                }
-                addTag (nt);
-            }
-        }
-    }
-    // this is a subdirectory
-    else {
-        // try to find it
-        std::string::size_type dp1 = fseg.find_first_of ('[');
-        std::string basename = fseg.substr (0, dp1);
-        Tag* t = nullptr;
-        int dirnum = -1;
-
-        for (size_t i = 0; i < tags.size(); i++)
-            if (tags[i]->isDirectory()) {
-                for (int j = 0; tags[i]->getDirectory (j); j++) {
-                    if (tags[i]->nameToString (j) == fseg) {
-                        t = tags[i];
-                        dirnum = j;
-                        break;
-                    }
-                }
-
-                if (!t && tags[i]->nameToString() == basename) { // found it, but that directory index does not exist
-                    t = tags[i];
-                    dirnum = -1;
-                }
-            }
-
-        if (!t && value != "#keep" && value != "#delete") {
-            const TagAttrib* attrib = nullptr;
-
-            for (int i = 0; attribs[i].ignore != -1; i++)
-                if (!strcmp (attribs[i].name, fseg.c_str())) {
-                    attrib = &attribs[i];
-                    break;
-                }
-
-            if (attrib && attrib->subdirAttribs) {
-                t = new Tag (this, attrib);
-                t->initSubDir ();
-                addTag (t);
-            }
-
-            dirnum = 0;
-        }
-
-        if (t && dirnum >= 0) {
-            t->getDirectory (dirnum)->applyChange (name.substr (dp + 1, std::string::npos), value);
-        }
-    }
-}
-
-TagDirectoryTable::TagDirectoryTable ()
-    : values (nullptr), zeroOffset (0), valuesSize (0), defaultType (INVALID)
-{
-}
-
-TagDirectoryTable::TagDirectoryTable (TagDirectory* p, unsigned char *v, int memsize, int offs, TagType type, const TagAttrib* ta, ByteOrder border)
-    : TagDirectory (p, ta, border), zeroOffset (offs), valuesSize (memsize), defaultType ( type )
-{
-    values = new unsigned char[valuesSize];
-    memcpy (values, v, valuesSize);
-
-    // Security ; will avoid to read above the buffer limit if the RT's tagDirectoryTable is longer that what's in the file
-    int count = valuesSize / getTypeSize (type);
-
-    for (const TagAttrib* tattr = ta; tattr->ignore != -1 && tattr->ID < count; ++tattr) {
-        Tag* newTag = new Tag (this, tattr, (values + zeroOffset + tattr->ID * getTypeSize (type)), tattr->type == AUTO ? type : tattr->type);
-        tags.push_back (newTag); // Here we can insert more tag in the same offset because of bitfield meaning
-    }
-}
-
-TagDirectoryTable::TagDirectoryTable (TagDirectory* p, FILE* f, int memsize, int offs, TagType type, const TagAttrib* ta, ByteOrder border)
-    : TagDirectory (p, ta, border), zeroOffset (offs), valuesSize (memsize), defaultType ( type )
-{
-    values = new unsigned char[valuesSize];
-    if (fread (values, 1, valuesSize, f) == static_cast<size_t>(valuesSize)) {
-
-        // Security ; will avoid to read above the buffer limit if the RT's tagDirectoryTable is longer that what's in the file
-        int count = valuesSize / getTypeSize (type);
-
-        for (const TagAttrib* tattr = ta; tattr->ignore != -1 && tattr->ID < count; ++tattr) {
-            Tag* newTag = new Tag (this, tattr, (values + zeroOffset + tattr->ID * getTypeSize (type)), tattr->type == AUTO ? type : tattr->type);
-            tags.push_back (newTag); // Here we can insert more tag in the same offset because of bitfield meaning
-        }
-    }
-}
-TagDirectory* TagDirectoryTable::clone (TagDirectory* parent) const
-{
-
-    TagDirectory* td = new TagDirectoryTable (parent, values, valuesSize, zeroOffset, defaultType, attribs, order);
-    return td;
-}
-
-TagDirectoryTable::~TagDirectoryTable()
-{
-    if (values) {
-        delete [] values;
-    }
-}
-int TagDirectoryTable::calculateSize ()
-{
-    return valuesSize;
-}
-
-int TagDirectoryTable::write (int start, unsigned char* buffer)
-{
-    if ( values && valuesSize) {
-        memcpy (buffer + start, values, valuesSize);
-        return start + valuesSize;
-    } else {
-        return start;
-    }
-}
-
-//--------------- class Tag ---------------------------------------------------
-// this class represents a tag stored in the directory
-//-----------------------------------------------------------------------------
-
-Tag::Tag (TagDirectory* p, FILE* f, int base)
-    : type (INVALID), count (0), value (nullptr), allocOwnMemory (true), attrib (nullptr), parent (p), directory (nullptr)
-{
-
-    ByteOrder order = getOrder();
-
-    tag   = get2 (f, order);
-    type  = (TagType)get2 (f, order);
-    count = get4 (f, order);
-
-    if (!count) {
-        count = 1;
-    }
-
-    makerNoteKind = NOMK;
-    keep = false;
-
-    // filter out invalid tags
-    // note the large count is to be able to pass LeafData ASCII tag which can be up to almost 10 megabytes,
-    // (only a small part of it will actually be parsed though)
-    if ((int)type < 1 || (int)type > 14 || count > 10 * 1024 * 1024) {
-        type = INVALID;
-        valuesize = 0;
-        return;
-    }
-
-    // store next Tag's position in file
-    int save = ftell (f) + 4;
-
-    // load value field (possibly seek before)
-    valuesize = count * getTypeSize (type);
-
-    if (valuesize > 4) {
-        fseek (f, get4 (f, getOrder()) + base, SEEK_SET);
-    }
-
-    attrib = parent->getAttrib (tag);
-
-    if (attrib && (attrib->action == AC_WRITE || attrib->action == AC_NEW)) {
-        keep = true;
-    }
-
-    if ( tag == 0xc634 ) { // DNGPrivateData
-        int currPos = ftell (f);
-        const int buffersize = 32;
-        char buffer[buffersize], *p = buffer;
-
-        while ( fread (p, 1, 1, f ) && *p != 0 && p - buffer < buffersize - 1 ) {
-            p++;
-        }
-
-        *p = 0;
-
-        if ( !strncmp (buffer, "Adobe", 5) ) {
-            fread (buffer, 1, 14, f );
-
-            if ( !strncmp ( buffer, "MakN", 4) ) {
-                ByteOrder bom = ((buffer[8] == 'M' && buffer[9] == 'M') ? MOTOROLA : INTEL) ;
-                Tag* tmake = parent->getRoot()->findTag ("Make");
-                std::string make ( tmake ? tmake->valueToString() : "");
-                int save = ftell (f);
-                int originalOffset = sget4 ( (unsigned char*)&buffer[10], ( make.find ("SONY") != std::string::npos ) || ( make.find ("Canon") != std::string::npos ) || ( make.find ("OLYMPUS") != std::string::npos ) ? MOTOROLA : bom );
-
-                if ( !parseMakerNote (f, save - originalOffset, bom )) {
-                    type = INVALID;
-                }
-            }
-        } else if ( !strncmp (buffer, "PENTAX", 6) ) {
-            makerNoteKind = HEADERIFD;
-            fread (buffer, 1, 2, f);
-            directory = new TagDirectory*[2];
-            directory[0] = new TagDirectory (parent, f, currPos, pentaxAttribs, strncmp (buffer, "MM", 2) ? INTEL : MOTOROLA);
-            directory[1] = nullptr;
-        } else
-            /* SONY uses this tag to write hidden info and pointer to private encrypted tags
-            {
-             unsigned offset =sget4((unsigned char*)buffer, order);
-             fseek(f,offset,SEEK_SET);
-             makerNoteKind = TABLESUBDIR;
-             directory = new TagDirectory*[2];
-             directory[0] = new TagDirectory (parent, f, base, sonyDNGMakerNote, order);
-             directory[1] = NULL;
-             fseek (f, save, SEEK_SET);
-             return;
-            }*/
-        {
-            type = INVALID;
-        }
-    }
-
-    if (parent->getParseJpeg() && tag == 0x002e) { // location of the embedded preview image in raw files of Panasonic cameras
-        ExifManager eManager(f, nullptr, true);
-        const auto fpos = ftell(f);
-
-        if (fpos >= 0) {
-            eManager.parseJPEG(fpos); // try to parse the exif data from the preview image
-
-            if (eManager.roots.size()) {
-                const TagDirectory* const previewdir = eManager.roots.at(0);
-                if (previewdir->getTag ("Exif")) {
-                    if (previewdir->getTag ("Make")) {
-                        if (previewdir->getTag ("Make")->valueToString() == "Panasonic") { // "make" is not yet available here, so get it from the preview tags to assure we're doing the right thing
-                            Tag* t = new Tag (parent->getRoot(), lookupAttrib (ifdAttribs, "Exif")); // replace raw exif with preview exif assuming there are the same
-                            t->initSubDir (previewdir->getTag ("Exif")->getDirectory());
-                            parent->getRoot()->addTag (t);
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    // if this tag is the makernote, it needs special treatment (brand specific parsing)
-    if (tag == 0x927C && attrib && !strcmp (attrib->name, "MakerNote") ) {
-        if ( !parseMakerNote (f, base, order )) {
-            type = INVALID;
-            fseek (f, save, SEEK_SET);
-            return;
-        }
-    } else if (attrib && attrib->subdirAttribs) {
-        // Some subdirs are specific of maker and model
-        char make[128], model[128];
-        make[0] = 0;
-        model[0] = 0;
-        Tag* tmake = parent->getRoot()->getTag ("Make");
-
-        if (tmake) {
-            tmake->toString (make, sizeof(make));
-        }
-
-        Tag* tmodel = parent->getRoot()->getTag ("Model");
-
-        if (tmodel) {
-            tmodel->toString (model, sizeof(model));
-        }
-
-        if (!strncmp (make, "SONY", 4)) {
-            switch ( tag ) {
-                case 0x0010:
-                    directory = new TagDirectory*[2];
-                    directory[1] = nullptr;
-
-                    if (count == 15360) {
-                        directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, BYTE, sonyCameraInfoAttribs, order);
-                    } else {
-                        directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, BYTE, sonyCameraInfo2Attribs, order);
-                    }
-
-                    break;
-
-                case 0x0114:
-                    directory = new TagDirectory*[2];
-                    directory[1] = nullptr;
-
-                    if (count == 280 || count == 364) {
-                        directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, SHORT, sonyCameraSettingsAttribs, MOTOROLA);
-                    } else if (count == 332) {
-                        directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, SHORT, sonyCameraSettingsAttribs2, MOTOROLA);
-                    } else if (count == 1536 || count == 2048) {
-                        directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, BYTE, sonyCameraSettingsAttribs3, INTEL);
-                    } else {
-                        // Unknown CameraSettings
-                        delete [] directory;
-                        directory = nullptr;
-                        type = INVALID;
-                    }
-
-                    makerNoteKind = directory ? TABLESUBDIR : NOMK;
-                    break;
-
-                case 0x9405:
-                    directory = new TagDirectory*[2];
-                    directory[1] = nullptr;
-                    directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, SHORT, attrib->subdirAttribs, order);
-                    makerNoteKind = TABLESUBDIR;
-                    break;
-
-                default:
-                    goto defsubdirs;
-            }
-        } else if ((!strncmp (make, "PENTAX", 6)) || (!strncmp (make, "RICOH", 5) && !strncmp (model, "PENTAX", 6))) { // Either the former Pentax brand or the RICOH brand + PENTAX model"
-            switch ( tag ) {
-                case 0x007d:
-                case 0x0205:
-                case 0x0208:
-                case 0x0216:
-                    directory = new TagDirectory*[2];
-                    directory[1] = nullptr;
-                    directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, BYTE, attrib->subdirAttribs, order);
-                    makerNoteKind = TABLESUBDIR;
-                    break;
-
-                case 0x0215:
-                    directory = new TagDirectory*[2];
-                    directory[1] = nullptr;
-                    directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, LONG, attrib->subdirAttribs, order);
-                    makerNoteKind = TABLESUBDIR;
-                    break;
-
-                case 0x005c:
-                    directory = new TagDirectory*[2];
-                    directory[1] = nullptr;
-
-                    if (count == 4) {     // SRInfo
-                        directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, BYTE, pentaxSRInfoAttribs, order);
-                    } else if (count == 2) { // SRInfo2
-                        directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, BYTE, pentaxSRInfo2Attribs, order);
-                    } else {
-                        // Unknown SRInfo
-                        delete [] directory;
-                        directory = nullptr;
-                        type = INVALID;
-                    }
-
-                    makerNoteKind = directory ? TABLESUBDIR : NOMK;
-                    break;
-
-                case 0x0206:
-                    directory = new TagDirectory*[2];
-                    directory[1] = nullptr;
-
-                    if (count == 21) {     // AEInfo2
-                        directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, BYTE, pentaxAEInfo2Attribs, order);
-                    } else if (count == 48) { // AEInfo3
-                        directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, BYTE, pentaxAEInfo3Attribs, order);
-                    } else if (count <= 25) { // AEInfo
-                        directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, BYTE, pentaxAEInfoAttribs, order);
-                    } else {
-                        // Unknown AEInfo
-                        delete [] directory;
-                        directory = nullptr;
-                        type = INVALID;
-                    }
-
-                    makerNoteKind = directory ? TABLESUBDIR : NOMK;
-                    break;
-
-                case 0x0207: {
-                    // There are 2 format pentaxLensDataAttribs
-                    int offsetFirst = 4;  // LensInfo2
-
-                    if ( strstr (model, "*ist") || strstr (model, "GX-1") || strstr (model, "K200D") || (strstr (model, "K100D") && !strstr (model, "K100D Super")) || strstr (model, "K110D") || strstr (model, "645Z")) {
-                        offsetFirst = 3;    // LensInfo
-                    } else if ( strstr (model, "645D") ) {
-                        offsetFirst = 13;    // LensInfo3
-                    } else if ( strstr (model, "K-01") || strstr (model, "K-30") || strstr (model, "K-50")) {
-                        offsetFirst = 15;    // LensInfo5
-                    } else if ( strstr (model, "K-5") || strstr (model, "K-r") ) {
-                        offsetFirst = 12;    // LensInfo4
-                    } else if (!strncmp (make, "RICOH", 5)) { // all PENTAX camera model produced under the RICOH era uses LensInfo5, for now...
-                        offsetFirst = 15;  // LensInfo5 too
-                    }
-
-                    directory = new TagDirectory*[2];
-                    directory[1] = nullptr;
-                    directory[0] = new TagDirectoryTable (parent, f, valuesize, offsetFirst, BYTE, attrib->subdirAttribs, order);
-                    makerNoteKind = TABLESUBDIR;
-                }
-                break;
-
-                case 0x0239:
-                    directory = new TagDirectory*[2];
-                    directory[1] = nullptr;
-                    directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, BYTE, attrib->subdirAttribs, order);
-                    makerNoteKind = TABLESUBDIR;
-                    break;
-
-                default:
-                    goto defsubdirs;
-            }
-        } else if (!strncmp (make, "Canon", 5)) {
-            switch ( tag ) {
-                case 0x0001:
-                case 0x0002:
-                case 0x0004:
-                case 0x0005:
-                case 0x0093:
-                case 0x0098:
-                case 0x00a0:
-                    directory = new TagDirectory*[2];
-                    directory[1] = nullptr;
-                    directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, SSHORT, attrib->subdirAttribs, order);
-                    makerNoteKind = TABLESUBDIR;
-                    break;
-
-                case 0x009a:
-                case 0x4013:
-                    directory = new TagDirectory*[2];
-                    directory[1] = nullptr;
-                    directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, LONG, attrib->subdirAttribs, order);
-                    makerNoteKind = TABLESUBDIR;
-                    break;
-
-                default:
-                    goto defsubdirs;
-            }
-        } else if (!strncmp (make, "NIKON", 5)) {
-            switch (tag) {
-                case 0x0025: {
-                    directory = new TagDirectory*[2];
-                    directory[1] = nullptr;
-                    directory[0] = new TagDirectoryTable (parent, f, valuesize, 0, BYTE, attrib->subdirAttribs, order);
-                    makerNoteKind = TABLESUBDIR;
-                    break;
-                }
-
-                default:
-                    goto defsubdirs;
-            }
-        } else if (type == UNDEFINED) {
-            count = 1;
-            type = LONG;
-            directory = new TagDirectory*[2];
-            directory[0] = new TagDirectory (parent, f, base, attrib->subdirAttribs, order);
-            directory[1] = nullptr;
-        } else {
-            goto defsubdirs;
-        }
-    } else {
-        // read value
-        value = new unsigned char [valuesize + 1];
-        auto readSize = fread (value, 1, valuesize, f);
-        value[readSize] = '\0';
-    }
-
-    // seek back to the saved position
-    fseek (f, save, SEEK_SET);
-    return;
-
-defsubdirs:
-    // read value
-    value = new unsigned char [valuesize];
-    if (fread (value, 1, valuesize, f) != static_cast<size_t>(valuesize)) {
-        type = INVALID;
-    } else {
-        // count the number of valid subdirs
-        int sdcount = count;
-
-        if (sdcount > 0) {
-            if (parent->getAttribTable() == olympusAttribs) {
-                sdcount = 1;
-            }
-
-            // allocate space
-            directory = new TagDirectory*[sdcount + 1];
-
-            // load directories
-            for (size_t j = 0, i = 0; j < count; j++, i++) {
-                int newpos = base + toInt (j * 4, LONG);
-                fseek (f, newpos, SEEK_SET);
-                directory[i] = new TagDirectory (parent, f, base, attrib->subdirAttribs, order, true, parent->getParseJpeg());
-            }
-
-            // set the terminating NULL
-            directory[sdcount] = nullptr;
-        } else {
-            type = INVALID;
-        }
-    }
-    // seek back to the saved position
-    fseek (f, save, SEEK_SET);
-    return;
-
-}
-
-bool Tag::parseMakerNote (FILE* f, int base, ByteOrder bom )
-{
-    value = nullptr;
-    Tag* tmake = parent->getRoot()->findTag ("Make");
-    std::string make ( tmake ? tmake->valueToString() : "");
-
-    Tag* tmodel = parent->getRoot()->findTag ("Model");
-    std::string model ( tmodel ? tmodel->valueToString() : "");
-
-    if ( make.find ( "NIKON" ) != std::string::npos ) {
-        if ( model.find ("NIKON E700") != std::string::npos ||
-                model.find ("NIKON E800") != std::string::npos ||
-                model.find ("NIKON E900") != std::string::npos ||
-                model.find ("NIKON E900S") != std::string::npos ||
-                model.find ("NIKON E910") != std::string::npos ||
-                model.find ("NIKON E950") != std::string::npos ) {
-            makerNoteKind = HEADERIFD;
-            valuesize = 8;
-            value = new unsigned char[8];
-            fread (value, 1, 8, f);
-            directory = new TagDirectory*[2];
-            directory[0] = new TagDirectory (parent, f, base, nikon2Attribs, bom);
-            directory[1] = nullptr;
-        } else if ( model.find ("NIKON E990") != std::string::npos ||
-                    (model.find ("NIKON D1") != std::string::npos && model.size() > 8 && model.at (8) != '0')) {
-            makerNoteKind = IFD;
-            directory = new TagDirectory*[2];
-            directory[0] = new TagDirectory (parent, f, base, nikon3Attribs, bom);
-            directory[1] = nullptr;
-        } else {
-            // needs refinement! (embedded tiff header parsing)
-            makerNoteKind = NIKON3;
-            valuesize = 18;
-            value = new unsigned char[18];
-            int basepos = ftell (f);
-            fread (value, 1, 18, f);
-            directory = new TagDirectory*[2];
-            // byte order for makernotes can be different from exif byte order. We have to get it from makernotes header
-            ByteOrder MakerNoteOrder;
-
-            if (value[10] == 'M' && value[11] == 'M') {
-                MakerNoteOrder = rtexif::MOTOROLA;
-            } else {
-                MakerNoteOrder = rtexif::INTEL;
-            }
-
-            directory[0] = new TagDirectory (parent, f, basepos + 10, nikon3Attribs, MakerNoteOrder);
-            directory[1] = nullptr;
-        }
-    } else if ( make.find ( "Canon" ) != std::string::npos  ) {
-        makerNoteKind = IFD;
-        directory = new TagDirectory*[2];
-        directory[0] = new TagDirectory (parent, f, base, canonAttribs, bom);
-        directory[1] = nullptr;
-    } else if ( make.find ( "PENTAX" ) != std::string::npos ) {
-        makerNoteKind = HEADERIFD;
-        valuesize = 6;
-        value = new unsigned char[6];
-        fread (value, 1, 6, f);
-        directory = new TagDirectory*[2];
-        directory[0] = new TagDirectory (parent, f, base, pentaxAttribs, bom);
-        directory[1] = nullptr;
-    } else if ( (make.find ( "RICOH" ) != std::string::npos ) && (model.find ("PENTAX") != std::string::npos) ) {
-        makerNoteKind = HEADERIFD;
-        valuesize = 10;
-        value = new unsigned char[10];
-        fread (value, 1, 10, f);
-        directory = new TagDirectory*[2];
-        directory[0] = new TagDirectory (parent, f, ftell (f) - 10, pentaxAttribs, bom);
-        directory[1] = nullptr;
-    } else if ( make.find ( "FUJIFILM" ) != std::string::npos ) {
-        makerNoteKind = FUJI;
-        valuesize = 12;
-        value = new unsigned char[12];
-        fread (value, 1, 12, f);
-        directory = new TagDirectory*[2];
-        directory[0] = new TagDirectory (parent, f, ftell (f) - 12, fujiAttribs, INTEL);
-        directory[1] = nullptr;
-    } else if ( make.find ( "KONICA MINOLTA" ) != std::string::npos || make.find ( "Minolta" ) != std::string::npos ) {
-        makerNoteKind = IFD;
-        directory = new TagDirectory*[2];
-        directory[0] = new TagDirectory (parent, f, base, minoltaAttribs, bom);
-        directory[1] = nullptr;
-    } else if ( make.find ( "SONY" ) != std::string::npos ) {
-        valuesize = 12;
-        value = new unsigned char[12];
-        fread (value, 1, 12, f);
-
-        if (!strncmp ((char*)value, "SONY DSC", 8)) {
-            makerNoteKind = HEADERIFD;
-        } else {
-            makerNoteKind = IFD;
-            fseek (f, -12, SEEK_CUR);
-        }
-
-        directory = new TagDirectory*[2];
-        directory[0] = new TagDirectory (parent, f, base, sonyAttribs, bom );
-        directory[1] = nullptr;
-    } else if ( make.find ( "OLYMPUS" ) != std::string::npos ) {
-        makerNoteKind = HEADERIFD;
-        valuesize = 8;
-        value = new unsigned char[12];
-        fread (value, 1, 8, f);
-        directory = new TagDirectory*[2];
-        directory[1] = nullptr;
-
-        if (!strncmp ((char*)value, "OLYMPUS", 7)) {
-            makerNoteKind = OLYMPUS2;
-            fread (value + 8, 1, 4, f);
-            valuesize = 12;
-            directory[0] = new TagDirectory (parent, f, ftell (f) - 12, olympusAttribs, value[8] == 'I' ? INTEL : MOTOROLA);
-        } else {
-            directory[0] = new TagDirectory (parent, f, base, olympusAttribs, bom);
-        }
-    } else if ( make.find ( "Panasonic" ) != std::string::npos) {
-        makerNoteKind = HEADERIFD;
-        valuesize = 12;
-        value = new unsigned char[12];
-        fread (value, 1, 12, f);
-        directory = new TagDirectory*[2];
-        directory[0] = new TagDirectory (parent, f, base, panasonicAttribs, bom, true, parent->getParseJpeg());
-        directory[1] = nullptr;
-    } else {
-        return false;
-    }
-
-    return true;
-}
-
-Tag* Tag::clone (TagDirectory* parent) const
-{
-
-    Tag* t = new Tag (parent, attrib);
-
-    t->tag = tag;
-    t->type = type;
-    t->count = count;
-    t->keep = keep;
-    t->valuesize = valuesize;
-
-    if (value) {
-        t->value = new unsigned char [valuesize];
-        memcpy (t->value, value, valuesize);
-    } else {
-        t->value = nullptr;
-    }
-
-    t->makerNoteKind = makerNoteKind;
-
-    if (directory) {
-        int ds = 0;
-
-        for (; directory[ds]; ds++);
-
-        t->directory = new TagDirectory*[ds + 1];
-
-        for (int i = 0; i < ds; i++) {
-            t->directory[i] = directory[i]->clone (parent);
-        }
-
-        t->directory[ds] = nullptr;
-    } else {
-        t->directory = nullptr;
-    }
-
-    return t;
-}
-
-Tag::~Tag ()
-{
-
-    // delete value
-    if (value && allocOwnMemory) {
-        delete [] value;
-    }
-
-    // if there are directories behind the tag, delete them
-    if (directory) {
-        int i = 0;
-
-        while (directory[i]) {
-            delete directory[i++];
-        }
-
-        delete [] directory;
-    }
-}
-
-int Tag::getDistanceFrom(const TagDirectory *root)
-{
-    int i = 0;
-    TagDirectory *currTagDir = parent;
-    while (currTagDir != nullptr && currTagDir != root) {
-        ++i;
-        if (parent->getParent() == currTagDir) {
-            break;
-        }
-        currTagDir = parent->getParent();
-    }
-    return  i;
-}
-
-void Tag::setInt (int v, int ofs, TagType astype)
-{
-
-    if (astype == SHORT) {
-        sset2 (v, value + ofs, getOrder());
-    } else if (astype == RATIONAL) {
-        sset4 (v, value + ofs, getOrder());
-        sset4 (1, value + ofs + 4, getOrder());
-    } else {
-        sset4 (v, value + ofs, getOrder());
-    }
-}
-
-void Tag::fromInt (int v)
-{
-
-    if (type == SHORT) {
-        sset2 (v, value, getOrder());
-    } else {
-        sset4 (v, value, getOrder());
-    }
-}
-
-void Tag::fromString (const char* v, int size)
-{
-
-    if ( value && allocOwnMemory) {
-        delete [] value;
-    }
-
-    if (size < 0) {
-        valuesize = strlen (v) + 1;
-    } else {
-        valuesize = size;
-    }
-
-    count = valuesize;
-
-    if ( allocOwnMemory ) {
-        value = new unsigned char [valuesize];
-    }
-
-    if(value) {
-        memcpy ((char*)value, v, valuesize);
-    }
-}
-
-int Tag::toInt (int ofs, TagType astype) const
-{
-    if (attrib) {
-        return attrib->interpreter->toInt (this, ofs, astype);
-    }
-
-    if (astype == INVALID) {
-        astype = type;
-    }
-
-    switch (astype) {
-        //case SBYTE: return (signed char)(value[ofs]);
-        case SBYTE:
-            return int ((reinterpret_cast<signed char*> (value))[ofs]);
-
-        case BYTE:
-            return value[ofs];
-
-        case ASCII:
-            return 0;
-
-        case SSHORT:
-            return (int)int2_to_signed (sget2 (value + ofs, getOrder()));
-
-        case SHORT:
-            return (int)sget2 (value + ofs, getOrder());
-
-        case SLONG:
-        case LONG:
-            return (int)sget4 (value + ofs, getOrder());
-
-        case SRATIONAL: {
-            int a = (int)sget4 (value + ofs + 4, getOrder());
-            return a == 0 ? 0 : (int)sget4 (value + ofs, getOrder()) / a;
-        }
-
-        case RATIONAL: {
-            uint32_t a = (uint32_t)sget4 (value + ofs + 4, getOrder());
-            return a == 0 ? 0 : (uint32_t)sget4 (value + ofs, getOrder()) / a;
-        }
-
-        case FLOAT:
-            return (int)toDouble (ofs);
-
-        case UNDEFINED:
-            return 0;
-
-        default:
-            return 0; // Quick fix for missing cases (INVALID, DOUBLE, OLYUNDEF, SUBDIR)
-    }
-
-    return 0;
-}
-
-double Tag::toDouble (int ofs) const
-{
-    if (attrib) {
-        return attrib->interpreter->toDouble (this, ofs);
-    }
-
-    union IntFloat {
-        uint32_t i;
-        float f;
-    } conv;
-
-    double ud, dd;
-
-    switch (type) {
-        case SBYTE:
-            return (double) (int ((reinterpret_cast<signed char*> (value))[ofs]));
-
-        case BYTE:
-            return (double) ((int)value[ofs]);
-
-        case ASCII:
-            return 0.0;
-
-        case SSHORT:
-            return (double)int2_to_signed (sget2 (value + ofs, getOrder()));
-
-        case SHORT:
-            return (double) ((int)sget2 (value + ofs, getOrder()));
-
-        case SLONG:
-        case LONG:
-            return (double) ((int)sget4 (value + ofs, getOrder()));
-
-        case SRATIONAL:
-            ud = (int)sget4 (value + ofs, getOrder());
-            dd = (int)sget4 (value + ofs + 4, getOrder());
-            return dd == 0. ? 0. : ud / dd;
-
-        case RATIONAL:
-            ud = (uint32_t)sget4 (value + ofs, getOrder());
-            dd = (uint32_t)sget4 (value + ofs + 4, getOrder());
-            return dd == 0. ? 0. : ud / dd;
-
-        case FLOAT:
-            conv.i = sget4 (value + ofs, getOrder());
-            return conv.f;  // IEEE FLOATs are already C format, they just need a recast
-
-        case UNDEFINED:
-            return 0.;
-
-        default:
-            return 0.; // Quick fix for missing cases (INVALID, DOUBLE, OLYUNDEF, SUBDIR)
-    }
-
-}
-
-/**
- * @brief Create an array of the elements
- */
-double* Tag::toDoubleArray (int ofs) const
-{
-    double *values = new double[count];
-
-    for (unsigned int i = 0; i < count; ++i) {
-        values[i] = toDouble (ofs + i * getTypeSize (type));
-    }
-
-    return values;
-}
-
-void Tag::toRational (int& num, int& denom, int ofs) const
-{
-
-    switch (type) {
-        case BYTE:
-            num = (int)value[ofs];
-            denom = 1;
-            break;
-
-        case ASCII:
-            num = 0;
-            denom = 0;
-            break;
-
-        case SSHORT:
-        case SHORT:
-            num = (int)sget2 (value + ofs, getOrder());
-            denom = 1;
-            break;
-
-        case SLONG:
-        case LONG:
-            num = (int)sget4 (value + ofs, getOrder());
-            denom = 1;
-            break;
-
-        case SRATIONAL:
-        case RATIONAL:
-            num = (int)sget4 (value + ofs, getOrder());
-            denom = (int)sget4 (value + ofs + 4, getOrder());
-            break;
-
-        case FLOAT:
-            num = 0;
-            denom = 0;
-            break;
-
-        case UNDEFINED:
-            num = 0;
-            denom = 0;
-            break;
-
-        default:
-            num = 0;
-            denom = 0;
-            break; // Quick fix for missing cases (INVALID, DOUBLE, OLYUNDEF, SUBDIR)
-    }
-}
-
-void Tag::toString (char* buffer, std::size_t size, int ofs) const
-{
-    if (!buffer || !size) {
-        return;
-    }
-
-    if (type == UNDEFINED && !directory) {
-        bool isstring = true;
-        unsigned int i = 0;
-
-        for (i = 0; i + ofs < count && i < 64 && value[i + ofs]; i++)
-            if (value[i + ofs] < 32 || value[i + ofs] > 126) {
-                isstring = false;
-            }
-
-        if (isstring) {
-            if (size < 3) {
-                return;
-            }
-
-            std::size_t j = 0;
-
-            for (i = 0; i + ofs < count && i < 64 && value[i + ofs]; i++) {
-                if (value[i + ofs] == '<' || value[i + ofs] == '>') {
-                    buffer[j++] = '\\';
-                    if (j > size - 2) {
-                        break;
-                    }
-                }
-
-                buffer[j++] = value[i + ofs];
-                if (j > size - 2) {
-                    break;
-                }
-            }
-
-            buffer[j++] = 0;
-            return;
-        }
-    } else if (type == ASCII) {
-        snprintf(buffer, size, "%.64s", value + ofs);
-        return;
-    }
-
-    size_t maxcount = rtengine::min<size_t>(count, 10);
-
-    buffer[0] = 0;
-
-    for (ssize_t i = 0; i < rtengine::min<int>(maxcount, valuesize - ofs); i++) {
-        std::size_t len = strlen(buffer);
-
-        if (i > 0 && size - len > 2) {
-            strcat (buffer, ", ");
-            len += 2;
-        }
-
-        char* b = buffer + len;
-
-        switch (type) {
-            case UNDEFINED:
-            case BYTE:
-                snprintf(b, size - len, "%d", value[i + ofs]);
-                break;
-
-            case SSHORT:
-                snprintf(b, size - len, "%d", toInt (2 * i + ofs));
-                break;
-
-            case SHORT:
-                snprintf(b, size - len, "%u", toInt (2 * i + ofs));
-                break;
-
-            case SLONG:
-                snprintf(b, size - len, "%d", toInt (4 * i + ofs));
-                break;
-
-            case LONG:
-                snprintf(b, size - len, "%u", toInt (4 * i + ofs));
-                break;
-
-            case SRATIONAL:
-                snprintf(b, size - len, "%d/%d", (int)sget4 (value + 8 * i + ofs, getOrder()), (int)sget4 (value + 8 * i + ofs + 4, getOrder()));
-                break;
-
-            case RATIONAL:
-                snprintf(b, size - len, "%u/%u", (uint32_t)sget4 (value + 8 * i + ofs, getOrder()), (uint32_t)sget4 (value + 8 * i + ofs + 4, getOrder()));
-                break;
-
-            case FLOAT:
-                snprintf(b, size - len, "%g", toDouble (8 * i + ofs));
-                break;
-
-            default:
-                break;
-        }
-    }
-
-    if (count > maxcount && size - strlen(buffer) > 3) {
-        strcat (buffer, "...");
-    }
-}
-
-std::string Tag::nameToString (int i)
-{
-
-    char buffer[1025];
-
-    if (attrib) {
-        strncpy (buffer, attrib->name, 1024);
-    } else {
-        snprintf(buffer, sizeof(buffer), "0x%x", tag);
-    }
-
-    if (i > 0) {
-        sprintf (buffer + strlen (buffer) - 1, "[%d]", i);
-    }
-
-    return buffer;
-}
-
-std::string Tag::valueToString () const
-{
-
-    if (attrib && attrib->interpreter) {
-        return attrib->interpreter->toString (this);
-    } else {
-        char buffer[1024];
-        toString (buffer, sizeof(buffer));
-        return buffer;
-    }
-}
-
-void Tag::valueFromString (const std::string& value)
-{
-
-    if (attrib && attrib->interpreter) {
-        attrib->interpreter->fromString (this, value);
-    }
-}
-
-void Tag::userCommentFromString (const Glib::ustring& text)
-{
-
-    if (!allocOwnMemory) {
-        return;
-    }
-    if (value) {
-        delete [] value;
-        value = nullptr;
-    }
-    initUserComment(text);
-}
-
-int Tag::calculateSize ()
-{
-    int size = 0;
-
-    if (directory) {
-        int j;
-
-        for (j = 0; directory[j]; j++) {
-            size += directory[j]->calculateSize ();
-        }
-
-        if (j > 1) {
-            size += 4 * j;
-        }
-        if (makerNoteKind != NOMK) {
-            count = directory[0]->calculateSize () / getTypeSize (type);
-        }
-    } else if (valuesize > 4) {
-        size += valuesize + (valuesize % 2);    // we align tags to even byte positions
-    }
-
-
-    if (makerNoteKind == NIKON3 || makerNoteKind == OLYMPUS2 || makerNoteKind == FUJI || makerNoteKind == HEADERIFD) {
-        size += valuesize;
-    }
-
-    return size;
-}
-
-int Tag::write (int offs, int dataOffs, unsigned char* buffer)
-{
-
-    if ((int)type == 0 || offs > 65500) {
-        return dataOffs;
-    }
-
-    sset2 (tag, buffer + offs, parent->getOrder());
-    offs += 2;
-    unsigned short typ = type;
-    sset2 (typ, buffer + offs, parent->getOrder());
-    offs += 2;
-    sset4 (count, buffer + offs, parent->getOrder());
-    offs += 4;
-
-    if (!directory) {
-        if (valuesize > 4) {
-            sset4 (dataOffs, buffer + offs, parent->getOrder());
-            memcpy (buffer + dataOffs, value, valuesize);
-
-            if (valuesize % 2) {
-                buffer[dataOffs + valuesize] = 0;    // zero padding required by the exif standard
-            }
-
-            return dataOffs + valuesize + (valuesize % 2);
-        } else {
-            memcpy (buffer + offs, value, valuesize);
-            return dataOffs;
-        }
-    } else {
-        if (makerNoteKind == NIKON3) {
-            sset4 (dataOffs, buffer + offs, parent->getOrder());
-            memcpy (buffer + dataOffs, value, 18);
-            dataOffs += 10;
-            dataOffs += directory[0]->write (8, buffer + dataOffs);
-            return dataOffs;
-        } else if (makerNoteKind == OLYMPUS2 || makerNoteKind == FUJI) {
-            sset4 (dataOffs, buffer + offs, parent->getOrder());
-            memcpy (buffer + dataOffs, value, valuesize);
-            dataOffs += valuesize + directory[0]->write (valuesize, buffer + dataOffs);
-            return dataOffs;
-        } else if (makerNoteKind == HEADERIFD) {
-            sset4 (dataOffs, buffer + offs, parent->getOrder());
-            memcpy (buffer + dataOffs, value, valuesize);
-            dataOffs += valuesize;
-            dataOffs += directory[0]->write (dataOffs, buffer);
-            return dataOffs;
-        } else if ( makerNoteKind == TABLESUBDIR) {
-            sset4 (dataOffs, buffer + offs, parent->getOrder());
-            dataOffs = directory[0]->write (dataOffs, buffer);
-            return dataOffs;
-        } else if (!directory[1]) {
-            sset4 (dataOffs, buffer + offs, parent->getOrder());
-            return directory[0]->write (dataOffs, buffer);
-        } else {
-            sset4 (dataOffs, buffer + offs, parent->getOrder());
-            int linkOffs = dataOffs;
-
-            for (int i = 0; directory[i]; i++) {
-                dataOffs += 4;
-            }
-
-            for (int i = 0; directory[i]; i++) {
-                sset4 (dataOffs, buffer + linkOffs, parent->getOrder());
-                linkOffs += 4;
-                dataOffs = directory[i]->write (dataOffs, buffer);
-            }
-
-            return dataOffs;
-        }
-    }
-}
-
-Tag::Tag (TagDirectory* p, const TagAttrib* attr)
-    : tag (attr ? attr->ID : -1), type (INVALID), count (0), value (nullptr), valuesize (0), keep (true), allocOwnMemory (true), attrib (attr), parent (p), directory (nullptr), makerNoteKind (NOMK)
-{
-}
-
-Tag::Tag (TagDirectory* p, const TagAttrib* attr, int data, TagType t)
-    : tag (attr ? attr->ID : -1), type (t), count (1), value (nullptr), valuesize (0), keep (true), allocOwnMemory (true), attrib (attr), parent (p), directory (nullptr), makerNoteKind (NOMK)
-{
-
-    initInt (data, t);
-}
-
-Tag::Tag (TagDirectory* p, const TagAttrib* attr, unsigned char *data, TagType t)
-    : tag (attr ? attr->ID : -1), type (t), count (1), value (nullptr), valuesize (0), keep (true), allocOwnMemory (false), attrib (attr), parent (p), directory (nullptr), makerNoteKind (NOMK)
-{
-
-    initType (data, t);
-}
-
-Tag::Tag (TagDirectory* p, const TagAttrib* attr, const char* text)
-    : tag (attr ? attr->ID : -1), type (ASCII), count (1), value (nullptr), valuesize (0), keep (true), allocOwnMemory (true), attrib (attr), parent (p), directory (nullptr), makerNoteKind (NOMK)
-{
-
-    initString (text);
-}
-
-void Tag::initType (unsigned char *data, TagType type)
-{
-    valuesize = getTypeSize (type);
-
-    if ( allocOwnMemory ) {
-        value = new unsigned char[valuesize];
-        memcpy ((char*)value, data, valuesize);
-    } else {
-        value = data;
-    }
-}
-
-void Tag::initInt (int data, TagType t, int cnt)
-{
-
-    type = t;
-
-    if (t == LONG) {
-        valuesize = 4;
-    } else if (t == SHORT) {
-        valuesize = 2;
-    } else if (t == BYTE) {
-        valuesize = 1;
-    } else if (t == RATIONAL) {
-        valuesize = 8;
-    }
-
-    count = cnt;
-    valuesize *= count;
-    value = new unsigned char[valuesize];
-    setInt (data, 0, t);
-}
-
-void Tag::swapByteOrder2(unsigned char *buffer, int count)
-{
-    unsigned char* ptr = buffer;
-    for (int i = 0; i < count; i+=2) {
-        unsigned char c = ptr[0];
-        ptr[0] = ptr[1];
-        ptr[1] = c;
-        ptr += 2;
-    }
-}
-void Tag::initUserComment (const Glib::ustring &text)
-{
-    const bool useBOM = false; // set it to true if you want to output BOM in UCS-2/UTF-8 UserComments ; this could be turned to an options entry
-    type = UNDEFINED;
-    if (text.is_ascii()) {
-        valuesize = count = 8 + strlen (text.c_str());
-        value = new unsigned char[valuesize];
-        memcpy(value, "ASCII\0\0\0", 8);
-        memcpy(value + 8, text.c_str(), valuesize - 8);
-    } else {
-        glong wcStrSize = 0;
-        gunichar2 *commentStr = g_utf8_to_utf16 (text.c_str(), -1, nullptr, &wcStrSize, nullptr);
-        valuesize = count = wcStrSize * 2 + 8 + (useBOM ? 2 : 0);
-        value = new unsigned char[valuesize];
-        memcpy(value, "UNICODE\0", 8);
-
-        if (useBOM) {
-            if (getOrder() == INTEL) { //Little Endian
-                value[8] = 0xFF;
-                value[9] = 0xFE;
-            } else {
-                value[8] = 0xFE;
-                value[9] = 0xFF;
-            }
-        }
-
-        // Swapping byte order to match the Exif's byte order
-        if (getOrder() != HOSTORDER) {
-            swapByteOrder2((unsigned char*)commentStr, wcStrSize * 2);
-        }
-
-        memcpy(value + 8 + (useBOM ? 2 : 0), (char*)commentStr, wcStrSize * 2);
-        g_free(commentStr);
-    }
-}
-
-void Tag::initString (const char* text)
-{
-
-    type = ASCII;
-    count = strlen (text) + 1;
-    valuesize = count;
-    value = new unsigned char[valuesize];
-    strcpy ((char*)value, text);
-}
-
-void Tag::initSubDir ()
-{
-    type = LONG;
-    valuesize = 4;
-    count = 1;
-    value = new unsigned char[4];
-    setInt (0);
-    directory = new TagDirectory*[2];
-    directory[0] = new TagDirectory (parent, attrib ? attrib->subdirAttribs : nullptr, parent->getOrder());
-    directory[1] = nullptr;
-}
-
-void Tag::initSubDir (TagDirectory* dir)
-{
-    type = LONG;
-    valuesize = 4;
-    count = 1;
-    value = new unsigned char[4];
-    setInt (0);
-    directory = new TagDirectory*[2];
-    directory[0] = dir;
-    directory[1] = nullptr;
-}
-
-void Tag::initMakerNote (MNKind mnk, const TagAttrib* ta)
-{
-    type = UNDEFINED;
-    valuesize = 4;
-    count = 1;
-    value = new unsigned char[4];
-    setInt (0);
-    directory = new TagDirectory*[2];
-    directory[0] = new TagDirectory (parent, ta, parent->getOrder());
-    directory[1] = nullptr;
-    makerNoteKind = mnk;
-}
-
-void Tag::initUndefArray (const char* data, int len)
-{
-    type = UNDEFINED;
-    count = valuesize = len;
-    value = new unsigned char[valuesize];
-    memcpy (value, data, len);
-}
-
-void Tag::initLongArray (const char* data, int len)
-{
-    type = LONG;
-    count = (len + 3) / 4;
-    valuesize = count * 4;
-    value = new unsigned char[valuesize];
-    memcpy (value, data, len);
-}
-
-void Tag::initRational (int num, int den)
-{
-    count = 1;
-    valuesize = 8;
-    value = new unsigned char[8];
-    type = RATIONAL;
-    setInt (num, 0);
-    setInt (den, 4);
-}
-
-//--------------- class IFDParser ---------------------------------------------
-// static functions to read tag directories from different kinds of files
-//-----------------------------------------------------------------------------
-
-
-const TagAttrib* lookupAttrib (const TagAttrib* dir, const char* field)
-{
-
-    for (int i = 0; dir[i].ignore != -1; i++)
-        if (!strcmp (dir[i].name, field)) {
-            return &dir[i];
-        }
-
-    return nullptr;
-}
-
-void ExifManager::setIFDOffset(unsigned int offset)
-{
-    IFDOffset = offset;
-}
-
-void ExifManager::parseCIFF ()
-{
-
-    TagDirectory* root = new TagDirectory (nullptr, ifdAttribs, INTEL);
-    Tag* exif = new Tag (root, lookupAttrib (ifdAttribs, "Exif"));
-    exif->initSubDir ();
-    root->addTag (exif);
-    if (exif) {
-        Tag* mn = new Tag (exif->getDirectory(), lookupAttrib (exifAttribs, "MakerNote"));
-        mn->initMakerNote (IFD, canonAttribs);
-        exif->getDirectory()->addTag (mn);
-    }
-    parseCIFF (rml->ciffLength, root);
-    root->sort ();
-    parse(true);
-}
-
-Tag* ExifManager::saveCIFFMNTag (TagDirectory* root, int len, const char* name)
-{
-    int s = ftell (f);
-    if(s >= 0) {
-        char* data = new char [len];
-        fread (data, len, 1, f);
-        TagDirectory* mn = root->getTag ("Exif")->getDirectory()->getTag ("MakerNote")->getDirectory();
-        Tag* cs = new Tag (mn, lookupAttrib (canonAttribs, name));
-        cs->initUndefArray (data, len);
-        mn->addTag (cs);
-        fseek (f, s, SEEK_SET);
-        delete [] data;
-        return cs;
-    } else {
-        return nullptr;
-    }
-}
-
-void ExifManager::parseCIFF (int length, TagDirectory* root)
-{
-
-    if (!f) {
-        #ifndef NDEBUG
-        std::cerr << "ERROR : no file opened !" << std::endl;
-        #endif
-        return;
-    }
-
-    char buffer[1024];
-    Tag* t;
-
-    if (fseek(f, rml->ciffBase + length - 4, SEEK_SET)) {
-        return;
-    }
-
-    int dirStart = get4 (f, INTEL) + rml->ciffBase;
-    if (fseek(f, dirStart, SEEK_SET)) {
-        return;
-    }
-
-    int numOfTags = get2 (f, INTEL);
-
-    if (numOfTags > 100) {
-        return;
-    }
-
-    float exptime, shutter, aperture, fnumber, ev;
-    exptime = fnumber = shutter = aperture = ev = -1000.f;
-    int focal_len, iso;
-    focal_len = iso = -1;
-
-    TagDirectory* exif = root->getTag ("Exif")->getDirectory();
-
-    time_t timestamp = time (nullptr);
-
-    for (int i = 0; i < numOfTags; i++) {
-
-        int type = get2 (f, INTEL);
-        int len  = get4 (f, INTEL);
-        int nextPos = ftell (f) + 4;
-
-        // seek to the location of the value
-        fseek (f, rml->ciffBase + get4 (f, INTEL), SEEK_SET);
-
-        if ((((type >> 8) + 8) | 8) == 0x38) {
-            ExifManager(
-                f,
-                std::unique_ptr<rtengine::RawMetaDataLocation>(
-                    new rtengine::RawMetaDataLocation(
-                        ftell(f),
-                        len
-                    )
-                ),
-                true
-            ).parseCIFF(len, root); // Parse a sub-table
-        }
-
-        if (type == 0x0810) {
-            fread (buffer, 64, 1, f);
-            t = new Tag (root, lookupAttrib (ifdAttribs, "Artist"));
-            t->initString (buffer);
-            root->addTag (t);
-        }
-
-        if (type == 0x080a) {
-            fread (buffer, 64, 1, f);
-            t = new Tag (root, lookupAttrib (ifdAttribs, "Make"));
-            t->initString (buffer);
-            root->addTag (t);
-            if (!fseek (f, strlen (buffer) - 63, SEEK_CUR)) {
-                if (fread (buffer, 64, 1, f) == 1) {
-                    t = new Tag (root, lookupAttrib (ifdAttribs, "Model"));
-                    t->initString (buffer);
-                    root->addTag (t);
-                }
-            }
-        }
-
-        if (type == 0x1818) {
-            ev = int_to_float (get4 (f, INTEL));
-            shutter = int_to_float (get4 (f, INTEL));
-            exptime = pow (2, -shutter);
-            aperture = int_to_float (get4 (f, INTEL));
-            fnumber = pow (2, aperture / 2);
-
-        }
-
-        ExifManager exifManager(f, nullptr, true);
-        if (type == 0x102d) {
-            Tag* t = exifManager.saveCIFFMNTag (root, len, "CanonCameraSettings");
-            int mm = t->toInt (34, SHORT);
-            Tag* nt = new Tag (exif, lookupAttrib (exifAttribs, "MeteringMode"));
-
-            switch (mm) {
-                case 0:
-                    nt->initInt (5, SHORT);
-                    break;
-
-                case 1:
-                    nt->initInt (3, SHORT);
-                    break;
-
-                case 2:
-                    nt->initInt (1, SHORT);
-                    break;
-
-                case 3:
-                    nt->initInt (5, SHORT);
-                    break;
-
-                case 4:
-                    nt->initInt (6, SHORT);
-                    break;
-
-                case 5:
-                    nt->initInt (2, SHORT);
-                    break;
-            }
-
-            exif->addTag (nt);
-            nt = new Tag (exif, lookupAttrib (exifAttribs, "MaxApertureValue"));
-            nt->initRational (t->toInt (52, SHORT), 32);
-            exif->addTag (nt);
-            int em = t->toInt (40, SHORT);
-            nt = new Tag (exif, lookupAttrib (exifAttribs, "ExposureProgram"));
-
-            switch (em) {
-                case 0:
-                    nt->initInt (2, SHORT);
-                    break;
-
-                case 1:
-                    nt->initInt (2, SHORT);
-                    break;
-
-                case 2:
-                    nt->initInt (4, SHORT);
-                    break;
-
-                case 3:
-                    nt->initInt (3, SHORT);
-                    break;
-
-                case 4:
-                    nt->initInt (1, SHORT);
-                    break;
-
-                default:
-                    nt->initInt (0, SHORT);
-                    break;
-            }
-
-            exif->addTag (nt);
-            nt = new Tag (exif, lookupAttrib (exifAttribs, "Flash"));
-
-            if (t->toInt (8, SHORT) == 0) {
-                nt->initInt (0, SHORT);
-            } else {
-                nt->initInt (1, SHORT);
-            }
-
-            exif->addTag (nt);
-            nt = new Tag (exif, lookupAttrib (exifAttribs, "MaxApertureValue"));
-            nt->initRational (t->toInt (52, SHORT), 32);
-            exif->addTag (nt);
-        }
-
-        if (type == 0x1029) {
-            exifManager.saveCIFFMNTag (root, len, "CanonFocalLength");
-        }
-
-        if (type == 0x1031) {
-            exifManager.saveCIFFMNTag (root, len, "SensorInfo");
-        }
-
-        if (type == 0x1033) {
-            exifManager.saveCIFFMNTag (root, len, "CustomFunctions");
-        }
-
-        if (type == 0x1038) {
-            exifManager.saveCIFFMNTag (root, len, "CanonAFInfo");
-        }
-
-        if (type == 0x1093) {
-            exifManager.saveCIFFMNTag (root, len, "CanonFileInfo");
-        }
-
-        if (type == 0x10a9) {
-            exifManager.saveCIFFMNTag (root, len, "ColorBalance");
-        }
-
-        if (type == 0x102a) {
-            exifManager.saveCIFFMNTag (root, len, "CanonShotInfo");
-
-            iso = pow (2, (get4 (f, INTEL), get2 (f, INTEL)) / 32.0 - 4) * 50;
-            aperture  = (get2 (f, INTEL), (short)get2 (f, INTEL)) / 32.0f;
-            fnumber = pow (2, aperture / 2);
-            shutter = ((short)get2 (f, INTEL)) / 32.0f;
-            ev = ((short)get2 (f, INTEL)) / 32.0f;
-            fseek (f, 34, SEEK_CUR);
-
-            if (shutter > 1e6f) {
-                shutter = get2 (f, INTEL) / 10.0f;
-            }
-
-            exptime   = pow (2, -shutter);
-        }
-
-        if (type == 0x5029) {
-            focal_len = len >> 16;
-
-            if ((len & 0xffff) == 2) {
-                focal_len /= 32;
-            }
-        }
-
-//    if (type == 0x5813) flash_used = int_to_float(len);
-        if (type == 0x580e) {
-            timestamp  = len;
-        }
-
-        if (type == 0x180e) {
-            timestamp  = get4 (f, INTEL);
-        }
-
-        if ((type | 0x4000) == 0x580e) {
-            timestamp = mktime (gmtime (&timestamp));
-        }
-
-        fseek (f, nextPos, SEEK_SET);
-    }
-
-    if (shutter > -999) {
-        t = new Tag (exif, lookupAttrib (exifAttribs, "ShutterSpeedValue"));
-        t->initRational ((int) (shutter * 10000), 10000);
-        exif->addTag (t);
-    }
-
-    if (exptime > -999) {
-        t = new Tag (exif, lookupAttrib (exifAttribs, "ExposureTime"));
-        t->initRational ((int) (exptime * 10000), 10000);
-        exif->addTag (t);
-    }
-
-    if (aperture > -999) {
-        t = new Tag (exif, lookupAttrib (exifAttribs, "ApertureValue"));
-        t->initRational ((int) (aperture * 10), 10);
-        exif->addTag (t);
-    }
-
-    if (fnumber > -999) {
-        t = new Tag (exif, lookupAttrib (exifAttribs, "FNumber"));
-        t->initRational ((int) (fnumber * 10), 10);
-        exif->addTag (t);
-    }
-
-    if (ev > -999) {
-        t = new Tag (exif, lookupAttrib (exifAttribs, "ExposureBiasValue"));
-        t->initRational ((int) (ev * 1000), 1000);
-        exif->addTag (t);
-    }
-
-    if (iso > 0) {
-        t = new Tag (exif, lookupAttrib (exifAttribs, "ISOSpeedRatings"));
-        t->initInt (iso, LONG);
-        exif->addTag (t);
-    }
-
-    if (focal_len > 0) {
-        t = new Tag (exif, lookupAttrib (exifAttribs, "FocalLength"));
-        t->initRational (focal_len * 32, 32);
-        exif->addTag (t);
-    }
-
-    if (timestamp != time (nullptr)) {
-        struct tm* tim = localtime (&timestamp);
-        strftime (buffer, 20, "%Y:%m:%d %H:%M:%S", tim);
-        t = new Tag (exif, lookupAttrib (exifAttribs, "DateTimeOriginal"));
-        t->initString (buffer);
-        exif->addTag (t);
-        t = new Tag (exif, lookupAttrib (exifAttribs, "DateTimeDigitized"));
-        t->initString (buffer);
-        exif->addTag (t);
-        t = new Tag (root, lookupAttrib (ifdAttribs, "DateTime"));
-        t->initString (buffer);
-        root->addTag (t);
-    }
-
-    roots.push_back(root);
-
-}
-
-static void
-parse_leafdata (TagDirectory* root, ByteOrder order)
-{
-
-    Tag *leafdata = root->getTag ("LeafData");
-
-    if (!leafdata) {
-        return;
-    }
-
-    unsigned char *value = leafdata->getValue();
-    int valuesize = leafdata->getValueSize();
-
-    // parse LeafData tag, a tag specific to Leaf digital backs, and has a custom
-    // format with 52 byte tag headers starting with "PKTS"
-    const char *PKTS_tag = (order == MOTOROLA) ? "PKTS" : "STKP";
-    char *hdr;
-    int pos = 0;
-
-    // There are lots of sub-tags in here, but for now we only care about those directly
-    // useful to RT, which is ISO and rotation. Shutter speed and aperture is not
-    // available here.
-    int iso_speed = 0;
-    int rotation_angle = 0;
-    int found_count = 0;
-
-    while (pos + (int)sizeof (hdr) <= valuesize && found_count < 2) {
-        hdr = (char *)&value[pos];
-
-        if (strncmp (hdr, PKTS_tag, 4) != 0) {
-            // in a few cases the header can be offset a few bytes, don't know why
-            // it does not seem to be some sort of alignment, it appears random,
-            // this check takes care of it, restart if we find an offset match.
-            int offset = 1;
-
-            for (; offset <= 3; offset++) {
-                if (strncmp (&hdr[offset], PKTS_tag, 4) == 0) {
-                    pos += offset;
-                    break;
-                }
-            }
-
-            if (offset <= 3) {
-                continue;
-            }
-
-            break;
-        }
-
-        int size = sget4 ((unsigned char *)&hdr[48], order);
-
-        if (pos + size > valuesize) {
-            break;
-        }
-
-        pos += 52;
-        char *val = (char *)&value[pos];
-
-        if (strncmp (&hdr[8], "CameraObj_ISO_speed", 19) == 0) {
-            iso_speed = 25 * (1 << std::max((atoi (val) - 1), 0));
-            found_count++;
-        } else if (strncmp (&hdr[8], "ImgProf_rotation_angle", 22) == 0) {
-            rotation_angle = atoi (val);
-            found_count++;
-        } else {
-            // check if this is a sub-directory, include test for that strange offset of next header
-            if (size >= 8 &&
-                    (strncmp (val, PKTS_tag, 4) == 0 ||
-                     strncmp (&val[1], PKTS_tag, 4) == 0 ||
-                     strncmp (&val[2], PKTS_tag, 4) == 0 ||
-                     strncmp (&val[3], PKTS_tag, 4) == 0)) {
-                // start of next hdr, this is a sub-directory, we skip those for now.
-                size = 0;
-            }
-        }
-
-        pos += size;
-    }
-
-    // create standard tags from the custom Leaf tags
-    Tag* exif = root->getTag ("Exif");
-
-    if (!exif) {
-        exif = new Tag (root, root->getAttrib ("Exif"));
-        exif->initSubDir();
-        root->addTagFront (exif);
-    }
-
-    if (exif && !exif->getDirectory()->getTag ("ISOSpeedRatings")) {
-        Tag *t = new Tag (exif->getDirectory(), exif->getDirectory()->getAttrib ("ISOSpeedRatings"));
-        t->initInt (iso_speed, LONG);
-        exif->getDirectory()->addTagFront (t);
-    }
-
-    if (!root->getTag ("Orientation")) {
-        int orientation;
-
-        switch (rotation_angle) {
-            case 0:
-                orientation = 1;
-                break;
-
-            case 90:
-                orientation = 6;
-                break;
-
-            case 180:
-                orientation = 3;
-                break;
-
-            case 270:
-                orientation = 8;
-                break;
-
-            default:
-                orientation = 1;
-                break;
-        }
-
-        Tag *t = new Tag (root, root->getAttrib ("Orientation"));
-        t->initInt (orientation, SHORT);
-        root->addTagFront (t);
-    }
-
-    // now look in ApplicationNotes tag for additional information
-    Tag *appnotes = root->getTag ("ApplicationNotes");
-
-    if (!appnotes) {
-        return;
-    }
-
-    char *xmp = (char *)appnotes->getValue();
-    char *end, *p;
-
-    // Quick-and-dirty value extractor, no real xml parsing.
-    // We could make it more generic, but we just get most important
-    // values we know use to be in there.
-    if ((p = strstr (xmp, "xmlns:tiff")) != nullptr &&
-            (end = strstr (p, "</rdf:Description>")) != nullptr) {
-        *end = '\0';
-
-        while ((p = strstr (p, "<tiff:")) != nullptr) {
-            char *tag = &p[6], *tagend;
-
-            if ((tagend = strchr (tag, '>')) == nullptr) {
-                break;
-            }
-
-            *tagend = '\0';
-            char *val = &tagend[1];
-
-            if ((p = strstr (val, "</tiff:")) == nullptr) {
-                *tagend = '>';
-                break;
-            }
-
-            *p = '\0';
-
-            if (root->getAttrib (tag) && !root->getTag (tag)) {
-                Tag *t = new Tag (root, root->getAttrib (tag));
-
-                if (strcmp (tag, "Make") == 0 ||
-                        strcmp (tag, "Model") == 0) {
-                    if (strcmp (tag, "Model") == 0) {
-                        // Leaf adds back serial number and camera model to the 'Model'
-                        // tag, we strip that away here so the back can be recognized
-                        // and matched against DCP profile
-                        char *p1 = strchr (val, '(');
-
-                        if (p1 != nullptr) {
-                            *p1 = '\0';
-                        }
-
-                        // Model name also contains a leading "Leaf " which we already
-                        // have in the Make name, remove that.
-                        if (strstr (val, "Leaf ") == val) {
-                            t->initString (&val[5]);
-                        } else {
-                            t->initString (val);
-                        }
-
-                        if (p1 != nullptr) {
-                            *p1 = '(';
-                        }
-                    } else {
-                        t->initString (val);
-                    }
-
-                    root->addTagFront (t);
-                } else {
-                    delete t;
-                }
-            }
-
-            *p = '<';
-            *tagend = '>';
-        }
-
-        *end = '<';
-    }
-
-    if ((p = strstr (xmp, "xmlns:exif")) != nullptr &&
-            (end = strstr (p, "</rdf:Description>")) != nullptr) {
-        *end = '\0';
-
-        while ((p = strstr (p, "<exif:")) != nullptr) {
-            char *tag = &p[6], *tagend;
-
-            if ((tagend = strchr (tag, '>')) == nullptr) {
-                break;
-            }
-
-            *tagend = '\0';
-            char *val = &tagend[1];
-
-            if ((p = strstr (val, "</exif:")) == nullptr) {
-                *tagend = '>';
-                break;
-            }
-
-            *p = '\0';
-
-            if (exif->getDirectory()->getAttrib (tag) && !exif->getDirectory()->getTag (tag)) {
-                Tag *t = new Tag (exif->getDirectory(), exif->getDirectory()->getAttrib (tag));
-                int num, denom;
-                struct tm tm;
-
-                if (strcmp (tag, "ApertureValue") == 0 && sscanf (val, "%d/%d", &num, &denom) == 2) {
-                    t->initRational (num, denom);
-                    exif->getDirectory()->addTagFront (t);
-                    // we also make an "FNumber" tag since many tools don't interpret ApertureValue
-                    // according to Exif standard
-                    t = new Tag (exif->getDirectory(), lookupAttrib (exifAttribs, "FNumber"));
-                    double f = pow (sqrt (2.0), ((double)num / denom));
-
-                    if (f > 10.0) {
-                        t->initRational ((int)floor (f), 1);
-                    } else {
-                        t->initRational ((int)floor (f * 10.0), 10);
-                    }
-
-                    exif->getDirectory()->addTagFront (t);
-                } else if (strcmp (tag, "ShutterSpeedValue") == 0 && sscanf (val, "%d/%d", &num, &denom) == 2) {
-                    t->initRational (num, denom);
-                    exif->getDirectory()->addTagFront (t);
-                    // we also make an "ExposureTime" tag since many tools don't interpret ShutterSpeedValue
-                    // according to Exif standard
-                    t = new Tag (exif->getDirectory(), lookupAttrib (exifAttribs, "ExposureTime"));
-                    double f = 1.0 / pow (2.0, ((double)num / denom));
-
-                    if (f > 10.0) {
-                        t->initRational ((int)floor (f), 1);
-                    } else if (f > 1.0) {
-                        t->initRational ((int)floor (f * 10.0), 10);
-                    } else if (f == 1.0) {
-                        t->initRational (1, 1);
-                    } else {
-                        f = 1.0 / f;
-                        static const double etimes[] = {
-                            10000, 8000, 6400, 6000, 5000,
-                            4000, 3200, 3000, 2500,
-                            2000, 1600, 1500, 1250,
-                            1000, 800, 750, 640,
-                            500, 400, 350, 320,
-                            250, 200, 180, 160,
-                            125, 100, 90, 80,
-                            60, 50, 45, 40,
-                            30, 25, 22, 20,
-                            15, 13, 11, 10,
-                            8, 6, 5,
-                            4, 3, 2.5,
-                            2, 1.6, 1.5, 1.3,
-                            1, -1
-                        };
-                        double diff = etimes[0];
-                        int idx = -1;
-
-                        for (int i = 1; etimes[i] > 0; i++) {
-                            if (abs (etimes[i] - f) < diff) {
-                                idx = i;
-                                diff = abs (etimes[i] - f);
-                            }
-                        }
-
-                        if (idx != -1 && f < etimes[0]) {
-                            f = etimes[idx];
-                        }
-
-                        if (f < 2) {
-                            t->initRational (10, (int) (10 * f));
-                        } else {
-                            t->initRational (1, (int)f);
-                        }
-                    }
-
-                    exif->getDirectory()->addTagFront (t);
-                } else if (strcmp (tag, "FocalLength") == 0 && sscanf (val, "%d/%d", &num, &denom) == 2) {
-                    t->initRational (num, denom);
-                    exif->getDirectory()->addTagFront (t);
-                } else if (strcmp (tag, "ISOSpeedRatings") == 0) {
-                    char *p1 = val;
-
-                    while (*p1 != '\0' && !isdigit (*p1)) {
-                        p1++;
-                    }
-
-                    if (*p1 != '\0') {
-                        t->initInt (atoi (p1), LONG);
-                        exif->getDirectory()->addTagFront (t);
-                    } else {
-                        delete t;
-                    }
-                } else if (strcmp (tag, "DateTimeOriginal") == 0 &&
-                           sscanf (val, "%d-%d-%dT%d:%d:%dZ",
-                                   &tm.tm_year, &tm.tm_mon,
-                                   &tm.tm_mday, &tm.tm_hour,
-                                   &tm.tm_min, &tm.tm_sec) == 6) {
-                    char tstr[64];
-                    snprintf(tstr, sizeof(tstr), "%04d:%02d:%02d %02d:%02d:%02d", tm.tm_year, tm.tm_mon,
-                             tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
-                    t->initString (tstr);
-                    exif->getDirectory()->addTagFront (t);
-                } else {
-                    delete t;
-                }
-            }
-
-            *p = '<';
-            *tagend = '>';
-        }
-
-        *end = '<';
-    }
-}
-
-void ExifManager::parseRaw (bool skipIgnored) {
-    parse(true, skipIgnored);
-}
-
-void ExifManager::parseStd (bool skipIgnored) {
-    parse(false, skipIgnored);
-}
-
-void ExifManager::parse (bool isRaw, bool skipIgnored, bool parseJpeg)
-{
-    int ifdOffset = IFDOffset;
-
-    if (!f) {
-        #ifndef NDEBUG
-        std::cerr << "ERROR : no file opened !" << std::endl;
-        #endif
-        return;
-    }
-    setlocale (LC_NUMERIC, "C"); // to set decimal point in sscanf
-
-    if (order == ByteOrder::UNKNOWN) {
-        // read tiff header
-        fseek (f, rml->exifBase, SEEK_SET);
-        unsigned short bo;
-        fread (&bo, 1, 2, f);
-        order = (ByteOrder) ((int)bo);
-        get2 (f, order);
-        if (!ifdOffset) {
-            ifdOffset = get4 (f, order);
-        }
-    }
-
-    do {
-        // seek to IFD
-        fseek (f, rml->exifBase + ifdOffset, SEEK_SET);
-
-        // first read the IFD directory
-        TagDirectory* root =  new TagDirectory (nullptr, f, rml->exifBase, ifdAttribs, order, skipIgnored, parseJpeg);
-
-        // fix ISO issue with nikon and panasonic cameras
-        Tag* make = root->getTag ("Make");
-        Tag* exif = root->getTag ("Exif");
-
-        if (exif && !exif->getDirectory()->getTag ("ISOSpeedRatings")) {
-            if (make && !strncmp ((char*)make->getValue(), "NIKON", 5)) {
-                Tag* mn   = exif->getDirectory()->getTag ("MakerNote");
-
-                if (mn) {
-                    Tag* iso = mn->getDirectory()->getTag ("ISOSpeed");
-
-                    if (iso) {
-                        std::string isov = iso->valueToString ();
-                        Tag* niso = new Tag (exif->getDirectory(), exif->getDirectory()->getAttrib ("ISOSpeedRatings"));
-                        niso->initInt (atoi (isov.c_str()), SHORT);
-                        exif->getDirectory()->addTagFront (niso);
-                    }
-                }
-            } else if (make && (!strncmp ((char*)make->getValue(), "Panasonic", 9) || !strncmp ((char*)make->getValue(), "LEICA", 5))) {
-                Tag* iso = root->getTag ("PanaISO");
-
-                if (iso) {
-                    std::string isov = iso->valueToString ();
-                    Tag* niso = new Tag (exif->getDirectory(), exif->getDirectory()->getAttrib ("ISOSpeedRatings"));
-                    niso->initInt (atoi (isov.c_str()), SHORT);
-                    exif->getDirectory()->addTagFront (niso);
-                }
-            }
-        }
-
-        if (make && !strncmp ((char*)make->getValue(), "Kodak", 5)) {
-            if (!exif) {
-                // old Kodak cameras may have exif tags in IFD0, reparse and create an exif subdir
-                fseek (f, rml->exifBase + ifdOffset, SEEK_SET);
-                TagDirectory* exifdir =  new TagDirectory (nullptr, f, rml->exifBase, exifAttribs, order, true);
-
-                exif = new Tag (root, root->getAttrib ("Exif"));
-                exif->initSubDir (exifdir);
-                root->addTagFront (exif);
-
-                if (exif && !exif->getDirectory()->getTag ("ISOSpeedRatings") && exif->getDirectory()->getTag ("ExposureIndex")) {
-                    Tag* niso = new Tag (exif->getDirectory(), exif->getDirectory()->getAttrib ("ISOSpeedRatings"));
-                    niso->initInt (exif->getDirectory()->getTag ("ExposureIndex")->toInt(), SHORT);
-                    exif->getDirectory()->addTagFront (niso);
-                }
-            }
-
-            Tag *kodakIFD = root->getTag ("KodakIFD");
-
-            if (kodakIFD && kodakIFD->getDirectory()->getTag ("TextualInfo")) {
-                parseKodakIfdTextualInfo (kodakIFD->getDirectory()->getTag ("TextualInfo"), exif);
-            }
-        }
-
-        parse_leafdata (root, order);
-
-        if (make && !strncmp ((char*)make->getValue(), "Hasselblad", 10)) {
-            /*
-            Figuring out the Hasselblad model is a mess. Hasselblad raw data comes in four slightly
-            different containers, 3FR (directly from CF card), FFF (same as 3FR but filtered through
-            Phocus, calibration data applied and a bit different tags), Adobe-generated DNGs and
-            Phocus-generated DNGs.
-
-            FFF usually has a sane model name in Model (and is used as reference for what we shall
-            call the different Hasselblad models), but 3FR only says like "Hasselblad H3D" for
-            all H3D models, or "Flash Sync" if the back has been used on a mechanical camera body.
-            V-mount backs may have the model name of the V body instead of the back model. Etc...
-            as said it's a mess.
-
-            This code is supposed to handle all raw containers and end up with the same model
-            regardless of container.
-
-            We don't differ between single shot and multi-shot models, and probably there's no use
-            of doing so. You need Hasselblad's own software to shoot multi-shot and can only do that
-            tethered. In single-shot mode they should be exactly the same as the single-shot models.
-                  */
-            Tag *subd = root->getTag (0x14a);
-            Tag *iw = (subd) ? subd->getDirectory()->getTag ("ImageWidth") : nullptr;
-            int sensorWidth = (iw) ? iw->toInt() : 0;
-            Tag* tmodel = root->getTag ("Model");
-            const char *model = (tmodel) ? (const char *)tmodel->getValue() : "";
-
-            if (strstr (model, "Hasselblad ") == model) {
-                model += 11;
-            } else {
-                // if HxD is used in flash sync mode for example, we need to fetch model from this tag
-                Tag* tmodel3 = root->getTag ("UniqueCameraModel");
-                const char *model3 = (tmodel3) ? (const char *)tmodel3->getValue() : "";
-
-                if (strstr (model3, "Hasselblad ") == model3) {
-                    model = model3 + 11;
-                }
-            }
-
-            // FIXME: due to lack of test files this Hasselblad model identification is not 100% complete
-            // This needs checking out: CFV-39/CFV-50 3FR, H3DII vs H3D, old CF/CFH models
-
-            if (!strcmp (model, "H3D")) {
-                // We can't differ between H3D and H3DII for the 22, 31 and 39 models. There's was no H3D-50 so we know that is a
-                // H3DII-50. At the time of writing I have no test files for the H3D vs H3DII models, so there still may be a chance
-                // to differ between them. AFAIK Adobe's DNG converter don't differ between them, and actually call the H3DII-50
-                // H3D-50 although Hasselblad never released such a model.
-                switch (sensorWidth) {
-                    case 4096:
-                        tmodel->initString ("H3D-22");
-                        break;
-
-                    case 6542:
-                        tmodel->initString ("H3D-31");
-                        break;
-
-                    case 7262:
-                        tmodel->initString ("H3D-39");
-                        break;
-
-                    case 8282:
-                        tmodel->initString ("H3DII-50");
-                        break;
-                }
-            } else if (!strcmp (model, "H4D")) {
-                switch (sensorWidth) {
-                    case 6542:
-                        tmodel->initString ("H4D-31");
-                        break;
-
-                    case 7410:
-                        tmodel->initString ("H4D-40");
-                        break;
-
-                    case 8282:
-                        tmodel->initString ("H4D-50");
-                        break;
-
-                    case 9044:
-                        tmodel->initString ("H4D-60");
-                        break;
-                }
-            } else if (!strcmp (model, "H5D")) {
-                switch (sensorWidth) {
-                    case 7410:
-                        tmodel->initString ("H5D-40");
-                        break;
-
-                    case 8282:
-                        tmodel->initString ("H5D-50");
-                        break;
-
-                    case 8374:
-                        tmodel->initString ("H5D-50c");
-                        break;
-
-                    case 9044:
-                        tmodel->initString ("H5D-60");
-                        break;
-                }
-            } else if (!strcmp (model, "CFV")) {
-                switch (sensorWidth) {
-                    case 7262:
-                        tmodel->initString ("CFV-39");
-                        break;
-
-                    case 8282:
-                        tmodel->initString ("CFV-50");
-                        break;
-
-                    case 8374:
-                        tmodel->initString ("CFV-50c");
-                        break;
-                }
-            }
-
-            // and a few special cases
-            Tag* tmodel3 = root->getTag ("UniqueCameraModel");
-            const char *model3 = (tmodel3) ? (const char *)tmodel3->getValue() : "";
-
-            if (strstr (model3, "Hasselblad ") == model3) {
-                model3 = model3 + 11;
-            }
-
-            if (!strcmp (model3, "ixpressCF132")) {
-                tmodel->initString ("CF-22");
-            } else if (!strcmp (model3, "Hasselblad96")) {
-                tmodel->initString ("CFV"); // popularly called CFV-16, but the official name is CFV
-            } else if (!strcmp (model3, "Hasselblad234")) {
-                tmodel->initString ("CFV-39");
-            } else if (sensorWidth == 4090) {
-                tmodel->initString ("V96C");
-            }
-
-            // and yet some, this is for Adobe-generated DNG files
-            Tag* tmodel4 = root->getTag ("LocalizedCameraModel");
-
-            if (tmodel4) {
-                const char *model4 = (const char *)tmodel4->getValue();
-
-                if (strstr (model4, "Hasselblad ") == model4) {
-                    model4 = model4 + 11;
-                }
-
-                if (!strcmp (model4, "ixpressCF132-22")) {
-                    tmodel->initString ("CF-22");
-                } else if (!strcmp (model4, "Hasselblad96-16")) {
-                    tmodel->initString ("CFV");
-                } else if (!strcmp (model4, "Hasselblad234-39")) {
-                    tmodel->initString ("CFV-39");
-                } else if (!strcmp (model4, "H3D-50")) {
-                    // Adobe names H3DII-50 incorrectly as H3D-50
-                    tmodel->initString ("H3DII-50");
-                } else if (strstr (model4, "H3D-") == model4 || strstr (model4, "H4D-") == model4 || strstr (model4, "H5D-") == model4) {
-                    tmodel->initString (model4);
-                }
-            }
-        }
-
-        if (!root->getTag ("Orientation")) {
-            if (make && !strncmp ((char*)make->getValue(), "Phase One", 9)) {
-                int orientation = 0;
-                Tag *iw = root->getTag ("ImageWidth");
-
-                if (iw) {
-                    // from dcraw, derive orientation from image width
-                    orientation = "0653"[iw->toInt() & 3] - '0';
-                }
-
-                Tag *t = new Tag (root, root->getAttrib ("Orientation"));
-                t->initInt (orientation, SHORT);
-                root->addTagFront (t);
-            }
-        }
-
-        if (!root->getTag ("Rating")) {
-            Tag *t = new Tag (root, root->getAttrib("Rating"));
-            t->initInt (0, LONG);
-            root->addTag (t);
-        }
-
-        // --- detecting image root IFD based on SubFileType, or if not provided, on PhotometricInterpretation
-
-        bool frameRootDetected = false;
-
-        for (auto ris : root->findTags("RawImageSegmentation")) {
-            frames.push_back(ris->getParent());
-            frameRootDetected = true;
-
-#if PRINT_METADATA_TREE
-            printf("\n--------------- FRAME (RAWIMAGESEGMENTATION) ---------------\n\n");
-            ris->getParent()->printAll ();
-#endif
-        }
-
-        if(!frameRootDetected) {
-            std::vector<const Tag*> sftTagList = root->findTags(TIFFTAG_SUBFILETYPE);
-            if (!sftTagList.empty()) {
-                for (auto sft : sftTagList) {
-                    int sftVal = sft->toInt();
-                    if (sftVal == 0 || (!isRaw && sftVal == 2)) {
-                        frames.push_back(sft->getParent());
-                        frameRootDetected = true;
-
-#if PRINT_METADATA_TREE
-                        printf("\n--------------- FRAME (SUBFILETYPE) ---------------\n\n");
-                        sft->getParent()->printAll ();
-#endif
-                    }
-                }
-            }
-        }
-
-        if(!frameRootDetected) {
-            std::vector<const Tag*> sftTagList = root->findTags(TIFFTAG_OSUBFILETYPE);
-            if (!sftTagList.empty()) {
-                for (auto sft : sftTagList) {
-                    int sftVal = sft->toInt();
-                    if (sftVal == OFILETYPE_IMAGE) {
-                        frames.push_back(sft->getParent());
-                        frameRootDetected = true;
-
-#if PRINT_METADATA_TREE
-                        printf("\n--------------- FRAME (OSUBFILETYPE) ---------------\n\n");
-                        sft->getParent()->printAll ();
-#endif
-                    }
-                }
-            }
-        }
-
-        if(!frameRootDetected) {
-            std::vector<const Tag*> piTagList = root->findTags("PhotometricInterpretation");
-            if (!piTagList.empty()) {
-                for (auto pi : piTagList) {
-                    int piVal = pi->toInt();
-                    if (piVal == (isRaw ? 32803 : 2)) {
-                        frames.push_back(pi->getParent());
-                        //frameRootDetected = true;  not used afterward
-
-#if PRINT_METADATA_TREE
-                        printf("\n--------------- FRAME (PHOTOMETRIC) ---------------\n\n");
-                        pi->getParent()->printAll ();
-#endif
-                    }
-                }
-            }
-        }
-
-        // --- getting next sibling root
-
-        ifdOffset = get4 (f, order);
-
-        roots.push_back(root);
-
-#if PRINT_METADATA_TREE
-        printf("\n~~~~~~~~~ ROOT ~~~~~~~~~~~~~~~~~~~~~~~~\n\n");
-        root->printAll ();
-#endif
-
-    } while (ifdOffset > 0 && !onlyFirst);
-
-    // Security check : if there's at least one root, there must be at least one image.
-    // If the following occurs, then image detection above has failed or it's an unsupported file type.
-    // Yet the result of this should be valid.
-    if (!roots.empty() && frames.empty()) {
-        frames.push_back(roots.at(0));
-    }
-}
-
-void ExifManager::parseJPEG (int offset)
-{
-    if (!f) {
-        #ifndef NDEBUG
-        std::cerr << "ERROR : no file opened !" << std::endl;
-        #endif
-        return;
-    }
-
-    if(!fseek (f, offset, SEEK_SET)) {
-        unsigned char c;
-        if(fread (&c, 1, 1, f) == 1) {
-            constexpr unsigned char markerl = 0xff;
-            const char exifid[] = "Exif\0\0";
-            char idbuff[8];
-            int tiffbase = -1;
-
-            while (fread (&c, 1, 1, f)) {
-                if (c != markerl) {
-                    continue;
-                }
-
-                if (fread (&c, 1, 1, f) && c == 0xe1) { // APP1 marker found
-                    if (fread (idbuff, 1, 8, f) < 8) {
-                        return;
-                    }
-
-                    if (!memcmp (idbuff + 2, exifid, 6)) {  // Exif info found
-                        tiffbase = ftell (f);
-
-                        // We need a RawMetaDataLocation to put the 'tiffbase' value
-                        const bool rmlCreated = !rml;
-                        if (rmlCreated) {
-                            rml.reset(new rtengine::RawMetaDataLocation(0));
-                        }
-                        rml->exifBase = tiffbase;
-                        parse (false, true, false);
-                        if (rmlCreated) {
-                            rml.reset();
-                        }
-                        return;
-                    }
-                }
-            }
-        }
-    }
-}
-
-void ExifManager::parseTIFF (bool skipIgnored)
-{
-    if (!rml) {
-        rml.reset(new rtengine::RawMetaDataLocation(0));
-        parse(false, skipIgnored);
-        rml.reset();
-    } else {
-        parse (false,skipIgnored);
-    }
-}
-
-std::vector<Tag*> ExifManager::getDefaultTIFFTags (TagDirectory* forthis)
-{
-
-    std::vector<Tag*> defTags;
-
-    defTags.reserve (12);
-    defTags.push_back (new Tag (forthis, lookupAttrib (ifdAttribs, "ImageWidth"), 0, LONG));
-    defTags.push_back (new Tag (forthis, lookupAttrib (ifdAttribs, "ImageHeight"), 0, LONG));
-    defTags.push_back (new Tag (forthis, lookupAttrib (ifdAttribs, "XResolution"), 300, RATIONAL));
-    defTags.push_back (new Tag (forthis, lookupAttrib (ifdAttribs, "YResolution"), 300, RATIONAL));
-    defTags.push_back (new Tag (forthis, lookupAttrib (ifdAttribs, "ResolutionUnit"), 2, SHORT));
-    defTags.push_back (new Tag (forthis, lookupAttrib (ifdAttribs, "Software"), "RawTherapee " RTVERSION));
-    defTags.push_back (new Tag (forthis, lookupAttrib (ifdAttribs, "Orientation"), 1, SHORT));
-    defTags.push_back (new Tag (forthis, lookupAttrib (ifdAttribs, "SamplesPerPixel"), 3, SHORT));
-    defTags.push_back (new Tag (forthis, lookupAttrib (ifdAttribs, "BitsPerSample"), 8, SHORT));
-    defTags.push_back (new Tag (forthis, lookupAttrib (ifdAttribs, "PlanarConfiguration"), 1, SHORT));
-    defTags.push_back (new Tag (forthis, lookupAttrib (ifdAttribs, "PhotometricInterpretation"), 2, SHORT));
-    defTags.push_back (new Tag (forthis, lookupAttrib (ifdAttribs, "Compression"), 1, SHORT));
-
-    return defTags;
-}
-
-
-
-int ExifManager::createJPEGMarker (const TagDirectory* root, const rtengine::procparams::ExifPairs& changeList, int W, int H, unsigned char* buffer)
-{
-
-    // write tiff header
-    int offs = 6;
-    memcpy (buffer, "Exif\0\0", 6);
-    ByteOrder order = INTEL;
-
-    if (root) {
-        order = root->getOrder ();
-    }
-
-    sset2 ((unsigned short)order, buffer + offs, order);
-    offs += 2;
-    sset2 (42, buffer + offs, order);
-    offs += 2;
-    sset4 (8, buffer + offs, order);
-
-    TagDirectory* cl;
-
-    if (root) {
-        cl = root->clone(nullptr);
-
-        // Drop unwanted tags before exporting
-        // For example, Nikon Z-series has a 52Kb MakerNotes->ShotInfo tag
-        // which does not fit into the 65Kb limit on JPEG exif tags
-        const Tag* const make_tag = cl->getTag(271);
-        if (make_tag && !std::strncmp((const char*)make_tag->getValue(), "NIKON CORPORATION", 17)) {
-            [cl]()
-            {
-                Tag* const exif_tag = cl->getTag(34665);
-                if (!exif_tag) {
-                    return;
-                }
-
-                TagDirectory* const exif_dir = exif_tag->getDirectory();
-                if (!exif_dir) {
-                    return;
-                }
-
-                Tag* const make_notes_tag = exif_dir->getTag(37500);
-                if (!make_notes_tag) {
-                    return;
-                }
-
-                TagDirectory* const maker_notes_dir = make_notes_tag->getDirectory();
-                if (!maker_notes_dir) {
-                    return;
-                }
-
-                Tag* const shot_info_tag = maker_notes_dir->getTag(145);
-                if (!shot_info_tag) {
-                    return;
-                }
-
-                shot_info_tag->setKeep(false);
-            }();
-        }
-    } else {
-        cl = new TagDirectory (nullptr, ifdAttribs, INTEL);
-    }
-
-    for (rtengine::procparams::ExifPairs::const_iterator i = changeList.begin(); i != changeList.end(); ++i) {
-        cl->applyChange (i->first, i->second);
-    }
-
-    const std::vector<Tag*> defTags = getDefaultTIFFTags (cl);
-
-    defTags[0]->setInt (W, 0, LONG);
-    defTags[1]->setInt (H, 0, LONG);
-    defTags[8]->setInt (8, 0, SHORT);
-
-    for (int i = defTags.size() - 1; i >= 0; i--) {
-        Tag* defTag = defTags[i];
-        cl->replaceTag (defTag->clone (cl));
-        delete defTag;
-    }
-
-    cl->sort ();
-    int size = cl->write (8, buffer + 6);
-
-    delete cl;
-
-    return size + 6;
-}
-
-int ExifManager::createPNGMarker(const TagDirectory* root, const rtengine::procparams::ExifPairs &changeList, int W, int H, int bps, const char* iptcdata, int iptclen, unsigned char *&buffer, unsigned &bufferSize)
-{
-// write tiff header
-    int offs = 0;
-    ByteOrder order = HOSTORDER;
-
-    if (root) {
-        order = root->getOrder ();
-    }
-
-    TagDirectory* cl;
-
-    if (root) {
-        cl = (const_cast<TagDirectory*> (root))->clone (nullptr);
-        // remove some unknown top level tags which produce warnings when opening a tiff
-        Tag *removeTag = cl->getTag (0x9003);
-
-        if (removeTag) {
-            removeTag->setKeep (false);
-        }
-
-        removeTag = cl->getTag (0x9211);
-
-        if (removeTag) {
-            removeTag->setKeep (false);
-        }
-    } else {
-        cl = new TagDirectory (nullptr, ifdAttribs, HOSTORDER);
-    }
-
-    if (iptcdata) {
-        Tag* iptc = new Tag (cl, lookupAttrib (ifdAttribs, "IPTCData"));
-        iptc->initLongArray (iptcdata, iptclen);
-        cl->replaceTag (iptc);
-    }
-
-// apply list of changes
-    for (rtengine::procparams::ExifPairs::const_iterator i = changeList.begin(); i != changeList.end(); ++i) {
-        cl->applyChange (i->first, i->second);
-    }
-
-    // append default properties
-    const std::vector<Tag*> defTags = getDefaultTIFFTags (cl);
-
-    defTags[0]->setInt (W, 0, LONG);
-    defTags[1]->setInt (H, 0, LONG);
-    defTags[8]->initInt (0, SHORT, 3);
-
-    for (int i = 0; i < 3; i++) {
-        defTags[8]->setInt (bps, i * 2, SHORT);
-    }
-
-    for (int i = defTags.size() - 1; i >= 0; i--) {
-        Tag* defTag = defTags[i];
-        cl->replaceTag (defTag->clone (cl));
-        delete defTag;
-    }
-
-    cl->sort ();
-    bufferSize = cl->calculateSize() + 8;
-    buffer = new unsigned char[bufferSize]; // this has to be deleted in caller
-    sset2 ((unsigned short)order, buffer + offs, order);
-    offs += 2;
-    sset2 (42, buffer + offs, order);
-    offs += 2;
-    sset4 (8, buffer + offs, order);
-
-    int endOffs = cl->write (8, buffer);
-
-//  cl->printAll();
-    delete cl;
-
-    return endOffs;
-}
-
-
-//-----------------------------------------------------------------------------
-// global functions to read byteorder dependent data
-//-----------------------------------------------------------------------------
-unsigned short sget2 (unsigned char *s, rtexif::ByteOrder order)
-{
-
-    if (order == rtexif::INTEL) {
-        return s[0] | s[1] << 8;
-    } else {
-        return s[0] << 8 | s[1];
-    }
-}
-
-int sget4 (unsigned char *s, rtexif::ByteOrder order)
-{
-
-    if (order == rtexif::INTEL) {
-        return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;
-    } else {
-        return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];
-    }
-}
-
-inline unsigned short get2 (FILE* f, rtexif::ByteOrder order)
-{
-
-    unsigned char str[2] = { 0xff, 0xff };
-    fread (str, 1, 2, f);
-    return rtexif::sget2 (str, order);
-}
-
-int get4 (FILE* f, rtexif::ByteOrder order)
-{
-
-    unsigned char str[4] = { 0xff, 0xff, 0xff, 0xff };
-    fread (str, 1, 4, f);
-    return rtexif::sget4 (str, order);
-}
-
-void sset2 (unsigned short v, unsigned char *s, rtexif::ByteOrder order)
-{
-
-    if (order == rtexif::INTEL) {
-        s[0] = v & 0xff;
-        v >>= 8;
-        s[1] = v;
-    } else {
-        s[1] = v & 0xff;
-        v >>= 8;
-        s[0] = v;
-    }
-}
-
-void sset4 (int v, unsigned char *s, rtexif::ByteOrder order)
-{
-
-    if (order == rtexif::INTEL) {
-        s[0] = v & 0xff;
-        v >>= 8;
-        s[1] = v & 0xff;
-        v >>= 8;
-        s[2] = v & 0xff;
-        v >>= 8;
-        s[3] = v;
-    } else {
-        s[3] = v & 0xff;
-        v >>= 8;
-        s[2] = v & 0xff;
-        v >>= 8;
-        s[1] = v & 0xff;
-        v >>= 8;
-        s[0] = v;
-    }
-}
-
-float int_to_float (int i)
-{
-    union {
-        int i;
-        float f;
-    } u;
-    u.i = i;
-    return u.f;
-}
-
-short int int2_to_signed (short unsigned int i)
-{
-    union {
-        short unsigned int i;
-        short int s;
-    } u;
-    u.i = i;
-    return u.s;
-}
-
-/* Function to parse and extract focal length and aperture information from description
- * @fullname must conform to the following formats
- * <focal>mm f/<aperture>
- * <focal>-<focal>mm f/<aperture>
- * <focal>-<focal>mm f/<aperture>-<aperture>
- * NB: no space between separator '-'; no space between focal length and 'mm'
- */
-bool extractLensInfo (const std::string &fullname, double &minFocal, double &maxFocal, double &maxApertureAtMinFocal, double &maxApertureAtMaxFocal)
-{
-    minFocal = 0.0;
-    maxFocal = 0.0;
-    maxApertureAtMinFocal = 0.0;
-    maxApertureAtMaxFocal = 0.0;
-    char buffer[1025];
-    strncpy (buffer, fullname.c_str(), 1024);
-    char *pF = strstr (buffer, "f/" );
-
-    if ( pF ) {
-        sscanf (pF + 2, "%lf-%lf", &maxApertureAtMinFocal, &maxApertureAtMaxFocal);
-
-        if (maxApertureAtMinFocal > 0. && maxApertureAtMaxFocal == 0.) {
-            maxApertureAtMaxFocal = maxApertureAtMinFocal;
-        }
-
-        char *pMM = pF - 3;
-
-        while ( pMM[0] != 'm' && pMM[1] != 'm' && pMM > buffer) {
-            pMM--;
-        }
-
-        if ( pMM[0] == 'm' && pMM[1] == 'm' ) {
-            char *sp = pMM;
-
-            while ( *sp != ' ' && sp > buffer ) {
-                sp--;
-            }
-
-            sscanf (sp + 1, "%lf-%lf", &minFocal, &maxFocal);
-
-            if (maxFocal == 0.) {
-                maxFocal = minFocal;
-            }
-
-            return true;
-        }
-    }
-
-    return false;
-}
-
-}
diff --git a/rtexif/rtexif.h b/rtexif/rtexif.h
deleted file mode 100644
index 7b2f8ad23..000000000
--- a/rtexif/rtexif.h
+++ /dev/null
@@ -1,706 +0,0 @@
-/*
- *  This file is part of RawTherapee.
- *
- *  Copyright (c) 2004-2010 Gabor Horvath <hgabor@rawtherapee.com>
- *
- *  RawTherapee is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  RawTherapee is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
- */
-#pragma once
-
-#include <cmath>
-#include <cstdint>
-#include <cstdio>
-#include <cstdlib>
-#include <iomanip>
-#include <map>
-#include <memory>
-#include <sstream>
-#include <string>
-#include <vector>
-
-#include <glibmm/ustring.h>
-
-#include "../rtengine/noncopyable.h"
-#include "../rtengine/rawmetadatalocation.h"
-
-namespace Glib
-{
-    class KeyFile;
-}
-namespace rtengine
-{
-
-namespace procparams
-{
-    class ExifPairs;
-}
-
-}
-
-class CacheImageData;
-
-namespace rtexif
-{
-
-enum TagType {INVALID = 0, BYTE = 1, ASCII = 2, SHORT = 3, LONG = 4, RATIONAL = 5, SBYTE = 6, UNDEFINED = 7, SSHORT = 8, SLONG = 9, SRATIONAL = 10, FLOAT = 11, DOUBLE = 12, OLYUNDEF = 13, AUTO = 98, SUBDIR = 99};
-enum ActionCode {
-    AC_DONTWRITE,  // don't write it to the output
-    AC_WRITE,      // write it to the output
-    AC_SYSTEM,     // changed by RT (not editable/deletable) - don't write, don't show
-    AC_NEW,        // new addition - write, don't show
-
-    AC_INVALID = 100,  // invalid state
-};
-enum ByteOrder {UNKNOWN = 0, INTEL = 0x4949, MOTOROLA = 0x4D4D};
-#if __BYTE_ORDER__==__ORDER_LITTLE_ENDIAN__
-const ByteOrder HOSTORDER = INTEL;
-#else
-const enum ByteOrder HOSTORDER = MOTOROLA;
-#endif
-enum MNKind {NOMK, IFD, HEADERIFD, NIKON3, OLYMPUS2, FUJI, TABLESUBDIR};
-
-bool extractLensInfo (const std::string &fullname, double &minFocal, double &maxFocal, double &maxApertureAtMinFocal, double &maxApertureAtMaxFocal);
-
-unsigned short sget2 (unsigned char *s, ByteOrder order);
-int sget4 (unsigned char *s, ByteOrder order);
-unsigned short get2 (FILE* f, ByteOrder order);
-int get4 (FILE* f, ByteOrder order);
-void sset2 (unsigned short v, unsigned char *s, ByteOrder order);
-void sset4 (int v, unsigned char *s, ByteOrder order);
-float int_to_float (int i);
-short int int2_to_signed (short unsigned int i);
-
-struct TIFFHeader {
-
-    unsigned short byteOrder;
-    unsigned short fixed;
-    unsigned int   ifdOffset;
-};
-
-class Tag;
-class Interpreter;
-
-/// Structure of information describing an Exif tag
-struct TagAttrib {
-    int                 ignore;   // =0: never ignore, =1: always ignore, =2: ignore if the subdir type is reduced image, =-1: end of table
-    ActionCode          action;
-    int                 editable;
-    const  TagAttrib*   subdirAttribs;  // !NULL if this tag points to a subdir
-    /**  Numeric identifier of tag (or index inside DirectoryTable)
-         To avoid rewriting all the tables, and to address the problem of TagDirectoryTable with heterogeneous tag's type,
-         this parameter is now an unsigned int, where the leftmost 2 bytes represent the tag's type, which by default will be aqual
-         to 0 (INVALID). Only non null tag type will be used. See nikon attrib for an example
-    */
-    unsigned short      ID;
-    TagType             type;
-    const char*         name;
-    Interpreter*        interpreter; // Call back hook
-};
-
-const TagAttrib* lookupAttrib (const TagAttrib* dir, const char* field);
-
-/// A directory of tags
-class TagDirectory
-{
-
-protected:
-    std::vector<Tag*> tags;         // tags in the directory
-    const TagAttrib*  attribs;      // descriptor table to decode the tags
-    ByteOrder         order;        // byte order
-    TagDirectory*     parent;       // parent directory (NULL if root)
-    bool              parseJPEG;
-    static Glib::ustring getDumpKey (int tagID, const Glib::ustring &tagName);
-
-public:
-    TagDirectory ();
-    TagDirectory (TagDirectory* p, FILE* f, int base, const TagAttrib* ta, ByteOrder border, bool skipIgnored = true, bool parseJpeg = true);
-    TagDirectory (TagDirectory* p, const TagAttrib* ta, ByteOrder border);
-    virtual ~TagDirectory ();
-
-    inline ByteOrder getOrder      () const
-    {
-        return order;
-    }
-    TagDirectory*    getParent     ()
-    {
-        return parent;
-    }
-    inline bool getParseJpeg() const
-    {
-        return parseJPEG;
-    }
-    TagDirectory*    getRoot       ();
-    inline int       getCount      () const
-    {
-        return tags.size ();
-    }
-    const TagAttrib* getAttrib     (int id) const;
-    // Find a Tag by scanning the whole tag tree and stopping at the first occurrence
-    const TagAttrib* getAttrib     (const char* name);
-    // Try to get the Tag at a given location. 'name' is a path relative to this directory (e.g. "LensInfo/FocalLength")
-    const TagAttrib* getAttribP    (const char* name);
-    const TagAttrib* getAttribTable() const
-    {
-        return attribs;
-    }
-    // Find a Tag by scanning the whole tag tree and stopping at the first occurrence
-    Tag*             getTag        (const char* name) const;
-    // Try to get the Tag at a given location. 'name' is a path relative to this directory (e.g. "LensInfo/FocalLength")
-    Tag*             getTagP       (const char* name) const;
-    Tag*             getTag        (int ID) const;
-
-    // Try to get the Tag in the current directory and in subdirectories
-    // if lookUpward = true, it will scan the parents TagDirectory up to the root one,
-    // but w/o looking into their subdirs
-    Tag*     findTag       (const char* name, bool lookUpward = false) const;
-    // Find a all Tags with the given name by scanning the whole tag tree
-    std::vector<const Tag*> findTags (const char* name);
-    // Find a all Tags with the given ID by scanning the whole tag tree
-    std::vector<const Tag*> findTags (int ID);
-    // Try to get the Tag in the current directory and in parent directories
-    // (won't look into subdirs)
-    Tag*     findTagUpward (const char* name) const;
-    bool             getXMPTagValue (const char* name, char* value) const;
-
-    void        keepTag       (int ID);
-    void        addTag        (Tag* &a);
-    void        addTagFront   (Tag* &a);
-    void        replaceTag    (Tag* a);
-    inline Tag* getTagByIndex (int ix)
-    {
-        return tags[ix];
-    }
-    inline void      setOrder      (ByteOrder bo)
-    {
-        order = bo;
-    }
-
-    virtual int      calculateSize ();
-    virtual int      write         (int start, unsigned char* buffer);
-    virtual TagDirectory* clone    (TagDirectory* parent) const;
-    void     applyChange   (const std::string &field, const Glib::ustring &value);
-
-    void     printAll      (unsigned  int level = 0) const; // reentrant debug function, keep level=0 on first call !
-    bool     CPBDump       (const Glib::ustring &commFName, const Glib::ustring &imageFName, const Glib::ustring &profileFName, const Glib::ustring &defaultPParams,
-                                    const CacheImageData* cfs, const bool flagMode, Glib::KeyFile *keyFile = nullptr, Glib::ustring tagDirName = "") const;
-    void     sort     ();
-};
-
-// a table of tags: id are offset from beginning and not identifiers
-class TagDirectoryTable: public TagDirectory, public rtengine::NonCopyable
-{
-protected:
-    unsigned char *values; // Tags values are saved internally here
-    long           zeroOffset; // Offset 0 (index 0) could be at an offset from values
-    long           valuesSize; // Size of allocated memory
-    TagType        defaultType; // Default type of all tags in this directory
-public:
-    TagDirectoryTable();
-    TagDirectoryTable (TagDirectory* p, unsigned char *v, int memsize, int offs, TagType type, const TagAttrib* ta, ByteOrder border);
-    TagDirectoryTable (TagDirectory* p, FILE* f, int memsize, int offset, TagType type, const TagAttrib* ta, ByteOrder border);
-    ~TagDirectoryTable() override;
-    int calculateSize () override;
-    int write (int start, unsigned char* buffer) override;
-    TagDirectory* clone (TagDirectory* parent) const override;
-};
-
-// a class representing a single tag
-class Tag :
-    public rtengine::NonCopyable
-{
-
-protected:
-    unsigned short tag;
-    TagType        type;
-    unsigned int   count;
-    unsigned char* value;
-    int            valuesize;
-    bool           keep;
-    bool           allocOwnMemory;
-
-    const TagAttrib* attrib;
-    TagDirectory*    parent;
-    TagDirectory**   directory;
-    MNKind           makerNoteKind;
-    bool             parseMakerNote (FILE* f, int base, ByteOrder bom );
-
-public:
-    Tag (TagDirectory* parent, FILE* f, int base);                          // parse next tag from the file
-    Tag (TagDirectory* parent, const TagAttrib* attr);
-    Tag (TagDirectory* parent, const TagAttrib* attr, unsigned char *data, TagType t);
-    Tag (TagDirectory* parent, const TagAttrib* attr, int data, TagType t);  // create a new tag from array (used
-    Tag (TagDirectory* parent, const TagAttrib* attr, const char* data);  // create a new tag from array (used
-
-    ~Tag ();
-    void initType        (unsigned char *data, TagType type);
-    void initInt         (int data, TagType t, int count = 1);
-    void initUserComment (const Glib::ustring &text);
-    void initString      (const char* text);
-    void initSubDir      ();
-    void initSubDir      (TagDirectory* dir);
-    void initMakerNote   (MNKind mnk, const TagAttrib* ta);
-    void initUndefArray  (const char* data, int len);
-    void initLongArray   (const char* data, int len);
-    void initRational    (int num, int den);
-
-    static void swapByteOrder2 (unsigned char *buffer, int count);
-
-    // get basic tag properties
-    int                  getID          () const
-    {
-        return tag;
-    }
-    int                  getCount       () const
-    {
-        return count;
-    }
-    TagType              getType        () const
-    {
-        return (attrib && attrib->type > INVALID && attrib->type < AUTO) ? attrib->type : type;
-    }
-    unsigned char*       getValue       () const
-    {
-        return value;
-    }
-    signed char*         getSignedValue () const
-    {
-        return reinterpret_cast<signed char*> (value);
-    }
-    const TagAttrib*     getAttrib      () const
-    {
-        return attrib;
-    }
-    inline ByteOrder     getOrder       () const
-    {
-        return parent ? parent->getOrder() : HOSTORDER;
-    }
-    inline TagDirectory* getParent      () const
-    {
-        return parent;
-    }
-    int                  getValueSize   () const
-    {
-        return valuesize;
-    }
-    bool                 getOwnMemory   () const
-    {
-        return allocOwnMemory;
-    }
-
-    // read/write value
-    int     toInt           (int ofs = 0, TagType astype = INVALID) const;
-    void    fromInt         (int v);
-    double  toDouble        (int ofs = 0) const;
-    double* toDoubleArray   (int ofs = 0) const;
-    void    toRational      (int& num, int& denom, int ofs = 0) const;
-    void    toString        (char* buffer, std::size_t size, int ofs = 0) const;
-    void    fromString      (const char* v, int size = -1);
-    void    setInt          (int v, int ofs = 0, TagType astype = LONG);
-    int     getDistanceFrom (const TagDirectory *root);
-
-    // additional getter/setter for more comfortable use
-    std::string valueToString         () const;
-    std::string nameToString          (int i = 0);
-    void        valueFromString       (const std::string& value);
-    void        userCommentFromString (const Glib::ustring& text);
-
-    // functions for writing
-    int  calculateSize ();
-    int  write         (int offs, int dataOffs, unsigned char* buffer);
-    Tag* clone         (TagDirectory* parent) const;
-
-    // to control if the tag shall be written
-    bool getKeep () const
-    {
-        return keep;
-    }
-    void setKeep (bool k)
-    {
-        keep = k;
-    }
-
-    // get subdirectory (there can be several, the last is NULL)
-    bool isDirectory () const
-    {
-        return directory != nullptr;
-    }
-    TagDirectory*  getDirectory (int i = 0)
-    {
-        return (directory) ? directory[i] : nullptr;
-    }
-
-    MNKind getMakerNoteFormat () const
-    {
-        return makerNoteKind;
-    }
-};
-
-class ExifManager
-{
-
-    Tag* saveCIFFMNTag (TagDirectory* root, int len, const char* name);
-    void parseCIFF (int length, TagDirectory* root);
-    void parse (bool isRaw, bool skipIgnored = true, bool parseJpeg = true);
-
-public:
-    FILE* f;
-    std::unique_ptr<rtengine::RawMetaDataLocation> rml;
-    ByteOrder order;
-    bool onlyFirst;  // Only first IFD
-    unsigned int IFDOffset;
-    std::vector<TagDirectory*> roots;
-    std::vector<TagDirectory*> frames;
-
-    ExifManager (FILE* fHandle, std::unique_ptr<rtengine::RawMetaDataLocation> _rml, bool onlyFirstIFD)
-        : f(fHandle), rml(std::move(_rml)), order(UNKNOWN), onlyFirst(onlyFirstIFD),
-          IFDOffset(0) {}
-
-    void setIFDOffset(unsigned int offset);
-
-
-    void parseRaw (bool skipIgnored = true);
-    void parseStd (bool skipIgnored = true);
-    void parseJPEG (int offset = 0); // offset: to extract exif data from a embedded preview/thumbnail
-    void parseTIFF (bool skipIgnored = true);
-    void parseCIFF ();
-
-    /// @brief Get default tag for TIFF
-    /// @param forthis The byte order will be taken from the given directory.
-    /// @return The ownership of the return tags is passed to the caller.
-    static std::vector<Tag*> getDefaultTIFFTags (TagDirectory* forthis);
-    static int    createJPEGMarker (const TagDirectory* root, const rtengine::procparams::ExifPairs& changeList, int W, int H, unsigned char* buffer);
-    static int    createTIFFHeader (const TagDirectory* root, const rtengine::procparams::ExifPairs& changeList, int W, int H, int bps, const char* profiledata, int profilelen, const char* iptcdata, int iptclen, unsigned char *&buffer, unsigned &bufferSize);
-    static int createPNGMarker(const TagDirectory *root, const rtengine::procparams::ExifPairs &changeList, int W, int H, int bps, const char *iptcdata, int iptclen, unsigned char *&buffer, unsigned &bufferSize);
-};
-
-class Interpreter
-{
-public:
-    Interpreter () {}
-    virtual ~Interpreter() {};
-    virtual std::string toString (const Tag* t) const
-    {
-        char buffer[1024];
-        t->toString (buffer, sizeof(buffer));
-        std::string s (buffer);
-        std::string::size_type p1 = s.find_first_not_of (' ');
-
-        if ( p1 == std::string::npos ) {
-            return s;
-        } else {
-            return s.substr (p1, s.find_last_not_of (' ') - p1 + 1);
-        }
-    }
-    virtual void fromString (Tag* t, const std::string& value)
-    {
-        if (t->getType() == SHORT || t->getType() == LONG) {
-            t->fromInt (atoi (value.c_str()));
-        } else {
-            t->fromString (value.c_str());
-        }
-    }
-    // Get the value as a double
-    virtual double toDouble (const Tag* t, int ofs = 0)
-    {
-
-        switch (t->getType()) {
-            case SBYTE:
-                return double (int (t->getSignedValue()[ofs]));
-
-            case BYTE:
-                return (double) ((int)t->getValue()[ofs]);
-
-            case ASCII:
-                return 0.0;
-
-            case SSHORT:
-                return (double)int2_to_signed (sget2 (t->getValue() + ofs, t->getOrder()));
-
-            case SHORT:
-                return (double) ((int)sget2 (t->getValue() + ofs, t->getOrder()));
-
-            case SLONG:
-            case LONG:
-                return (double) ((int)sget4 (t->getValue() + ofs, t->getOrder()));
-
-            case SRATIONAL: {
-                const double dividend = (int)sget4 (t->getValue() + ofs, t->getOrder());
-                const double divisor = (int)sget4 (t->getValue() + ofs + 4, t->getOrder());
-                return divisor == 0. ? 0. : dividend / divisor;
-            }
-
-            case RATIONAL: {
-                const double dividend = (uint32_t)sget4 (t->getValue() + ofs, t->getOrder());
-                const double divisor = (uint32_t)sget4 (t->getValue() + ofs + 4, t->getOrder());
-                return divisor == 0. ? 0. : dividend / divisor;
-            }
-
-            case FLOAT:
-                return double (sget4 (t->getValue() + ofs, t->getOrder()));
-
-            case UNDEFINED:
-                return 0.;
-
-            default:
-                return 0.; // Quick fix for missing cases (INVALID, DOUBLE, OLYUNDEF, SUBDIR)
-        }
-    }
-    // Get the value as an int
-    virtual int toInt (const Tag* t, int ofs = 0, TagType astype = INVALID)
-    {
-        if (astype == INVALID || astype == AUTO) {
-            astype = t->getType();
-        }
-
-        switch (astype) {
-            case SBYTE:
-                return int (t->getSignedValue()[ofs]);
-
-            case BYTE:
-                return t->getValue()[ofs];
-
-            case ASCII:
-                return 0;
-
-            case SSHORT:
-                return (int)int2_to_signed (sget2 (t->getValue() + ofs, t->getOrder()));
-
-            case SHORT:
-                return (int)sget2 (t->getValue() + ofs, t->getOrder());
-
-            case SLONG:
-            case LONG:
-                return (int)sget4 (t->getValue() + ofs, t->getOrder());
-
-            case SRATIONAL: {
-                int a = (int)sget4 (t->getValue() + ofs + 4, t->getOrder());
-                return a == 0 ? 0 : (int)sget4 (t->getValue() + ofs, t->getOrder()) / a;
-            }
-
-            case RATIONAL: {
-                uint32_t a = (uint32_t)sget4 (t->getValue() + ofs + 4, t->getOrder());
-                return a == 0 ? 0 : (uint32_t)sget4 (t->getValue() + ofs, t->getOrder()) / a;
-            }
-
-            case FLOAT:
-                return (int)toDouble (t, ofs);
-
-            case UNDEFINED:
-                return 0;
-
-            default:
-                return 0; // Quick fix for missing cases (INVALID, DOUBLE, OLYUNDEF, SUBDIR)
-        }
-
-        return 0;
-    }
-};
-
-extern Interpreter stdInterpreter;
-
-template<typename T = std::uint32_t>
-class ChoiceInterpreter : public Interpreter
-{
-protected:
-    using Choices = std::map<T, std::string>;
-    using ChoicesIterator = typename Choices::const_iterator;
-    Choices choices;
-public:
-    ChoiceInterpreter () {};
-    std::string toString (const Tag* t) const override
-    {
-        const typename std::map<T, std::string>::const_iterator r = choices.find(t->toInt());
-
-        if (r != choices.end()) {
-            return r->second;
-        } else {
-            char buffer[1024];
-            t->toString(buffer, sizeof(buffer));
-            return buffer;
-        }
-    }
-};
-
-template< class T >
-class IntLensInterpreter : public Interpreter
-{
-protected:
-    typedef std::multimap< T, std::string> container_t;
-    typedef typename std::multimap< T, std::string>::const_iterator it_t;
-    typedef std::pair< T, std::string> p_t;
-    container_t choices;
-
-    virtual std::string guess (const T lensID, double focalLength, double maxApertureAtFocal, double *lensInfoArray) const
-    {
-        it_t r;
-        size_t nFound = choices.count ( lensID );
-
-        switch ( nFound ) {
-            case 0: { // lens Unknown
-                std::ostringstream s;
-                s << lensID;
-                return s.str();
-            }
-
-            case 1: // lens found
-                r = choices.find ( lensID );
-                return r->second;
-
-            default:
-                // More than one hit: we must guess
-                break;
-        }
-
-        std::string bestMatch ("Unknown");
-        double a1, a2, f1, f2;
-
-        /* FIRST TRY
-        *
-        * Get the lens info (min/man focal, min/max aperture) and compare them to the possible choice
-        */
-        if (lensInfoArray) {
-            for ( r = choices.lower_bound ( lensID ); r != choices.upper_bound (lensID); ++r  ) {
-                if ( !extractLensInfo ( r->second, f1, f2, a1, a2) ) {
-                    continue;
-                }
-
-                if (f1 == lensInfoArray[0] && f2 == lensInfoArray[1] && a1 == lensInfoArray[2] && a2 == lensInfoArray[3])
-                    // can't match better! we take this entry as being the one
-                {
-                    return r->second;
-                }
-            }
-
-            // No lens found, we update the "unknown" string with the lens info values
-            if (lensInfoArray[0] == lensInfoArray[1]) {
-                bestMatch += Glib::ustring::compose (" (%1mm", int (lensInfoArray[0]));
-            } else {
-                bestMatch += Glib::ustring::compose (" (%1-%2mm", int (lensInfoArray[0]), int (lensInfoArray[1]));
-            }
-
-            if (lensInfoArray[2] == lensInfoArray[3]) {
-                bestMatch += Glib::ustring::compose (" f/%1)", Glib::ustring::format (std::fixed, std::setprecision (1), lensInfoArray[2]));
-            } else
-                bestMatch += Glib::ustring::compose (" f/%1-%2)",
-                                                     Glib::ustring::format (std::fixed, std::setprecision (1), lensInfoArray[2]),
-                                                     Glib::ustring::format (std::fixed, std::setprecision (1), lensInfoArray[3]));
-        }
-
-        /* SECOND TRY
-        *
-        * Choose the best match: thanks to exiftool by Phil Harvey
-        * first throws for "out of focal range" and lower or upper aperture of the lens compared to MaxApertureAtFocal
-        * if the lens is not constant aperture, calculate aprox. aperture of the lens at focalLength
-        * and compare with actual aperture.
-        */
-        std::ostringstream candidates;
-        double deltaMin = 1000.;
-
-        for ( r = choices.lower_bound ( lensID ); r != choices.upper_bound (lensID); ++r  ) {
-            double dif;
-
-            if ( !extractLensInfo ( r->second, f1, f2, a1, a2) ) {
-                continue;
-            }
-
-            if ( f1 == 0. || a1 == 0.) {
-                continue;
-            }
-
-            if ( focalLength < f1 - .5 || focalLength > f2 + 0.5 ) {
-                continue;
-            }
-
-            if ( maxApertureAtFocal > 0.1) {
-                double lensAperture;
-
-                if ( maxApertureAtFocal < a1 - 0.15 || maxApertureAtFocal > a2 + 0.15) {
-                    continue;
-                }
-
-                if ( a1 == a2 || f1 == f2) {
-                    lensAperture = a1;
-                } else {
-                    lensAperture = exp ( log (a1) + (log (a2) - log (a1)) / (log (f2) - log (f1)) * (log (focalLength) - log (f1)) );
-                }
-
-                dif = std::abs (lensAperture - maxApertureAtFocal);
-            } else {
-                dif = 0;
-            }
-
-            if ( dif < deltaMin ) {
-                deltaMin = dif;
-                bestMatch = r->second;
-            }
-
-            if ( dif < 0.15) {
-                if ( candidates.tellp() ) {
-                    candidates << "\n or " <<  r->second;
-                } else {
-                    candidates <<  r->second;
-                }
-            }
-        }
-
-        if ( !candidates.tellp() ) {
-            return bestMatch;
-        } else {
-            return candidates.str();
-        }
-    }
-};
-
-inline static int getTypeSize ( TagType type )
-{
-    return ("11124811248484"[type < 14 ? type : 0] - '0');
-}
-
-extern const TagAttrib exifAttribs[];
-extern const TagAttrib gpsAttribs[];
-extern const TagAttrib iopAttribs[];
-extern const TagAttrib ifdAttribs[];
-extern const TagAttrib nikon2Attribs[];
-extern const TagAttrib nikon3Attribs[];
-extern const TagAttrib canonAttribs[];
-extern const TagAttrib pentaxAttribs[];
-extern const TagAttrib pentaxLensDataAttribs[];
-extern const TagAttrib pentaxLensInfoQAttribs[];
-extern const TagAttrib pentaxLensCorrAttribs[];
-extern const TagAttrib pentaxAEInfoAttribs[];
-extern const TagAttrib pentaxAEInfo2Attribs[];
-extern const TagAttrib pentaxAEInfo3Attribs[];
-extern const TagAttrib pentaxCameraSettingsAttribs[];
-extern const TagAttrib pentaxFlashInfoAttribs[];
-extern const TagAttrib pentaxSRInfoAttribs[];
-extern const TagAttrib pentaxSRInfo2Attribs[];
-extern const TagAttrib pentaxBatteryInfoAttribs[];
-extern const TagAttrib pentaxCameraInfoAttribs[];
-extern const TagAttrib fujiAttribs[];
-extern const TagAttrib minoltaAttribs[];
-extern const TagAttrib sonyAttribs[];
-extern const TagAttrib sonyTag9405Attribs[];
-extern const TagAttrib sonyCameraInfoAttribs[];
-extern const TagAttrib sonyCameraInfo2Attribs[];
-extern const TagAttrib sonyCameraSettingsAttribs[];
-extern const TagAttrib sonyCameraSettingsAttribs2[];
-extern const TagAttrib sonyCameraSettingsAttribs3[];
-//extern const TagAttrib sonyDNGMakerNote[];
-extern const TagAttrib olympusAttribs[];
-extern const TagAttrib kodakIfdAttribs[];
-void parseKodakIfdTextualInfo (Tag *textualInfo, Tag* exif);
-extern const TagAttrib panasonicAttribs[];
-extern const TagAttrib panasonicRawAttribs[];
-
-}
diff --git a/rtexif/sonyminoltaattribs.cc b/rtexif/sonyminoltaattribs.cc
deleted file mode 100644
index f666d7046..000000000
--- a/rtexif/sonyminoltaattribs.cc
+++ /dev/null
@@ -1,2557 +0,0 @@
-/*
- *
- *  Copyright (c) 2004-2010 Gabor Horvath <hgabor@rawtherapee.com>
- *
- *  RawTherapee is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  RawTherapee is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-#include <cmath>
-
-#include "rtexif.h"
-
-namespace rtexif
-{
-
-class SANoYesInterpreter : public ChoiceInterpreter<>
-{
-public:
-    SANoYesInterpreter ()
-    {
-        choices[1]  = "No";
-        choices[16] = "Yes";
-    }
-};
-SANoYesInterpreter saNoYesInterpreter;
-
-class SAOnOffInterpreter : public ChoiceInterpreter<>
-{
-public:
-    SAOnOffInterpreter ()
-    {
-        choices[0]      = "Off";
-        choices[1]      = "On";
-        choices[5]      = "On";
-    }
-};
-SAOnOffInterpreter saOnOffInterpreter;
-
-class SAOnOffInterpreter2 : public ChoiceInterpreter<>
-{
-public:
-    SAOnOffInterpreter2 ()
-    {
-        choices[1]  = "Off";
-        choices[16] = "On";
-    }
-};
-SAOnOffInterpreter2 saOnOffInterpreter2;
-
-class SAOnOffInterpreter3 : public ChoiceInterpreter<>
-{
-public:
-    SAOnOffInterpreter3 ()
-    {
-        choices[1]  = "Off";
-        choices[16] = "On (Auto)";
-        choices[17] = "On (Manual)";
-    }
-};
-SAOnOffInterpreter3 saOnOffInterpreter3;
-
-class SAOnOffInterpreter4 : public ChoiceInterpreter<>
-{
-public:
-    SAOnOffInterpreter4 ()
-    {
-        choices[0]   = "n/a";
-        choices[1]   = "Off";
-        choices[16]  = "On";
-        choices[255] = "None";
-    }
-};
-SAOnOffInterpreter4 saOnOffInterpreter4;
-
-class SAOnOffInterpreter5 : public ChoiceInterpreter<>
-{
-public:
-    SAOnOffInterpreter5 ()
-    {
-        choices[1]   = "On";
-        choices[2]   = "Off";
-    }
-};
-SAOnOffInterpreter5 saOnOffInterpreter5;
-
-class SAHighISONoiseReduction : public ChoiceInterpreter<>
-{
-public:
-    SAHighISONoiseReduction ()
-    {
-        choices[0]     = "Off";
-        choices[1]     = "Low";
-        choices[2]     = "Normal";
-        choices[3]     = "High";
-        choices[256]   = "Auto";
-        choices[65535] = "n/a";
-    }
-};
-SAHighISONoiseReduction saHighISONoiseReduction;
-
-class SAHighISONoiseReduction2 : public ChoiceInterpreter<>
-{
-public:
-    SAHighISONoiseReduction2 ()
-    {
-        choices[0]     = "Normal";
-        choices[1]     = "High";
-        choices[2]     = "Low";
-        choices[3]     = "Off";
-        choices[65535] = "n/a";
-    }
-};
-SAHighISONoiseReduction2 saHighISONoiseReduction2;
-
-class SAHighISONoiseReduction3 : public ChoiceInterpreter<>
-{
-public:
-    SAHighISONoiseReduction3 ()
-    {
-        choices[0]     = "Normal";
-        choices[1]     = "Low";
-        choices[2]     = "High";
-        choices[3]     = "Off";
-    }
-};
-SAHighISONoiseReduction3 saHighISONoiseReduction3;
-
-class SAHighISONoiseReduction4 : public ChoiceInterpreter<>
-{
-public:
-    SAHighISONoiseReduction4 ()
-    {
-        choices[0]     = "Off";
-        choices[1]     = "Low";
-        choices[2]     = "Normal";
-        choices[3]     = "High";
-    }
-};
-SAHighISONoiseReduction4 saHighISONoiseReduction4;
-
-class SAHighISONoiseReduction5 : public ChoiceInterpreter<>
-{
-public:
-    SAHighISONoiseReduction5 ()
-    {
-        choices[16]    = "Low";
-        choices[19]    = "Auto";
-    }
-};
-SAHighISONoiseReduction5 saHighISONoiseReduction5;
-
-class SASmileShutterMode : public ChoiceInterpreter<>
-{
-public:
-    SASmileShutterMode ()
-    {
-        choices[17]    = "Slight smile";
-        choices[18]    = "Normal smile";
-        choices[19]    = "Big smile";
-    }
-};
-SASmileShutterMode saSmileShutterMode;
-
-class SAHDRLevel : public ChoiceInterpreter<>
-{
-public:
-    SAHDRLevel ()
-    {
-        choices[33]    = "1 EV";
-        choices[34]    = "1.5 EV";
-        choices[35]    = "2 EV";
-        choices[36]    = "2.5 EV";
-        choices[37]    = "3 EV";
-        choices[38]    = "3.5 EV";
-        choices[39]    = "4 EV";
-        choices[40]    = "5 EV";
-        choices[41]    = "6 EV";
-    }
-};
-SAHDRLevel saHDRLevel;
-
-class SAViewingMode : public ChoiceInterpreter<>
-{
-public:
-    SAViewingMode ()
-    {
-        choices[0]     = "n/a";
-        choices[16]    = "ViewFinder";
-        choices[33]    = "Focus Check Live View";
-        choices[34]    = "Quick AF Live View";
-    }
-};
-SAViewingMode saViewingMode;
-
-class SAFlashAction : public ChoiceInterpreter<>
-{
-public:
-    SAFlashAction ()
-    {
-        choices[1]    = "Did not fire";
-        choices[2]    = "Fired";
-    }
-};
-SAFlashAction saFlashAction;
-
-class SALiveViewFocusMode : public ChoiceInterpreter<>
-{
-public:
-    SALiveViewFocusMode ()
-    {
-        choices[0]    = "n/a";
-        choices[1]    = "AF";
-        choices[16]   = "Manual";
-    }
-};
-SALiveViewFocusMode saLiveViewFocusMode;
-
-class SALensMount : public ChoiceInterpreter<>
-{
-public:
-    SALensMount ()
-    {
-        choices[1]    = "Unknown";
-        choices[16]   = "A-Mount";
-        choices[17]   = "E-Mount";
-    }
-};
-SALensMount saLensMount;
-
-class SASweepPanoramaSize : public ChoiceInterpreter<>
-{
-public:
-    SASweepPanoramaSize ()
-    {
-        choices[1]    = "Standard";
-        choices[2]    = "Wide";
-    }
-};
-SASweepPanoramaSize saSweepPanoramaSize;
-
-class SASweepPanoramaDirection : public ChoiceInterpreter<>
-{
-public:
-    SASweepPanoramaDirection ()
-    {
-        choices[1]    = "Right";
-        choices[2]    = "Left";
-        choices[3]    = "Up";
-        choices[4]    = "Down";
-    }
-};
-SASweepPanoramaDirection saSweepPanoramaDirection;
-
-class SALiveViewAFSetting : public ChoiceInterpreter<>
-{
-public:
-    SALiveViewAFSetting ()
-    {
-        choices[0]    = "n/a";
-        choices[1]    = "Phase-detect AF";
-        choices[2]    = "Contrast AF";
-    }
-};
-SALiveViewAFSetting saLiveViewAFSetting;
-
-class SAPanoramaSize3D : public ChoiceInterpreter<>
-{
-public:
-    SAPanoramaSize3D ()
-    {
-        choices[0]    = "n/a";
-        choices[1]    = "Standard";
-        choices[2]    = "Wide";
-        choices[3]    = "16:9";
-    }
-};
-SAPanoramaSize3D saPanoramaSize3D;
-
-class SALiveViewMetering : public ChoiceInterpreter<>
-{
-public:
-    SALiveViewMetering ()
-    {
-        choices[0]    = "n/a";
-        choices[16]   = "40 segment";
-        choices[32]   = "1200-zone Evaluative";
-    }
-};
-SALiveViewMetering saLiveViewMetering;
-
-class SAWhiteBalanceInterpreter: public ChoiceInterpreter<>
-{
-public:
-    SAWhiteBalanceInterpreter()
-    {
-        choices[ 0x0] = "Auto";
-        choices[ 0x1] = "Color Temperature/Color Filter";
-        choices[0x10] = "Daylight";
-        choices[0x20] = "Cloudy";
-        choices[0x30] = "Shade";
-        choices[0x40] = "Tungsten";
-        choices[0x50] = "Flash";
-        choices[0x60] = "Fluorescent";
-        choices[0x70] = "Custom";
-        choices[0x80] = "Underwater";
-    }
-};
-SAWhiteBalanceInterpreter saWhiteBalanceInterpreter;
-
-class SAWhiteBalanceSettingInterpreter: public ChoiceInterpreter<>
-{
-public:
-    SAWhiteBalanceSettingInterpreter()
-    {
-        choices[0x10] = "Auto (-3)";
-        choices[0x11] = "Auto (-2)";
-        choices[0x12] = "Auto (-1)";
-        choices[0x13] = "Auto (0)";
-        choices[0x14] = "Auto (+1)";
-        choices[0x15] = "Auto (+2)";
-        choices[0x16] = "Auto (+3)";
-        choices[0x20] = "Daylight (-3)";
-        choices[0x21] = "Daylight (-2)";
-        choices[0x22] = "Daylight (-1)";
-        choices[0x23] = "Daylight (0)";
-        choices[0x24] = "Daylight (+1)";
-        choices[0x25] = "Daylight (+2)";
-        choices[0x26] = "Daylight (+3)";
-        choices[0x30] = "Shade (-3)";
-        choices[0x31] = "Shade (-2)";
-        choices[0x32] = "Shade (-1)";
-        choices[0x33] = "Shade (0)";
-        choices[0x34] = "Shade (+1)";
-        choices[0x35] = "Shade (+2)";
-        choices[0x36] = "Shade (+3)";
-        choices[0x40] = "Cloudy (-3)";
-        choices[0x41] = "Cloudy (-2)";
-        choices[0x42] = "Cloudy (-1)";
-        choices[0x43] = "Cloudy (0)";
-        choices[0x44] = "Cloudy (+1)";
-        choices[0x45] = "Cloudy (+2)";
-        choices[0x46] = "Cloudy (+3)";
-        choices[0x50] = "Tungsten (-3)";
-        choices[0x51] = "Tungsten (-2)";
-        choices[0x52] = "Tungsten (-1)";
-        choices[0x53] = "Tungsten (0)";
-        choices[0x54] = "Tungsten (+1)";
-        choices[0x55] = "Tungsten (+2)";
-        choices[0x56] = "Tungsten (+3)";
-        choices[0x60] = "Fluorescent (-3)";
-        choices[0x61] = "Fluorescent (-2)";
-        choices[0x62] = "Fluorescent (-1)";
-        choices[0x63] = "Fluorescent (0)";
-        choices[0x64] = "Fluorescent (+1)";
-        choices[0x65] = "Fluorescent (+2)";
-        choices[0x66] = "Fluorescent (+3)";
-        choices[0x70] = "Flash (-3)";
-        choices[0x71] = "Flash (-2)";
-        choices[0x72] = "Flash (-1)";
-        choices[0x73] = "Flash (0)";
-        choices[0x74] = "Flash (+1)";
-        choices[0x75] = "Flash (+2)";
-        choices[0x76] = "Flash (+3)";
-        choices[0xa3] = "Custom";
-        choices[0xf3] = "Color Temperature/Color Filter";
-    }
-};
-SAWhiteBalanceSettingInterpreter saWhiteBalanceSettingInterpreter;
-
-class SASceneModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    SASceneModeInterpreter ()
-    {
-        choices[0]  = "Standard";
-        choices[1]  = "Portrait";
-        choices[2]  = "Text";
-        choices[3]  = "Night Scene";
-        choices[4]  = "Sunset";
-        choices[5]  = "Sports";
-        choices[6]  = "Landscape";
-        choices[7]  = "Night Portrait";
-        choices[8]  = "Macro";
-        choices[9]  = "Super Macro";
-        choices[16] = "Auto";
-        choices[17] = "Night View/Portrait";
-        choices[18] = "Sweep Panorama";
-        choices[19] = "Handheld Night Shot";
-        choices[20] = "Anti Motion Blur";
-        choices[21] = "Cont. Priority AE";
-        choices[22] = "Auto+";
-        choices[23] = "3D Sweep Panorama";
-        choices[24] = "Superior Auto";
-        choices[25] = "High Sensitivity";
-        choices[26] = "Fireworks";
-        choices[27] = "Food";
-        choices[28] = "Pet";
-        choices[33] = "HDR";
-        choices[65535] = "n/a";
-    }
-};
-SASceneModeInterpreter saSceneModeInterpreter;
-
-class SAZoneMatchingInterpreter : public ChoiceInterpreter<>
-{
-public:
-    SAZoneMatchingInterpreter ()
-    {
-        choices[0] = "ISO Setting Used";
-        choices[1] = "High Key";
-        choices[2] = "Low Key";
-    }
-};
-SAZoneMatchingInterpreter saZoneMatchingInterpreter;
-
-class SADynamicRangeOptimizerInterpreter : public ChoiceInterpreter<>
-{
-public:
-    SADynamicRangeOptimizerInterpreter ()
-    {
-        choices[0] = "Off";
-        choices[1] = "Standard";
-        choices[2] = "Advanced";
-        choices[3] = "Auto";
-        choices[8] = "Advanced Lv1";
-        choices[9] = "Advanced Lv2";
-        choices[10] = "Advanced Lv3";
-        choices[11] = "Advanced Lv4";
-        choices[12] = "Advanced Lv5";
-        choices[16] = "Lv1";
-        choices[17] = "Lv2";
-        choices[18] = "Lv3";
-        choices[19] = "Lv4";
-        choices[20] = "Lv5";
-    }
-};
-SADynamicRangeOptimizerInterpreter saDynamicRangeOptimizerInterpreter;
-
-class SAColorModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    SAColorModeInterpreter ()
-    {
-        choices[0]  = "Standard";
-        choices[1]  = "Vivid";
-        choices[2]  = "Portrait";
-        choices[3]  = "Landscape";
-        choices[4]  = "Sunset";
-        choices[5]  = "Night View/Portrait";
-        choices[6]  = "B&W";
-        choices[7]  = "Adobe RGB";
-        choices[12] = "Neutral";
-        choices[13] = "Clear";
-        choices[14] = "Deep";
-        choices[15] = "Light";
-        choices[16] = "Autumn Leaves";
-        choices[17] = "Sepia";
-        choices[100] = "Neutral";
-        choices[101] = "Clear";
-        choices[102] = "Deep";
-        choices[103] = "Light";
-        choices[104] = "Night View";
-        choices[105] = "Autumn Leaves";
-    }
-};
-SAColorModeInterpreter saColorModeInterpreter;
-
-class SAExposureModeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    SAExposureModeInterpreter ()
-    {
-        choices[0]  = "Program AE";
-        choices[1]  = "Portrait";
-        choices[2]  = "Beach";
-        choices[3]  = "Sports";
-        choices[4]  = "Snow";
-        choices[5]  = "Landscape";
-        choices[6]  = "Auto";
-        choices[7]  = "Aperture-priority AE";
-        choices[8]  = "Shutter speed priority AE";
-        choices[9]  = "Night Scene / Twilight";
-        choices[10] = "Hi-Speed Shutter";
-        choices[11] = "Twilight Portrait";
-        choices[12] = "Soft Snap/Portrait";
-        choices[13] = "Fireworks";
-        choices[14] = "Smile Shutter";
-        choices[15] = "Manual";
-        choices[18] = "High Sensitivity";
-        choices[19] = "Macro";
-        choices[20] = "Advanced Sports Shooting";
-        choices[29] = "Underwater";
-        choices[33] = "Food";
-        choices[34] = "Sweep Panorama";
-        choices[35] = "Handheld Night Shot";
-        choices[36] = "Anti Motion Blur";
-        choices[37] = "Pet";
-        choices[38] = "Backlight Correction HDR";
-        choices[39] = "Superior Auto";
-        choices[40] = "Background Defocus";
-        choices[41] = "Soft Skin";
-        choices[42] = "3D Image";
-        choices[65535] = "n/a";
-    }
-};
-SAExposureModeInterpreter saExposureModeInterpreter;
-
-class SAQualityInterpreter : public ChoiceInterpreter<>
-{
-public:
-    SAQualityInterpreter ()
-    {
-        choices[0]  = "Normal";
-        choices[1]  = "Fine";
-    }
-};
-SAQualityInterpreter saQualityInterpreter;
-
-class SAAntiBlurInterpreter : public ChoiceInterpreter<>
-{
-public:
-    SAAntiBlurInterpreter ()
-    {
-        choices[0]  = "Off";
-        choices[1]  = "On (Continuous)";
-        choices[2]  = "On (Shooting)";
-        choices[65535]  = "n/a";
-    }
-};
-SAAntiBlurInterpreter saAntiBlurInterpreter;
-
-class SALensIDInterpreter final : public IntLensInterpreter<int>
-{
-public:
-    SALensIDInterpreter ()
-    {
-        choices = {
-            {0, "Minolta AF 28-85mm f/3.5-4.5 New"},
-            {1, "Minolta AF 80-200mm f/2.8 HS-APO G"},
-            {2, "Minolta AF 28-70mm f/2.8 G"},
-            {3, "Minolta AF 28-80mm f/4-5.6"},
-            {4, "Minolta AF 85mm f/1.4G"},
-            {5, "Minolta AF 35-70mm f/3.5-4.5 [II]"},
-            {6, "Minolta AF 24-85mm f/3.5-4.5 [New]"},
-            {7, "Minolta AF 100-300mm f/4.5-5.6 APO [New] or 100-400mm or Sigma Lens"},
-            {7, "Minolta AF 100-400mm f/4.5-6.7 APO"},
-            {7, "Sigma AF 100-300mm f/4 EX DG IF"},
-            {8, "Minolta AF 70-210mm f/4.5-5.6 [II]"},
-            {9, "Minolta AF 50mm f/3.5 Macro"},
-            {10, "Minolta AF 28-105mm f/3.5-4.5 [New]"},
-            {11, "Minolta AF 300mm f/4 HS-APO G"},
-            {12, "Minolta AF 100mm f/2.8 Soft Focus"},
-            {13, "Minolta AF 75-300mm f/4.5-5.6 (New or II)"},
-            {14, "Minolta AF 100-400mm f/4.5-6.7 APO"},
-            {15, "Minolta AF 400mm f/4.5 HS-APO G"},
-            {16, "Minolta AF 17-35mm f/3.5 G"},
-            {17, "Minolta AF 20-35mm f/3.5-4.5"},
-            {18, "Minolta AF 28-80mm f/3.5-5.6 II"},
-            {19, "Minolta AF 35mm f/1.4 G"},
-            {20, "Minolta/Sony 135mm f/2.8 [T4.5] STF"},
-            {22, "Minolta AF 35-80mm f/4-5.6 II"},
-            {23, "Minolta AF 200mm f/4 Macro APO G"},
-            {24, "Minolta/Sony AF 24-105mm f/3.5-4.5 (D) or Sigma or Tamron Lens"},
-            {24, "Sigma 18-50mm f/2.8"},
-            {24, "Sigma 17-70mm f/2.8-4.5 DC Macro"},
-            {24, "Sigma 20-40mm f/2.8 EX DG Aspherical IF"},
-            {24, "Sigma 18-200mm f/3.5-6.3 DC"},
-            {24, "Sigma DC 18-125mm f/4-5,6 D"},
-            {24, "Tamron SP AF 28-75mm f/2.8 XR Di LD Aspherical [IF] Macro"},
-            {24, "Sigma 15-30mm f/3.5-4.5 EX DG Aspherical"},
-            {25, "Minolta AF 100-300mm f/4.5-5.6 APO (D) or Sigma Lens"},
-            {25, "Sigma 100-300mm f/4 EX (APO (D) or D IF)"},
-            {25, "Sigma 70mm f/2.8 EX DG Macro"},
-            {25, "Sigma 20mm f/1.8 EX DG Aspherical RF"},
-            {25, "Sigma 30mm f/1.4 EX DC"},
-            {25, "Sigma 24mm f/1.8 EX DG ASP Macro"},
-            {27, "Minolta AF 85mm f/1.4 G (D)"},
-            {28, "Minolta/Sony AF 100mm f/2.8 Macro (D) or Tamron Lens"},
-            {28, "Tamron SP AF 90mm f/2.8 Di Macro"},
-            {28, "Tamron SP AF 180mm f/3.5 Di LD [IF] Macro"},
-            {29, "Minolta/Sony AF 75-300mm f/4.5-5.6 (D)"},
-            {30, "Minolta AF 28-80mm f/3.5-5.6 (D) or Sigma Lens"},
-            {30, "Sigma AF 10-20mm f/4-5.6 EX DC"},
-            {30, "Sigma AF 12-24mm f/4.5-5.6 EX DG"},
-            {30, "Sigma 28-70mm EX DG f/2.8"},
-            {30, "Sigma 55-200mm f/4-5.6 DC"},
-            {31, "Minolta/Sony AF 50mm f/2.8 Macro (D) or f/3.5"},
-            {31, "Minolta/Sony AF 50mm f/3.5 Macro"},
-            {32, "Minolta/Sony AF 300mm f/2.8 G or 1.5x Teleconverter"},
-            {33, "Minolta/Sony AF 70-200mm f/2.8 G"},
-            {35, "Minolta AF 85mm f/1.4 G (D) Limited"},
-            {36, "Minolta AF 28-100mm f/3.5-5.6 (D)"},
-            {38, "Minolta AF 17-35mm f/2.8-4 (D)"},
-            {39, "Minolta AF 28-75mm f/2.8 (D)"},
-            {40, "Minolta/Sony AF DT 18-70mm f/3.5-5.6 (D)"},
-            {41, "Minolta/Sony AF DT 11-18mm f/4.5-5.6 (D) or Tamron Lens"},
-            {41, "Tamron SP AF 11-18mm f/4.5-5.6 Di II LD Aspherical IF"},
-            {42, "Minolta/Sony AF DT 18-200mm f/3.5-6.3 (D)"},
-            {43, "Sony 35mm f/1.4 G (SAL35F14G)"},
-            {44, "Sony 50mm f/1.4 (SAL50F14)"},
-            {45, "Carl Zeiss Planar T* 85mm f/1.4 ZA (SAL85F14Z)"},
-            {46, "Carl Zeiss Vario-Sonnar T* DT 16-80mm f/3.5-4.5 ZA (SAL1680Z)"},
-            {47, "Carl Zeiss Sonnar T* 135mm f/1.8 ZA (SAL135F18Z)"},
-            {48, "Carl Zeiss Vario-Sonnar T* 24-70mm f/2.8 ZA SSM (SAL2470Z) or Other Lens"},
-            {48, "Carl Zeiss Vario-Sonnar T* 24-70mm f/2.8 ZA SSM II (SAL2470Z2)"},
-            {48, "Tamron SP 24-70mm f/2.8 Di USD"},
-            {49, "Sony DT 55-200mm f/4-5.6 (SAL55200)"},
-            {50, "Sony DT 18-250mm f/3.5-6.3 (SAL18250)"},
-            {51, "Sony DT 16-105mm f/3.5-5.6 (SAL16105)"},
-            {52, "Sony 70-300mm f/4.5-5.6 G SSM (SAL70300G) or G SSM II or Tamron Lens"},
-            {52, "Sony 70-300mm f/4.5-5.6 G SSM II (SAL70300G2)"},
-            {52, "Tamron SP 70-300mm f/4-5.6 Di USD"},
-            {53, "Sony 70-400mm f/4-5.6 G SSM (SAL70400G)"},
-            {54, "Carl Zeiss Vario-Sonnar T* 16-35mm f/2.8 ZA SSM (SAL1635Z) or ZA SSM II"},
-            {54, "Carl Zeiss Vario-Sonnar T* 16-35mm f/2.8 ZA SSM II (SAL1635Z2)"},
-            {55, "Sony DT 18-55mm f/3.5-5.6 SAM (SAL1855) or SAM II"},
-            {55, "Sony DT 18-55mm f/3.5-5.6 SAM II (SAL18552)"},
-            {56, "Sony DT 55-200mm f/4-5.6 SAM (SAL55200-2)"},
-            {57, "Sony DT 50mm f/1.8 SAM (SAL50F18) or Tamron Lens or Commlite CM-EF-NEX adapter"},
-            {57, "Tamron SP AF 60mm f/2 Di II LD [IF] Macro 1:1"},
-            {57, "Tamron 18-270mm f/3.5-6.3 Di II PZD"},
-            {58, "Sony DT 30mm f/2.8 Macro SAM (SAL30M28)"},
-            {59, "Sony 28-75mm f/2.8 SAM (SAL2875)"},
-            {60, "Carl Zeiss Distagon T* 24mm f/2 ZA SSM (SAL24F20Z)"},
-            {61, "Sony 85mm f/2.8 SAM (SAL85F28)"},
-            {62, "Sony DT 35mm f/1.8 SAM (SAL35F18)"},
-            {63, "Sony DT 16-50mm f/2.8 SSM (SAL1650)"},
-            {64, "Sony 500mm f/4 G SSM (SAL500F40G)"},
-            {65, "Sony DT 18-135mm f/3.5-5.6 SAM (SAL18135)"},
-            {66, "Sony 300mm f/2.8 G SSM II (SAL300F28G2)"},
-            {67, "Sony 70-200mm f/2.8 G SSM II (SAL70200G2)"},
-            {68, "Sony DT 55-300mm f/4.5-5.6 SAM (SAL55300)"},
-            {69, "Sony 70-400mm f/4-5.6 G SSM II (SAL70400G2)"},
-            {70, "Carl Zeiss Planar T* 50mm f/1.4 ZA SSM (SAL50F14Z)"},
-            {128, "Tamron or Sigma Lens (128)"},
-            {128, "Tamron AF 18-200mm f/3.5-6.3 XR Di II LD Aspherical [IF] Macro"},
-            {128, "Tamron AF 28-300mm f/3.5-6.3 XR Di LD Aspherical [IF] Macro"},
-            {128, "Tamron AF 28-200mm f/3.8-5.6 XR Di Aspherical [IF] Macro"},
-            {128, "Tamron SP AF 17-35mm f/2.8-4 Di LD Aspherical IF"},
-            {128, "Sigma AF 50-150mm f/2.8 EX DC APO HSM II"},
-            {128, "Sigma 10-20mm f/3.5 EX DC HSM"},
-            {128, "Sigma 70-200mm f/2.8 II EX DG APO MACRO HSM"},
-            {128, "Sigma 10mm f/2.8 EX DC HSM Fisheye"},
-            {128, "Sigma 50mm f/1.4 EX DG HSM"},
-            {128, "Sigma 85mm f/1.4 EX DG HSM"},
-            {128, "Sigma 24-70mm f/2.8 IF EX DG HSM"},
-            {128, "Sigma 18-250mm f/3.5-6.3 DC OS HSM"},
-            {128, "Sigma 17-50mm f/2.8 EX DC HSM"},
-            {128, "Sigma 17-70mm f/2.8-4 DC Macro HSM"},
-            {128, "Sigma 150mm f/2.8 EX DG OS HSM APO Macro"},
-            {128, "Sigma 150-500mm f/5-6.3 APO DG OS HSM"},
-            {128, "Tamron AF 28-105mm f/4-5.6 [IF]"},
-            {128, "Sigma 35mm f/1.4 DG HSM"},
-            {128, "Sigma 18-35mm f/1.8 DC HSM"},
-            {128, "Sigma 50-500mm f/4.5-6.3 APO DG OS HSM"},
-            {128, "Sigma 24-105mm f/4 DG HSM | A"},
-            {128, "Sigma 30mm f/1.4"},
-            {128, "Sigma 35mm f/1.4 DG HSM | A"},
-            {128, "Sigma 105mm f/2.8 EX DG OS HSM Macro"},
-            {128, "Sigma 180mm f/2.8 EX DG OS HSM APO Macro"},
-            {128, "Sigma 18-300mm f/3.5-6.3 DC Macro HSM | C"},
-            {128, "Sigma 18-50mm f/2.8-4.5 DC HSM"},
-            {129, "Tamron Lens (129)"},
-            {129, "Tamron 200-400mm f/5.6 LD"},
-            {129, "Tamron 70-300mm f/4-5.6 LD"},
-            {131, "Tamron 20-40mm f/2.7-3.5 SP Aspherical IF"},
-            {135, "Vivitar 28-210mm f/3.5-5.6"},
-            {136, "Tokina EMZ M100 AF 100mm f/3.5"},
-            {137, "Cosina 70-210mm f/2.8-4 AF"},
-            {138, "Soligor 19-35mm f/3.5-4.5"},
-            {139, "Tokina AF 28-300mm f/4-6.3"},
-            {142, "Cosina AF 70-300mm f/4.5-5.6 MC"},
-            {146, "Voigtlander Macro APO-Lanthar 125mm f/2.5 SL"},
-            {194, "Tamron SP AF 17-50mm f/2.8 XR Di II LD Aspherical [IF]"},
-            {202, "Tamron SP AF 70-200mm f/2.8 Di LD [IF] Macro"},
-            {203, "Tamron SP 70-200mm f/2.8 Di USD"},
-            {204, "Tamron SP 24-70mm f/2.8 Di USD"},
-            {212, "Tamron 28-300mm f/3.5-6.3 Di PZD"},
-            {213, "Tamron 16-300mm f/3.5-6.3 Di II PZD Macro"},
-            {214, "Tamron SP 150-600mm f/5-6.3 Di USD"},
-            {215, "Tamron SP 15-30mm f/2.8 Di USD"},
-            {216, "Tamron SP 45mm f/1.8 Di USD"},
-            {217, "Tamron SP 35mm f/1.8 Di USD"},
-            {218, "Tamron SP 90mm f/2.8 Di Macro 1:1 USD (F017)"},
-            {220, "Tamron SP 150-600mm f/5-6.3 Di USD G2"},
-            {224, "Tamron SP 90mm f/2.8 Di Macro 1:1 USD (F004)"},
-            {255, "Tamron Lens (255)"},
-            {255, "Tamron SP AF 17-50mm f/2.8 XR Di II LD Aspherical"},
-            {255, "Tamron AF 18-250mm f/3.5-6.3 XR Di II LD"},
-            {255, "Tamron AF 55-200mm f/4-5.6 Di II LD Macro"},
-            {255, "Tamron AF 70-300mm f/4-5.6 Di LD Macro 1:2"},
-            {255, "Tamron SP AF 200-500mm f/5.0-6.3 Di LD IF"},
-            {255, "Tamron SP AF 10-24mm f/3.5-4.5 Di II LD Aspherical IF"},
-            {255, "Tamron SP AF 70-200mm f/2.8 Di LD IF Macro"},
-            {255, "Tamron SP AF 28-75mm f/2.8 XR Di LD Aspherical IF"},
-            {255, "Tamron AF 90-300mm f/4.5-5.6 Telemacro"},
-            {1868, "Sigma MC-11 SA-E Mount Converter with not-supported Sigma lens"},
-            {2550, "Minolta AF 50mm f/1.7"},
-            {2551, "Minolta AF 35-70mm f/4 or Other Lens"},
-            {2551, "Sigma UC AF 28-70mm f/3.5-4.5"},
-            {2551, "Sigma AF 28-70mm f/2.8"},
-            {2551, "Sigma M-AF 70-200mm f/2.8 EX Aspherical"},
-            {2551, "Quantaray M-AF 35-80mm f/4-5.6"},
-            {2551, "Tokina 28-70mm f/2.8-4.5 AF"},
-            {2552, "Minolta AF 28-85mm f/3.5-4.5 or Other Lens"},
-            {2552, "Tokina 19-35mm f/3.5-4.5"},
-            {2552, "Tokina 28-70mm f/2.8 AT-X"},
-            {2552, "Tokina 80-400mm f/4.5-5.6 AT-X AF II 840"},
-            {2552, "Tokina AF PRO 28-80mm f/2.8 AT-X 280"},
-            {2552, "Tokina AT-X PRO [II] AF 28-70mm f/2.6-2.8 270"},
-            {2552, "Tamron AF 19-35mm f/3.5-4.5"},
-            {2552, "Angenieux AF 28-70mm f/2.6"},
-            {2552, "Tokina AT-X 17 AF 17mm f/3.5"},
-            {2552, "Tokina 20-35mm f/3.5-4.5 II AF"},
-            {2553, "Minolta AF 28-135mm f/4-4.5 or Other Lens"},
-            {2553, "Sigma ZOOM-alpha 35-135mm f/3.5-4.5"},
-            {2553, "Sigma 28-105mm f/2.8-4 Aspherical"},
-            {2553, "Sigma 28-105mm f/4-5.6 UC"},
-            {2553, "Tokina AT-X 242 AF 24-200mm f/3.5-5.6"},
-            {2554, "Minolta AF 35-105mm f/3.5-4.5"},
-            {2555, "Minolta AF 70-210mm f/4 Macro or Sigma Lens"},
-            {2555, "Sigma 70-210mm f/4-5.6 APO"},
-            {2555, "Sigma M-AF 70-200mm f/2.8 EX APO"},
-            {2555, "Sigma 75-200mm f/2.8-3.5"},
-            {2556, "Minolta AF 135mm f/2.8"},
-            {2557, "Minolta/Sony AF 28mm f/2.8"},
-            {2558, "Minolta AF 24-50mm f/4"},
-            {2560, "Minolta AF 100-200mm f/4.5"},
-            {2561, "Minolta AF 75-300mm f/4.5-5.6 or Sigma Lens"},
-            {2561, "Sigma 70-300mm f/4-5.6 DL Macro"},
-            {2561, "Sigma 300mm f/4 APO Macro"},
-            {2561, "Sigma AF 500mm f/4.5 APO"},
-            {2561, "Sigma AF 170-500mm f/5-6.3 APO Aspherical"},
-            {2561, "Tokina AT-X AF 300mm f/4"},
-            {2561, "Tokina AT-X AF 400mm f/5.6 SD"},
-            {2561, "Tokina AF 730 II 75-300mm f/4.5-5.6"},
-            {2561, "Sigma 800mm f/5.6 APO"},
-            {2561, "Sigma AF 400mm f/5.6 APO Macro"},
-            {2561, "Sigma 1000mm f/8 APO"},
-            {2562, "Minolta AF 50mm f/1.4 [New]"},
-            {2563, "Minolta AF 300mm f/2.8 APO or Sigma Lens"},
-            {2563, "Sigma AF 50-500mm f/4-6.3 EX DG APO"},
-            {2563, "Sigma AF 170-500mm f/5-6.3 APO Aspherical"},
-            {2563, "Sigma AF 500mm f/4.5 EX DG APO"},
-            {2563, "Sigma 400mm f/5.6 APO"},
-            {2564, "Minolta AF 50mm f/2.8 Macro or Sigma Lens"},
-            {2564, "Sigma 50mm f/2.8 EX Macro"},
-            {2565, "Minolta AF 600mm f/4 APO"},
-            {2566, "Minolta AF 24mm f/2.8 or Sigma Lens"},
-            {2566, "Sigma 17-35mm f/2.8-4 EX Aspherical"},
-            {2572, "Minolta/Sony AF 500mm f/8 Reflex"},
-            {2578, "Minolta/Sony AF 16mm f/2.8 Fisheye or Sigma Lens"},
-            {2578, "Sigma 8mm f/4 EX [DG] Fisheye"},
-            {2578, "Sigma 14mm f/3.5"},
-            {2578, "Sigma 15mm f/2.8 Fisheye"},
-            {2579, "Minolta/Sony AF 20mm f/2.8 or Tokina Lens"},
-            {2579, "Tokina AT-X Pro DX 11-16mm f/2.8"},
-            {2581, "Minolta AF 100mm f/2.8 Macro [New] or Sigma or Tamron Lens"},
-            {2581, "Sigma AF 90mm f/2.8 Macro"},
-            {2581, "Sigma AF 105mm f/2.8 EX [DG] Macro"},
-            {2581, "Sigma 180mm f/5.6 Macro"},
-            {2581, "Sigma 180mm f/3.5 EX DG Macro"},
-            {2581, "Tamron 90mm f/2.8 Macro"},
-            {2585, "Minolta AF 35-105mm f/3.5-4.5 New or Tamron Lens"},
-            {2585, "Beroflex 35-135mm f/3.5-4.5"},
-            {2585, "Tamron 24-135mm f/3.5-5.6"},
-            {2588, "Minolta AF 70-210mm f/3.5-4.5"},
-            {2589, "Minolta AF 80-200mm f/2.8 APO or Tokina Lens"},
-            {2589, "Tokina 80-200mm f/2.8"},
-            {2590, "Minolta AF 200mm f/2.8 G APO + Minolta AF 1.4x APO or Other Lens + 1.4x"},
-            {2590, "Minolta AF 600mm f/4 HS-APO G + Minolta AF 1.4x APO"},
-            {2591, "Minolta AF 35mm f/1.4"},
-            {2592, "Minolta AF 85mm f/1.4 G (D)"},
-            {2593, "Minolta AF 200mm f/2.8 APO"},
-            {2594, "Minolta AF 3x-1x f/1.7-2.8 Macro"},
-            {2596, "Minolta AF 28mm f/2"},
-            {2597, "Minolta AF 35mm f/2 [New]"},
-            {2598, "Minolta AF 100mm f/2"},
-            {2601, "Minolta AF 200mm f/2.8 G APO + Minolta AF 2x APO or Other Lens + 2x"},
-            {2601, "Minolta AF 600mm f/4 HS-APO G + Minolta AF 2x APO"},
-            {2604, "Minolta AF 80-200mm f/4.5-5.6"},
-            {2605, "Minolta AF 35-80mm f/4-5.6"},
-            {2606, "Minolta AF 100-300mm f/4.5-5.6"},
-            {2607, "Minolta AF 35-80mm f/4-5.6"},
-            {2608, "Minolta AF 300mm f/2.8 HS-APO G"},
-            {2609, "Minolta AF 600mm f/4 HS-APO G"},
-            {2612, "Minolta AF 200mm f/2.8 HS-APO G"},
-            {2613, "Minolta AF 50mm f/1.7 New"},
-            {2615, "Minolta AF 28-105mm f/3.5-4.5 xi"},
-            {2616, "Minolta AF 35-200mm f/4.5-5.6 xi"},
-            {2618, "Minolta AF 28-80mm f/4-5.6 xi"},
-            {2619, "Minolta AF 80-200mm f/4.5-5.6 xi"},
-            {2620, "Minolta AF 28-70mm f/2.8 G"},
-            {2621, "Minolta AF 100-300mm f/4.5-5.6 xi"},
-            {2624, "Minolta AF 35-80mm f/4-5.6 Power Zoom"},
-            {2628, "Minolta AF 80-200mm f/2.8 HS-APO G"},
-            {2629, "Minolta AF 85mm f/1.4 New"},
-            {2631, "Minolta AF 100-300mm f/4.5-5.6 APO"},
-            {2632, "Minolta AF 24-50mm f/4 New"},
-            {2638, "Minolta AF 50mm f/2.8 Macro New"},
-            {2639, "Minolta AF 100mm f/2.8 Macro"},
-            {2641, "Minolta/Sony AF 20mm f/2.8 New"},
-            {2642, "Minolta AF 24mm f/2.8 New"},
-            {2644, "Minolta AF 100-400mm f/4.5-6.7 APO"},
-            {2662, "Minolta AF 50mm f/1.4 New"},
-            {2667, "Minolta AF 35mm f/2 New"},
-            {2668, "Minolta AF 28mm f/2 New"},
-            {2672, "Minolta AF 24-105mm f/3.5-4.5 (D)"},
-            {3046, "Metabones Canon EF Speed Booster"},
-            {4567, "Tokina 70-210mm f/4-5.6"},
-            {4568, "Tokina AF 35-200mm f/4-5.6 Zoom SD"},
-            {4570, "Tamron AF 35-135mm f/3.5-4.5"},
-            {4571, "Vivitar 70-210mm f/4.5-5.6"},
-            {4574, "2x Teleconverter or Tamron or Tokina Lens"},
-            {4574, "Tamron SP AF 90mm f/2.5"},
-            {4574, "Tokina RF 500mm f/8.0 x2"},
-            {4574, "Tokina 300mm f/2.8 x2"},
-            {4575, "1.4x Teleconverter"},
-            {4585, "Tamron SP AF 300mm f/2.8 LD IF"},
-            {4586, "Tamron SP AF 35-105mm f/2.8 LD Aspherical IF"},
-            {4587, "Tamron AF 70-210mm f/2.8 SP LD"},
-            {4812, "Metabones Canon EF Speed Booster Ultra"},
-            {6118, "Canon EF Adapter"},
-            {6528, "Sigma 16mm f/2.8 Filtermatic Fisheye"},
-            {6553, "E-Mount, T-Mount, Other Lens or no lens"},
-            {6553, "Arax MC 35mm f/2.8 Tilt+Shift"},
-            {6553, "Arax MC 80mm f/2.8 Tilt+Shift"},
-            {6553, "Zenitar MF 16mm f/2.8 Fisheye M42"},
-            {6553, "Samyang 500mm Mirror f/8.0"},
-            {6553, "Pentacon Auto 135mm f/2.8"},
-            {6553, "Pentacon Auto 29mm f/2.8"},
-            {6553, "Helios 44-2 58mm f/2.0"},
-            {18688, "Sigma MC-11 SA-E Mount Converter with not-supported Sigma lens"},
-            {25501, "Minolta AF 50mm f/1.7"},
-            {25511, "Minolta AF 35-70mm f/4 or Other Lens"},
-            {25511, "Sigma UC AF 28-70mm f/3.5-4.5"},
-            {25511, "Sigma AF 28-70mm f/2.8"},
-            {25511, "Sigma M-AF 70-200mm f/2.8 EX Aspherical"},
-            {25511, "Quantaray M-AF 35-80mm f/4-5.6"},
-            {25511, "Tokina 28-70mm f/2.8-4.5 AF"},
-            {25521, "Minolta AF 28-85mm f/3.5-4.5 or Other Lens"},
-            {25521, "Tokina 19-35mm f/3.5-4.5"},
-            {25521, "Tokina 28-70mm f/2.8 AT-X"},
-            {25521, "Tokina 80-400mm f/4.5-5.6 AT-X AF II 840"},
-            {25521, "Tokina AF PRO 28-80mm f/2.8 AT-X 280"},
-            {25521, "Tokina AT-X PRO [II] AF 28-70mm f/2.6-2.8 270"},
-            {25521, "Tamron AF 19-35mm f/3.5-4.5"},
-            {25521, "Angenieux AF 28-70mm f/2.6"},
-            {25521, "Tokina AT-X 17 AF 17mm f/3.5"},
-            {25521, "Tokina 20-35mm f/3.5-4.5 II AF"},
-            {25531, "Minolta AF 28-135mm f/4-4.5 or Other Lens"},
-            {25531, "Sigma ZOOM-alpha 35-135mm f/3.5-4.5"},
-            {25531, "Sigma 28-105mm f/2.8-4 Aspherical"},
-            {25531, "Sigma 28-105mm f/4-5.6 UC"},
-            {25531, "Tokina AT-X 242 AF 24-200mm f/3.5-5.6"},
-            {25541, "Minolta AF 35-105mm f/3.5-4.5"},
-            {25551, "Minolta AF 70-210mm f/4 Macro or Sigma Lens"},
-            {25551, "Sigma 70-210mm f/4-5.6 APO"},
-            {25551, "Sigma M-AF 70-200mm f/2.8 EX APO"},
-            {25551, "Sigma 75-200mm f/2.8-3.5"},
-            {25561, "Minolta AF 135mm f/2.8"},
-            {25571, "Minolta/Sony AF 28mm f/2.8"},
-            {25581, "Minolta AF 24-50mm f/4"},
-            {25601, "Minolta AF 100-200mm f/4.5"},
-            {25611, "Minolta AF 75-300mm f/4.5-5.6 or Sigma Lens"},
-            {25611, "Sigma 70-300mm f/4-5.6 DL Macro"},
-            {25611, "Sigma 300mm f/4 APO Macro"},
-            {25611, "Sigma AF 500mm f/4.5 APO"},
-            {25611, "Sigma AF 170-500mm f/5-6.3 APO Aspherical"},
-            {25611, "Tokina AT-X AF 300mm f/4"},
-            {25611, "Tokina AT-X AF 400mm f/5.6 SD"},
-            {25611, "Tokina AF 730 II 75-300mm f/4.5-5.6"},
-            {25611, "Sigma 800mm f/5.6 APO"},
-            {25611, "Sigma AF 400mm f/5.6 APO Macro"},
-            {25611, "Sigma 1000mm f/8 APO"},
-            {25621, "Minolta AF 50mm f/1.4 [New]"},
-            {25631, "Minolta AF 300mm f/2.8 APO or Sigma Lens"},
-            {25631, "Sigma AF 50-500mm f/4-6.3 EX DG APO"},
-            {25631, "Sigma AF 170-500mm f/5-6.3 APO Aspherical"},
-            {25631, "Sigma AF 500mm f/4.5 EX DG APO"},
-            {25631, "Sigma 400mm f/5.6 APO"},
-            {25641, "Minolta AF 50mm f/2.8 Macro or Sigma Lens"},
-            {25641, "Sigma 50mm f/2.8 EX Macro"},
-            {25651, "Minolta AF 600mm f/4 APO"},
-            {25661, "Minolta AF 24mm f/2.8 or Sigma Lens"},
-            {25661, "Sigma 17-35mm f/2.8-4 EX Aspherical"},
-            {25721, "Minolta/Sony AF 500mm f/8 Reflex"},
-            {25781, "Minolta/Sony AF 16mm f/2.8 Fisheye or Sigma Lens"},
-            {25781, "Sigma 8mm f/4 EX [DG] Fisheye"},
-            {25781, "Sigma 14mm f/3.5"},
-            {25781, "Sigma 15mm f/2.8 Fisheye"},
-            {25791, "Minolta/Sony AF 20mm f/2.8 or Tokina Lens"},
-            {25791, "Tokina AT-X Pro DX 11-16mm f/2.8"},
-            {25811, "Minolta AF 100mm f/2.8 Macro [New] or Sigma or Tamron Lens"},
-            {25811, "Sigma AF 90mm f/2.8 Macro"},
-            {25811, "Sigma AF 105mm f/2.8 EX [DG] Macro"},
-            {25811, "Sigma 180mm f/5.6 Macro"},
-            {25811, "Sigma 180mm f/3.5 EX DG Macro"},
-            {25811, "Tamron 90mm f/2.8 Macro"},
-            {25851, "Beroflex 35-135mm f/3.5-4.5"},
-            {25858, "Minolta AF 35-105mm f/3.5-4.5 New or Tamron Lens"},
-            {25858, "Tamron 24-135mm f/3.5-5.6"},
-            {25881, "Minolta AF 70-210mm f/3.5-4.5"},
-            {25891, "Minolta AF 80-200mm f/2.8 APO or Tokina Lens"},
-            {25891, "Tokina 80-200mm f/2.8"},
-            {25901, "Minolta AF 200mm f/2.8 G APO + Minolta AF 1.4x APO or Other Lens + 1.4x"},
-            {25901, "Minolta AF 600mm f/4 HS-APO G + Minolta AF 1.4x APO"},
-            {25911, "Minolta AF 35mm f/1.4"},
-            {25921, "Minolta AF 85mm f/1.4 G (D)"},
-            {25931, "Minolta AF 200mm f/2.8 APO"},
-            {25941, "Minolta AF 3x-1x f/1.7-2.8 Macro"},
-            {25961, "Minolta AF 28mm f/2"},
-            {25971, "Minolta AF 35mm f/2 [New]"},
-            {25981, "Minolta AF 100mm f/2"},
-            {26011, "Minolta AF 200mm f/2.8 G APO + Minolta AF 2x APO or Other Lens + 2x"},
-            {26011, "Minolta AF 600mm f/4 HS-APO G + Minolta AF 2x APO"},
-            {26041, "Minolta AF 80-200mm f/4.5-5.6"},
-            {26051, "Minolta AF 35-80mm f/4-5.6"},
-            {26061, "Minolta AF 100-300mm f/4.5-5.6"},
-            {26071, "Minolta AF 35-80mm f/4-5.6"},
-            {26081, "Minolta AF 300mm f/2.8 HS-APO G"},
-            {26091, "Minolta AF 600mm f/4 HS-APO G"},
-            {26121, "Minolta AF 200mm f/2.8 HS-APO G"},
-            {26131, "Minolta AF 50mm f/1.7 New"},
-            {26151, "Minolta AF 28-105mm f/3.5-4.5 xi"},
-            {26161, "Minolta AF 35-200mm f/4.5-5.6 xi"},
-            {26181, "Minolta AF 28-80mm f/4-5.6 xi"},
-            {26191, "Minolta AF 80-200mm f/4.5-5.6 xi"},
-            {26201, "Minolta AF 28-70mm f/2.8 G"},
-            {26211, "Minolta AF 100-300mm f/4.5-5.6 xi"},
-            {26241, "Minolta AF 35-80mm f/4-5.6 Power Zoom"},
-            {26281, "Minolta AF 80-200mm f/2.8 HS-APO G"},
-            {26291, "Minolta AF 85mm f/1.4 New"},
-            {26311, "Minolta AF 100-300mm f/4.5-5.6 APO"},
-            {26321, "Minolta AF 24-50mm f/4 New"},
-            {26381, "Minolta AF 50mm f/2.8 Macro New"},
-            {26391, "Minolta AF 100mm f/2.8 Macro"},
-            {26411, "Minolta/Sony AF 20mm f/2.8 New"},
-            {26421, "Minolta AF 24mm f/2.8 New"},
-            {26441, "Minolta AF 100-400mm f/4.5-6.7 APO"},
-            {26621, "Minolta AF 50mm f/1.4 New"},
-            {26671, "Minolta AF 35mm f/2 New"},
-            {26681, "Minolta AF 28mm f/2 New"},
-            {26721, "Minolta AF 24-105mm f/3.5-4.5 (D)"},
-            {30464, "Metabones Canon EF Speed Booster"},
-            {45671, "Tokina 70-210mm f/4-5.6"},
-            {45681, "Tokina AF 35-200mm f/4-5.6 Zoom SD"},
-            {45701, "Tamron AF 35-135mm f/3.5-4.5"},
-            {45711, "Vivitar 70-210mm f/4.5-5.6"},
-            {45741, "2x Teleconverter or Tamron or Tokina Lens"},
-            {45741, "Tamron SP AF 90mm f/2.5"},
-            {45741, "Tokina RF 500mm f/8.0 x2"},
-            {45741, "Tokina 300mm f/2.8 x2"},
-            {45751, "1.4x Teleconverter"},
-            {45851, "Tamron SP AF 300mm f/2.8 LD IF"},
-            {45861, "Tamron SP AF 35-105mm f/2.8 LD Aspherical IF"},
-            {45871, "Tamron AF 70-210mm f/2.8 SP LD"},
-            {48128, "Metabones Canon EF Speed Booster Ultra"},
-            {61184, "Canon EF Adapter"},
-            {65280, "Sigma 16mm f/2.8 Filtermatic Fisheye"},
-            {65535, "E-Mount, T-Mount, Other Lens or no lens"},
-            {65535, "Arax MC 35mm f/2.8 Tilt+Shift"},
-            {65535, "Arax MC 80mm f/2.8 Tilt+Shift"},
-            {65535, "Zenitar MF 16mm f/2.8 Fisheye M42"},
-            {65535, "Samyang 500mm Mirror f/8.0"},
-            {65535, "Pentacon Auto 135mm f/2.8"},
-            {65535, "Pentacon Auto 29mm f/2.8"},
-            {65535, "Helios 44-2 58mm f/2.0"}
-        };
-    }
-
-    std::string toString (const Tag* t) const override
-    {
-        int lensID = t->toInt();
-        Tag *lensInfoTag = t->getParent()->getRoot()->findTag ("LensInfo");
-        Tag *apertureTag = t->getParent()->getRoot()->findTag ("MaxApertureValue");
-        Tag *focalLengthTag = t->getParent()->getRoot()->findTag ("FocalLength");
-        double maxApertureAtFocal = 0.;
-        double focalLength = 0.;
-
-        if ( apertureTag ) {
-            maxApertureAtFocal = pow (2.0, apertureTag->toDouble() / 2.0);
-        }
-
-        if ( focalLengthTag ) {
-            focalLength = focalLengthTag->toDouble();
-        }
-
-        double *liArray = nullptr;
-
-        if (lensInfoTag) {
-            liArray = lensInfoTag->toDoubleArray();
-        }
-
-        std::string retval = guess ( lensID, focalLength, maxApertureAtFocal, liArray);
-
-        if (liArray) {
-            delete [] liArray;
-        }
-
-        return retval;
-    }
-};
-SALensIDInterpreter saLensIDInterpreter;
-
-class SALensID2Interpreter final : public IntLensInterpreter< int >
-{
-public:
-    SALensID2Interpreter ()
-    {
-        choices.insert (p_t (0, "Unknown E-mount lens or other lens"));
-        choices.insert (p_t (0, "Sigma 19mm f/2.8 [EX] DN"));
-        choices.insert (p_t (0, "Sigma 30mm f/2.8 [EX] DN"));
-        choices.insert (p_t (0, "Sigma 60mm f/2.8 DN"));
-        choices.insert (p_t (0, "Sony E 18-200mm f/3.5-6.3 OSS LE"));
-        choices.insert (p_t (0, "Tamron 18-200mm f/3.5-6.3 Di III VC"));
-        choices.insert (p_t (0, "Tokina FiRIN 20mm f/2 FE AF"));
-        choices.insert (p_t (0, "Tokina FiRIN 20mm f/2 FE MF"));
-        choices.insert (p_t (0, "Zeiss Touit 12mm f/2.8"));
-        choices.insert (p_t (0, "Zeiss Touit 32mm f/1.8"));
-        choices.insert (p_t (0, "Zeiss Touit 50mm f/2.8 Macro"));
-        choices.insert (p_t (0, "Zeiss Loxia 50mm f/2"));
-        choices.insert (p_t (0, "Zeiss Loxia 35mm f/2"));
-        choices.insert (p_t (1, "Sony LA-EA1 or Sigma MC-11 Adapter"));
-        choices.insert (p_t (2, "Sony LA-EA2 Adapter"));
-        choices.insert (p_t (3, "Sony LA-EA3 Adapter"));
-        choices.insert (p_t (6, "Sony LA-EA4 Adapter"));
-        choices.insert (p_t (7, "Sony LA-EA5 Adapter"));
-        choices.insert (p_t (44, "Metabones Canon EF Smart Adapter"));
-        choices.insert (p_t (78, "Metabones Canon EF Smart Adapter Mark III or Other Adapter"));
-        choices.insert (p_t (184, "Metabones Canon EF Speed Booster Ultra"));
-        choices.insert (p_t (234, "Metabones Canon EF Smart Adapter Mark IV"));
-        choices.insert (p_t (239, "Metabones Canon EF Speed Booster"));
-        choices.insert (p_t (24593, "LA-EA4r MonsterAdapter"));
-        choices.insert (p_t (32784, "Sony E 16mm f/2.8"));
-        choices.insert (p_t (32785, "Sony E 18-55mm f/3.5-5.6 OSS"));
-        choices.insert (p_t (32786, "Sony E 55-210mm f/4.5-6.3 OSS"));
-        choices.insert (p_t (32787, "Sony E 18-200mm f/3.5-6.3 OSS"));
-        choices.insert (p_t (32788, "Sony E 30mm f/3.5 Macro"));
-        choices.insert (p_t (32789, "Sony E 24mm f/1.8 ZA or Samyang AF 50mm f/1.4"));
-        choices.insert (p_t (32789, "Samyang AF 50mm f/1.4"));
-        choices.insert (p_t (32790, "Sony E 50mm f/1.8 OSS or Samyang AF 14mm f/2.8"));
-        choices.insert (p_t (32790, "Samyang AF 14mm f/2.8"));
-        choices.insert (p_t (32791, "Sony E 16-70mm f/4 ZA OSS"));
-        choices.insert (p_t (32792, "Sony E 10-18mm f/4 OSS"));
-        choices.insert (p_t (32793, "Sony E PZ 16-50mm f/3.5-5.6 OSS"));
-        choices.insert (p_t (32794, "Sony FE 35mm f/2.8 ZA or Samyang Lens"));
-        choices.insert (p_t (32794, "Samyang AF 24mm f/2.8"));
-        choices.insert (p_t (32794, "Samyang AF 35mm f/2.8"));
-        choices.insert (p_t (32795, "Sony FE 24-70mm f/4 ZA OSS"));
-        choices.insert (p_t (32796, "Sony FE 85mm f/1.8 or Viltrox PFU RBMH 85mm f/1.8"));
-        choices.insert (p_t (32796, "Viltrox PFU RBMH 85mm f/1.8"));
-        choices.insert (p_t (32797, "Sony E 18-200mm f/3.5-6.3 OSS LE"));
-        choices.insert (p_t (32798, "Sony E 20mm f/2.8"));
-        choices.insert (p_t (32799, "Sony E 35mm f/1.8 OSS"));
-        choices.insert (p_t (32800, "Sony E PZ 18-105mm f/4 G OSS"));
-        choices.insert (p_t (32801, "Sony FE 12-24mm f/4 G"));
-        choices.insert (p_t (32802, "Sony FE 90mm f/2.8 Macro G OSS"));
-        choices.insert (p_t (32803, "Sony E 18-50mm f/4-5.6"));
-        choices.insert (p_t (32804, "Sony FE 24mm f/1.4 GM"));
-        choices.insert (p_t (32805, "Sony FE 24-105mm f/4 G OSS"));
-        choices.insert (p_t (32807, "Sony E PZ 18-200mm f/3.5-6.3 OSS"));
-        choices.insert (p_t (32808, "Sony FE 55mm f/1.8 ZA"));
-        choices.insert (p_t (32810, "Sony FE 70-200mm f/4 G OSS"));
-        choices.insert (p_t (32811, "Sony FE 16-35mm f/4 ZA OSS"));
-        choices.insert (p_t (32812, "Sony FE 50mm f/2.8 Macro"));
-        choices.insert (p_t (32813, "Sony FE 28-70mm f/3.5-5.6 OSS"));
-        choices.insert (p_t (32814, "Sony FE 35mm f/1.4 ZA"));
-        choices.insert (p_t (32815, "Sony FE 24-240mm f/3.5-6.3 OSS"));
-        choices.insert (p_t (32816, "Sony FE 28mm f/2"));
-        choices.insert (p_t (32817, "Sony FE PZ 28-135mm f/4 G OSS"));
-        choices.insert (p_t (32819, "Sony FE 100mm f/2.8 STF GM OSS"));
-        choices.insert (p_t (32820, "Sony E PZ 18-110mm f/4 G OSS"));
-        choices.insert (p_t (32821, "Sony FE 24-70mm f/2.8 GM"));
-        choices.insert (p_t (32822, "Sony FE 50mm f/1.4 ZA"));
-        choices.insert (p_t (32823, "Sony FE 85mm f/1.4 GM or Samyang AF 85mm f/1.4"));
-        choices.insert (p_t (32823, "Samyang AF 85mm f/1.4"));
-        choices.insert (p_t (32824, "Sony FE 50mm f/1.8"));
-        choices.insert (p_t (32826, "Sony FE 21mm f/2.8 (SEL28F20 + SEL075UWC)"));
-        choices.insert (p_t (32827, "Sony FE 16mm f/3.5 Fisheye (SEL28F20 + SEL057FEC)"));
-        choices.insert (p_t (32828, "Sony FE 70-300mm f/4.5-5.6 G OSS"));
-        choices.insert (p_t (32829, "Sony FE 100-400mm f/4.5-5.6 GM OSS"));
-        choices.insert (p_t (32830, "Sony FE 70-200mm f/2.8 GM OSS"));
-        choices.insert (p_t (32831, "Sony FE 16-35mm f/2.8 GM"));
-        choices.insert (p_t (32848, "Sony FE 400mm f/2.8 GM OSS"));
-        choices.insert (p_t (32849, "Sony E 18-135mm f/3.5-5.6 OSS"));
-        choices.insert (p_t (32850, "Sony FE 135mm f/1.8 GM"));
-        choices.insert (p_t (32851, "Sony FE 200-600mm f/5.6-6.3 G OSS"));
-        choices.insert (p_t (32852, "Sony FE 600mm f/4 GM OSS"));
-        choices.insert (p_t (32853, "Sony E 16-55mm f/2.8 G"));
-        choices.insert (p_t (32854, "Sony E 70-350mm f/4.5-6.3 G OSS"));
-        choices.insert (p_t (32855, "Sony FE C 16-35mm T3.1 G"));
-        choices.insert (p_t (32858, "Sony FE 35mm f/1.8"));
-        choices.insert (p_t (32859, "Sony FE 20mm f/1.8 G"));
-        choices.insert (p_t (32860, "Sony FE 12-24mm f/2.8 GM"));
-        choices.insert (p_t (32862, "Sony FE 50mm f/1.2 GM"));
-        choices.insert (p_t (32863, "Sony FE 14mm f/1.8 GM"));
-        choices.insert (p_t (32864, "Sony FE 28-60mm f/4-5.6"));
-        choices.insert (p_t (32865, "Sony FE 35mm f/1.4 GM"));
-        choices.insert (p_t (32866, "Sony FE 24mm f/2.8 G"));
-        choices.insert (p_t (32867, "Sony FE 40mm f/2.5 G"));
-        choices.insert (p_t (32868, "Sony FE 50mm f/2.5 G"));
-        choices.insert (p_t (32871, "Sony FE PZ 16-35mm f/4 G"));
-        choices.insert (p_t (32873, "Sony E PZ 10-20mm f/4 G"));
-        choices.insert (p_t (32874, "Sony FE 70-200mm f/2.8 GM OSS II"));
-        choices.insert (p_t (32875, "Sony FE 24-70mm f/2.8 GM II"));
-        choices.insert (p_t (32876, "Sony E 11mm f/1.8"));
-        choices.insert (p_t (32877, "Sony E 15mm f/1.4 G"));
-        choices.insert (p_t (33072, "Sony FE 70-200mm f/2.8 GM OSS + 1.4X Teleconverter"));
-        choices.insert (p_t (33073, "Sony FE 70-200mm f/2.8 GM OSS + 2X Teleconverter"));
-        choices.insert (p_t (33076, "Sony FE 100mm f/2.8 STF GM OSS (macro mode)"));
-        choices.insert (p_t (33077, "Sony FE 100-400mm f/4.5-5.6 GM OSS + 1.4X Teleconverter"));
-        choices.insert (p_t (33078, "Sony FE 100-400mm f/4.5-5.6 GM OSS + 2X Teleconverter"));
-        choices.insert (p_t (33079, "Sony FE 400mm f/2.8 GM OSS + 1.4X Teleconverter"));
-        choices.insert (p_t (33080, "Sony FE 400mm f/2.8 GM OSS + 2X Teleconverter"));
-        choices.insert (p_t (33081, "Sony FE 200-600mm f/5.6-6.3 G OSS + 1.4X Teleconverter"));
-        choices.insert (p_t (33082, "Sony FE 200-600mm f/5.6-6.3 G OSS + 2X Teleconverter"));
-        choices.insert (p_t (33083, "Sony FE 600mm f/4 GM OSS + 1.4X Teleconverter"));
-        choices.insert (p_t (33084, "Sony FE 600mm f/4 GM OSS + 2X Teleconverter"));
-        choices.insert (p_t (49201, "Zeiss Touit 12mm f/2.8"));
-        choices.insert (p_t (49202, "Zeiss Touit 32mm f/1.8"));
-        choices.insert (p_t (49203, "Zeiss Touit 50mm f/2.8 Macro"));
-        choices.insert (p_t (49216, "Zeiss Batis 25mm f/2"));
-        choices.insert (p_t (49217, "Zeiss Batis 85mm f/1.8"));
-        choices.insert (p_t (49218, "Zeiss Batis 18mm f/2.8"));
-        choices.insert (p_t (49219, "Zeiss Batis 135mm f/2.8"));
-        choices.insert (p_t (49220, "Zeiss Batis 40mm f/2 CF"));
-        choices.insert (p_t (49232, "Zeiss Loxia 50mm f/2"));
-        choices.insert (p_t (49233, "Zeiss Loxia 35mm f/2"));
-        choices.insert (p_t (49234, "Zeiss Loxia 21mm f/2.8"));
-        choices.insert (p_t (49235, "Zeiss Loxia 85mm f/2.4"));
-        choices.insert (p_t (49236, "Zeiss Loxia 25mm f/2.4"));
-        choices.insert (p_t (49457, "Tamron 28-75mm f/2.8 Di III RXD"));
-        choices.insert (p_t (49458, "Tamron 17-28mm f/2.8 Di III RXD"));
-        choices.insert (p_t (49459, "Tamron 35mm f/2.8 Di III OSD M1:2"));
-        choices.insert (p_t (49460, "Tamron 24mm f/2.8 Di III OSD M1:2"));
-        choices.insert (p_t (49461, "Tamron 20mm f/2.8 Di III OSD M1:2"));
-        choices.insert (p_t (49462, "Tamron 70-180mm f/2.8 Di III VXD"));
-        choices.insert (p_t (49463, "Tamron 28-200mm f/2.8-5.6 Di III RXD"));
-        choices.insert (p_t (49464, "Tamron 70-300mm f/4.5-6.3 Di III RXD"));
-        choices.insert (p_t (49465, "Tamron 17-70mm f/2.8 Di III-A VC RXD"));
-        choices.insert (p_t (49466, "Tamron 150-500mm f/5-6.7 Di III VC VXD"));
-        choices.insert (p_t (49467, "Tamron 11-20mm f/2.8 Di III-A RXD"));
-        choices.insert (p_t (49468, "Tamron 18-300mm f/3.5-6.3 Di III-A VC VXD"));
-        choices.insert (p_t (49469, "Tamron 35-150mm f/2-F2.8 Di III VXD"));
-        choices.insert (p_t (49470, "Tamron 28-75mm f/2.8 Di III VXD G2"));
-        choices.insert (p_t (49471, "Tamron 50-400mm f/4.5-6.3 Di III VC VXD"));
-        choices.insert (p_t (49473, "Tokina atx-m 85mm f/1.8 FE or Viltrox lens"));
-        choices.insert (p_t (49473, "Viltrox 23mm f/1.4 E"));
-        choices.insert (p_t (49473, "Viltrox 56mm f/1.4 E"));
-        choices.insert (p_t (49712, "Tokina FiRIN 20mm f/2 FE AF"));
-        choices.insert (p_t (49713, "Tokina FiRIN 100mm f/2.8 FE MACRO"));
-        choices.insert (p_t (50480, "Sigma 30mm f/1.4 DC DN | C"));
-        choices.insert (p_t (50481, "Sigma 50mm f/1.4 DG HSM | A"));
-        choices.insert (p_t (50482, "Sigma 18-300mm f/3.5-6.3 DC MACRO OS HSM | C + MC-11"));
-        choices.insert (p_t (50483, "Sigma 18-35mm f/1.8 DC HSM | A + MC-11"));
-        choices.insert (p_t (50484, "Sigma 24-35mm f/2 DG HSM | A + MC-11"));
-        choices.insert (p_t (50485, "Sigma 24mm f/1.4 DG HSM | A + MC-11"));
-        choices.insert (p_t (50486, "Sigma 150-600mm f/5-6.3 DG OS HSM | C + MC-11"));
-        choices.insert (p_t (50487, "Sigma 20mm f/1.4 DG HSM | A + MC-11"));
-        choices.insert (p_t (50488, "Sigma 35mm f/1.4 DG HSM | A"));
-        choices.insert (p_t (50489, "Sigma 150-600mm f/5-6.3 DG OS HSM | S + MC-11"));
-        choices.insert (p_t (50490, "Sigma 120-300mm f/2.8 DG OS HSM | S + MC-11"));
-        choices.insert (p_t (50492, "Sigma 24-105mm f/4 DG OS HSM | A + MC-11"));
-        choices.insert (p_t (50493, "Sigma 17-70mm f/2.8-4 DC MACRO OS HSM | C + MC-11"));
-        choices.insert (p_t (50495, "Sigma 50-100mm f/1.8 DC HSM | A + MC-11"));
-        choices.insert (p_t (50499, "Sigma 85mm f/1.4 DG HSM | A"));
-        choices.insert (p_t (50501, "Sigma 100-400mm f/5-6.3 DG OS HSM | C + MC-11"));
-        choices.insert (p_t (50503, "Sigma 16mm f/1.4 DC DN | C"));
-        choices.insert (p_t (50507, "Sigma 105mm f/1.4 DG HSM | A"));
-        choices.insert (p_t (50508, "Sigma 56mm f/1.4 DC DN | C"));
-        choices.insert (p_t (50512, "Sigma 70-200mm f/2.8 DG OS HSM | S + MC-11"));
-        choices.insert (p_t (50513, "Sigma 70mm f/2.8 DG MACRO | A"));
-        choices.insert (p_t (50514, "Sigma 45mm f/2.8 DG DN | C"));
-        choices.insert (p_t (50515, "Sigma 35mm f/1.2 DG DN | A"));
-        choices.insert (p_t (50516, "Sigma 14-24mm f/2.8 DG DN | A"));
-        choices.insert (p_t (50517, "Sigma 24-70mm f/2.8 DG DN | A"));
-        choices.insert (p_t (50518, "Sigma 100-400mm f/5-6.3 DG DN OS | C"));
-        choices.insert (p_t (50521, "Sigma 85mm f/1.4 DG DN | A"));
-        choices.insert (p_t (50522, "Sigma 105mm f/2.8 DG DN MACRO | A"));
-        choices.insert (p_t (50523, "Sigma 65mm f/2 DG DN | C"));
-        choices.insert (p_t (50524, "Sigma 35mm f/2 DG DN | C"));
-        choices.insert (p_t (50525, "Sigma 24mm f/3.5 DG DN | C"));
-        choices.insert (p_t (50526, "Sigma 28-70mm f/2.8 DG DN | C"));
-        choices.insert (p_t (50527, "Sigma 150-600mm f/5-6.3 DG DN OS | S"));
-        choices.insert (p_t (50528, "Sigma 35mm f/1.4 DG DN | A"));
-        choices.insert (p_t (50529, "Sigma 90mm f/2.8 DG DN | C"));
-        choices.insert (p_t (50530, "Sigma 24mm f/2 DG DN | C"));
-        choices.insert (p_t (50531, "Sigma 18-50mm f/2.8 DC DN | C"));
-        choices.insert (p_t (50532, "Sigma 20mm f/2 DG DN | C"));
-        choices.insert (p_t (50533, "Sigma 16-28mm f/2.8 DG DN | C"));
-        choices.insert (p_t (50992, "Voigtlander SUPER WIDE-HELIAR 15mm f/4.5 III"));
-        choices.insert (p_t (50993, "Voigtlander HELIAR-HYPER WIDE 10mm f/5.6"));
-        choices.insert (p_t (50994, "Voigtlander ULTRA WIDE-HELIAR 12mm f/5.6 III"));
-        choices.insert (p_t (50995, "Voigtlander MACRO APO-LANTHAR 65mm f/2 Aspherical"));
-        choices.insert (p_t (50996, "Voigtlander NOKTON 40mm f/1.2 Aspherical"));
-        choices.insert (p_t (50997, "Voigtlander NOKTON classic 35mm f/1.4"));
-        choices.insert (p_t (50998, "Voigtlander MACRO APO-LANTHAR 110mm f/2.5"));
-        choices.insert (p_t (50999, "Voigtlander COLOR-SKOPAR 21mm f/3.5 Aspherical"));
-        choices.insert (p_t (51000, "Voigtlander NOKTON 50mm f/1.2 Aspherical"));
-        choices.insert (p_t (51001, "Voigtlander NOKTON 21mm f/1.4 Aspherical"));
-        choices.insert (p_t (51002, "Voigtlander APO-LANTHAR 50mm f/2 Aspherical"));
-        choices.insert (p_t (51003, "Voigtlander NOKTON 35mm f/1.2 Aspherical SE"));
-        choices.insert (p_t (51006, "Voigtlander APO-LANTHAR 35mm f/2 Aspherical"));
-        choices.insert (p_t (51504, "Samyang AF 50mm f/1.4"));
-        choices.insert (p_t (51505, "Samyang AF 14mm f/2.8 or Samyang AF 35mm f/2.8"));
-        choices.insert (p_t (51505, "Samyang AF 35mm f/2.8"));
-        choices.insert (p_t (51507, "Samyang AF 35mm f/1.4"));
-        choices.insert (p_t (51508, "Samyang AF 45mm f/1.8"));
-        choices.insert (p_t (51510, "Samyang AF 18mm f/2.8 or Samyang AF 35mm f/1.8"));
-        choices.insert (p_t (51510, "Samyang AF 35mm f/1.8"));
-        choices.insert (p_t (51512, "Samyang AF 75mm f/1.8"));
-        choices.insert (p_t (51513, "Samyang AF 35mm f/1.8"));
-        choices.insert (p_t (51514, "Samyang AF 24mm f/1.8"));
-        choices.insert (p_t (51515, "Samyang AF 12mm f/2.0"));
-        choices.insert (p_t (51516, "Samyang AF 24-70mm f/2.8"));
-        choices.insert (p_t (51517, "Samyang AF 50mm f/1.4 II"));
-        choices.insert (p_t (51518, "Samyang AF 135mm f/1.8"));
-    }
-
-    std::string toString (const Tag* t) const override
-    {
-        int lensID = t->toInt();
-        Tag *lensInfoTag = t->getParent()->getRoot()->findTag ("LensInfo");
-        Tag *apertureTag = t->getParent()->getRoot()->findTag ("MaxApertureValue");
-        Tag *focalLengthTag = t->getParent()->getRoot()->findTag ("FocalLength");
-        double maxApertureAtFocal = 0.;
-        double focalLength = 0.;
-
-        if ( apertureTag ) {
-            maxApertureAtFocal = pow (2.0, apertureTag->toDouble() / 2.0);
-        }
-
-        if ( focalLengthTag ) {
-            focalLength = focalLengthTag->toDouble();
-        }
-
-        double *liArray = nullptr;
-
-        if (lensInfoTag) {
-            liArray = lensInfoTag->toDoubleArray();
-        }
-
-        std::string retval = guess ( lensID, focalLength, maxApertureAtFocal, liArray);
-
-        if (liArray) {
-            delete [] liArray;
-        }
-
-        return retval;
-    }
-};
-SALensID2Interpreter saLensID2Interpreter;
-
-class MATeleconverterInterpreter : public ChoiceInterpreter<>
-{
-public:
-    MATeleconverterInterpreter ()
-    {
-        choices[0x0]  = "None";
-        choices[0x4]  = "Minolta/Sony AF 1.4x APO (D) (0x04)";
-        choices[0x5]  = "Minolta/Sony AF 2x APO (D) (0x05)";
-        choices[0x48] = "Minolta/Sony AF 2x APO (D)";
-        choices[0x50] = "Minolta AF 2x APO II";
-        choices[0x60] = "Minolta AF 2x APO";
-        choices[0x88] = "Minolta/Sony AF 1.4x APO (D)";
-        choices[0x90] = "Minolta AF 1.4x APO II";
-        choices[0xa0] = "Minolta AF 1.4x APO";
-    }
-};
-MATeleconverterInterpreter maTeleconverterInterpreter;
-
-class MAQualityInterpreter : public ChoiceInterpreter<>
-{
-public:
-    MAQualityInterpreter ()
-    {
-        choices[0] = "RAW";
-        choices[1] = "Super Fine";
-        choices[2] = "Fine";
-        choices[3] = "Standard";
-        choices[4] = "Economy";
-        choices[5] = "Extra Fine";
-        choices[6] = "RAW + JPEG";
-        choices[7] = "Compressed RAW";
-        choices[8] = "Compressed RAW + JPEG";
-    }
-};
-MAQualityInterpreter maQualityInterpreter;
-
-class MAImageSizeInterpreter : public ChoiceInterpreter<>
-{
-public:
-    MAImageSizeInterpreter ()
-    {
-        choices[1]  = "1600x1200";
-        choices[2]  = "1280x960";
-        choices[3]  = "640x480";
-        choices[5]  = "2560x1920";
-        choices[6]  = "2272x1704";
-        choices[7]  = "2048x1536";
-    }
-};
-MAImageSizeInterpreter maImageSizeInterpreter;
-
-class SAQualityInterpreter2 : public ChoiceInterpreter<>
-{
-public:
-    SAQualityInterpreter2 ()
-    {
-        choices[0]  = "Raw";
-        choices[2]  = "cRAW";
-        choices[16] = "Extra fine";
-        choices[32]  = "Fine";
-        choices[34]  = "RAW + JPEG";
-        choices[35]  = "cRAW + JPEG";
-        choices[48]  = "Standard";
-    }
-};
-SAQualityInterpreter2 saQualityInterpreter2;
-
-class SAQualityInterpreter3 : public ChoiceInterpreter<>
-{
-public:
-    SAQualityInterpreter3 ()
-    {
-        choices[2]  = "RAW";
-        choices[4]  = "RAW + JPEG";
-        choices[6]  = "Fine";
-        choices[7]  = "Standard";
-    }
-};
-SAQualityInterpreter3 saQualityInterpreter3;
-
-class SADriveMode : public ChoiceInterpreter<>
-{
-public:
-    SADriveMode ()
-    {
-        choices[1]  = "Single Frame";
-        choices[2]  = "Continuous High";
-        choices[4]  = "Self-timer 10 sec";
-        choices[5]  = "Self-timer 2 sec, Mirror Lock-up";
-        choices[6]  = "Single-frame Bracketing";
-        choices[7]  = "Continuous Bracketing";
-        choices[10] = "Remote Commander";
-        choices[11] = "Mirror Lock-up";
-        choices[18] = "Continuous Low";
-        choices[24] = "White Balance Bracketing Low";
-        choices[25] = "D-Range Optimizer Bracketing Low";
-        choices[40] = "White Balance Bracketing High";
-        choices[41] = "D-Range Optimizer Bracketing High";
-    }
-};
-SADriveMode saDriveMode;
-
-class SADriveMode2 : public ChoiceInterpreter<>
-{
-public:
-    SADriveMode2 ()
-    {
-        choices[1]  = "Single Frame";
-        choices[2]  = "Continuous High";
-        choices[4]  = "Self-timer 10 sec";
-        choices[5]  = "Self-timer 2 sec, Mirror Lock-up";
-        choices[7]  = "Continuous Bracketing";
-        choices[10] = "Remote Commander";
-        choices[11] = "Continuous Self-timer";
-    }
-};
-SADriveMode2 saDriveMode2;
-
-class SADriveMode3 : public ChoiceInterpreter<>
-{
-public:
-    SADriveMode3 ()
-    {
-        choices[16]  = "Single Frame";
-        choices[33]  = "Continuous High";
-        choices[34]  = "Continuous Low";
-        choices[48]  = "Speed Priority Continuous";
-        choices[81]  = "Self-timer 10 sec";
-        choices[82]  = "Self-timer 2 sec, Mirror Lock-up";
-        choices[113] = "Continuous Bracketing 0.3 EV";
-        choices[117] = "Continuous Bracketing 0.7 EV";
-        choices[145] = "White Balance Bracketing Low";
-        choices[146] = "White Balance Bracketing High";
-        choices[192] = "Remote Commander";
-        choices[209] = "Continuous - HDR";
-        choices[210] = "Continuous - Multi Frame NR";
-        choices[211] = "Continuous - Handheld Night Shot";
-        choices[212] = "Continuous - Anti Motion Blur";
-        choices[213] = "Continuous - Sweep Panorama";
-        choices[214] = "Continuous - 3D Sweep Panorama";
-    }
-};
-SADriveMode3 saDriveMode3;
-
-class SAFocusMode: public ChoiceInterpreter<>
-{
-public:
-    SAFocusMode ()
-    {
-        choices[0]  = "Manual";
-        choices[1]  = "AF-S";
-        choices[2]  = "AF-C";
-        choices[3]  = "AF-A";
-        choices[4]  = "Permanent-AF";
-        choices[65535] = "n/a";
-    }
-};
-SAFocusMode saFocusMode;
-
-class SAFocusMode2: public ChoiceInterpreter<>
-{
-public:
-    SAFocusMode2 ()
-    {
-        choices[0]  = "Manual";
-        choices[1]  = "AF-S";
-        choices[2]  = "AF-C";
-        choices[3]  = "AF-A";
-        choices[65535] = "n/a";
-    }
-};
-SAFocusMode2 saFocusMode2;
-
-class SAFocusModeSetting3: public ChoiceInterpreter<>
-{
-public:
-    SAFocusModeSetting3 ()
-    {
-        choices[17]  = "AF-S";
-        choices[18]  = "AF-C";
-        choices[19]  = "AF-A";
-        choices[32]  = "Manual";
-        choices[48]  = "DMF";
-        choices[65535] = "n/a";
-    }
-};
-SAFocusModeSetting3 saFocusModeSetting3;
-
-class SAAFMode: public ChoiceInterpreter<>
-{
-public:
-    SAAFMode()
-    {
-        choices[0] = "Default";
-        choices[1] = "Multi AF";
-        choices[2] = "Center AF";
-        choices[3] = "Spot AF";
-        choices[4] = "Flexible Spot AF";
-        choices[6] = "Touch AF";
-        choices[14] = "Tracking";
-        choices[15] = "Face Tracking";
-        choices[65535] = "n/a";
-    }
-};
-SAAFMode saAFMode;
-
-class SAAFAreaMode: public ChoiceInterpreter<>
-{
-public:
-    SAAFAreaMode ()
-    {
-        choices[0]  = "Wide";
-        choices[1]  = "Local";
-        choices[2]  = "Spot";
-    }
-};
-SAAFAreaMode saAFAreaMode;
-
-class SAAFAreaMode2: public ChoiceInterpreter<>
-{
-public:
-    SAAFAreaMode2 ()
-    {
-        choices[1]  = "Wide";
-        choices[2]  = "Spot";
-        choices[3]  = "Local";
-        choices[4]  = "Flexible";
-    }
-};
-SAAFAreaMode2 saAFAreaMode2;
-
-class SAAFPointSelected: public ChoiceInterpreter<>
-{
-public:
-    SAAFPointSelected ()
-    {
-        choices[1] = "Center";
-        choices[2] = "Top";
-        choices[3] = "Top-Right";
-        choices[4] = "Right";
-        choices[5] = "Bottom-Right";
-        choices[6] = "Bottom";
-        choices[7] = "Bottom-Left";
-        choices[8] = "Left";
-        choices[9] = "Top-Left";
-        choices[10] = "Far Right";
-        choices[11] = "Far Left";
-    }
-};
-SAAFPointSelected saAFPointSelected;
-
-class SACameraInfoAFPointSelected: public ChoiceInterpreter<>
-{
-public:
-    SACameraInfoAFPointSelected ()
-    {
-        choices[0] = "Auto";
-        choices[1] = "Center";
-        choices[2] = "Top";
-        choices[3] = "Upper-Right";
-        choices[4] = "Right";
-        choices[5] = "Lower-Right";
-        choices[6] = "Bottom";
-        choices[7] = "Lower-Left";
-        choices[8] = "Left";
-        choices[9] = "Upper-Left";
-        choices[10] = "Far Right";
-        choices[11] = "Far Left";
-        choices[12] = "Upper-middle";
-        choices[13] = "Near Right";
-        choices[14] = "Lower-middle";
-        choices[15] = "Near Left";
-    }
-};
-SACameraInfoAFPointSelected saCameraInfoAFPointSelected;
-
-class SACameraInfoAFPoint: public ChoiceInterpreter<>
-{
-public:
-    SACameraInfoAFPoint ()
-    {
-        choices[0] = "Upper-Left";
-        choices[1] = "Left";
-        choices[2] = "Lower-Left";
-        choices[3] = "Far Left";
-        choices[4] = "Top (horizontal)";
-        choices[5] = "Near Right";
-        choices[6] = "Center (horizontal)";
-        choices[7] = "Near Left";
-        choices[8] = "Bottom (horizontal)";
-        choices[9] = "Top (vertical)";
-        choices[10] = "Center (vertical)";
-        choices[11] = "Bottom (vertical)";
-        choices[12] = "Far Right";
-        choices[13] = "Upper-Right";
-        choices[14] = "Right";
-        choices[15] = "Lower-Right";
-        choices[16] = "Upper-middle";
-        choices[17] = "Lower-middle";
-        choices[255] = "(none)";
-    }
-};
-SACameraInfoAFPoint saCameraInfoAFPoint;
-
-class SAAFPointSelected2: public ChoiceInterpreter<>
-{
-public:
-    SAAFPointSelected2 ()
-    {
-        choices[1] = "Center";
-        choices[2] = "Top";
-        choices[3] = "Top-Right";
-        choices[4] = "Right";
-        choices[5] = "Bottom-Right";
-        choices[6] = "Bottom";
-        choices[7] = "Bottom-Left";
-        choices[8] = "Left";
-        choices[9] = "Top-Left";
-    }
-};
-SAAFPointSelected2 saAFPointSelected2;
-
-class SAMeteringMode0_3: public ChoiceInterpreter<>
-{
-public:
-    SAMeteringMode0_3 ()
-    {
-        choices[0] = "Multi-segment";
-        choices[2] = "Center-weighted Average";
-        choices[3] = "Spot";
-    }
-};
-SAMeteringMode0_3 saMeteringMode0_3;
-
-class SAMeteringMode1_3: public ChoiceInterpreter<>
-{
-public:
-    SAMeteringMode1_3 ()
-    {
-        choices[1] = "Multi-segment";
-        choices[2] = "Center-weighted Average";
-        choices[3] = "Spot";
-    }
-};
-SAMeteringMode1_3 saMeteringMode1_3;
-
-class SAMeteringMode1_4: public ChoiceInterpreter<>
-{
-public:
-    SAMeteringMode1_4 ()
-    {
-        choices[1] = "Multi-segment";
-        choices[2] = "Center-weighted Average";
-        choices[4] = "Spot";
-    }
-};
-SAMeteringMode1_4 saMeteringMode1_4;
-
-class SADynamicRangeOptimizerMode: public ChoiceInterpreter<>
-{
-public:
-    SADynamicRangeOptimizerMode ()
-    {
-        choices[0] = "Off";
-        choices[1] = "Standard";
-        choices[2] = "Advanced Auto";
-        choices[3] = "Advanced Level";
-        choices[4097] = "Auto";
-    }
-};
-SADynamicRangeOptimizerMode saDynamicRangeOptimizerMode;
-
-class SADynamicRangeOptimizerSetting: public ChoiceInterpreter<>
-{
-public:
-    SADynamicRangeOptimizerSetting ()
-    {
-        choices[1] = "Off";
-        choices[2] = "On (Auto)";
-        choices[3] = "On (Manual)";
-    }
-};
-SADynamicRangeOptimizerSetting saDynamicRangeOptimizerSetting;
-
-class SACreativeStyle: public ChoiceInterpreter<>
-{
-public:
-    SACreativeStyle ()
-    {
-        choices[1] = "Standard";
-        choices[2] = "Vivid";
-        choices[3] = "Portrait";
-        choices[4] = "Landscape";
-        choices[5] = "Sunset";
-        choices[6] = "Night View/Portrait";
-        choices[8] = "B&W";
-        choices[9] = "Adobe RGB";
-        choices[11] = "Neutral";
-        choices[12] = "Clear";
-        choices[13] = "Deep";
-        choices[14] = "Light";
-        choices[15] = "Autumn Leaves";
-        choices[16] = "Sepia";
-    }
-};
-SACreativeStyle saCreativeStyle;
-
-class SACreativeStyle2: public ChoiceInterpreter<>
-{
-public:
-    SACreativeStyle2 ()
-    {
-        choices[1] = "Standard";
-        choices[2] = "Vivid";
-        choices[3] = "Portrait";
-        choices[4] = "Landscape";
-        choices[5] = "Sunset";
-        choices[6] = "Night View/Portrait";
-        choices[8] = "B&W";
-    }
-};
-SACreativeStyle2 saCreativeStyle2;
-
-class SACreativeStyleSetting: public ChoiceInterpreter<>
-{
-public:
-    SACreativeStyleSetting ()
-    {
-        choices[16]  = "Standard";
-        choices[32]  = "Vivid";
-        choices[64]  = "Portrait";
-        choices[80]  = "Landscape";
-        choices[96]  = "B&W";
-        choices[160] = "Sunset";
-    }
-};
-SACreativeStyleSetting saCreativeStyleSetting;
-
-class SAFlashControl: public ChoiceInterpreter<>
-{
-public:
-    SAFlashControl ()
-    {
-        choices[1] = "ADI Flash";
-        choices[2] = "Pre-flash TTL";
-    }
-};
-SAFlashControl saFlashControl;
-
-class SAFlashMode: public ChoiceInterpreter<>
-{
-public:
-    SAFlashMode ()
-    {
-        choices[0] = "ADI";
-        choices[1] = "TTL";
-    }
-};
-SAFlashMode saFlashMode;
-
-class SAFlashMode2: public ChoiceInterpreter<>
-{
-public:
-    SAFlashMode2 ()
-    {
-        choices[1] = "Flash Off";
-        choices[16] = "Autoflash";
-        choices[17] = "Fill-flash";
-        choices[18] = "Slow Sync";
-        choices[19] = "Rear Sync";
-        choices[20] = "Wireless";
-    }
-};
-SAFlashMode2 saFlashMode2;
-
-class SAExposureProgram: public ChoiceInterpreter<>
-{
-public:
-    SAExposureProgram ()
-    {
-        choices[0] = "Auto";
-        choices[1] = "Manual";
-        choices[2] = "Program AE";
-        choices[3] = "Aperture-priority AE";
-        choices[4] = "Shutter speed priority AE";
-        choices[8] = "Program Shift A";
-        choices[9] = "Program Shift S";
-        choices[16] = "Portrait";
-        choices[17] = "Sports";
-        choices[18] = "Sunset";
-        choices[19] = "Night Portrait";
-        choices[20] = "Landscape";
-        choices[21] = "Macro";
-        choices[35] = "Auto No Flash";
-    }
-};
-SAExposureProgram saExposureProgram;
-
-class SAExposureProgram2: public ChoiceInterpreter<>
-{
-public:
-    SAExposureProgram2 ()
-    {
-        choices[1]   = "Program AE";
-        choices[2]   = "Aperture-priority AE";
-        choices[3]   = "Shutter speed priority AE";
-        choices[4]   = "Manual";
-        choices[5]   = "Cont. Priority AE";
-        choices[16]  = "Auto";
-        choices[17]  = "Auto (no flash)";
-        choices[18]  = "Auto+";
-        choices[49]  = "Portrait";
-        choices[50]  = "Landscape";
-        choices[51]  = "Macro";
-        choices[52]  = "Sports";
-        choices[53]  = "Sunset";
-        choices[54]  = "Night view";
-        choices[55]  = "Night view/portrait";
-        choices[56]  = "Handheld Night Shot";
-        choices[57]  = "3D Sweep Panorama";
-        choices[64]  = "Auto 2";
-        choices[65]  = "Auto 2 (no flash)";
-        choices[80]  = "Sweep Panorama";
-        choices[96]  = "Anti Motion Blur";
-        choices[128] = "Toy Camera";
-        choices[129] = "Pop Color";
-        choices[130] = "Posterization";
-        choices[131] = "Posterization B/W";
-        choices[132] = "Retro Photo";
-        choices[133] = "High-key";
-        choices[134] = "Partial Color Red";
-        choices[135] = "Partial Color Green";
-        choices[136] = "Partial Color Blue";
-        choices[137] = "Partial Color Yellow";
-        choices[138] = "High Contrast Monochrome";
-    }
-};
-SAExposureProgram2 saExposureProgram2;
-
-class SARotation: public ChoiceInterpreter<>
-{
-public:
-    SARotation ()
-    {
-        choices[0] = "Horizontal";
-        choices[1] = "Rotate 90 CW";
-        choices[2] = "Rotate 270 CW";
-        choices[3] = "None";
-    }
-};
-SARotation saRotation;
-
-class SASonyImageSize: public ChoiceInterpreter<>
-{
-public:
-    SASonyImageSize ()
-    {
-        choices[1] = "Large";
-        choices[2] = "Medium";
-        choices[3] = "Small";
-    }
-};
-SASonyImageSize saSonyImageSize;
-
-class SASonyImageSize3: public ChoiceInterpreter<>
-{
-public:
-    SASonyImageSize3 ()
-    {
-        choices[21] = "Large (3:2)";
-        choices[22] = "Medium (3:2)";
-        choices[23] = "Small (3:2)";
-        choices[25] = "Large (16:9)";
-        choices[26] = "Medium (16:9) ";
-        choices[27] = "Small (16:9)";
-    }
-};
-SASonyImageSize3 saSonyImageSize3;
-
-class SAAspectRatio: public ChoiceInterpreter<>
-{
-public:
-    SAAspectRatio ()
-    {
-        choices[1] = "3:2";
-        choices[2] = "16:9";
-    }
-};
-SAAspectRatio saAspectRatio;
-
-class SAAspectRatio2: public ChoiceInterpreter<>
-{
-public:
-    SAAspectRatio2 ()
-    {
-        choices[4] = "3:2";
-        choices[8] = "16:9";
-    }
-};
-SAAspectRatio2 saAspectRatio2;
-
-class SAExposureLevelIncrements: public ChoiceInterpreter<>
-{
-public:
-    SAExposureLevelIncrements ()
-    {
-        choices[33] = "1/3 EV";
-        choices[50] = "1/2 EV";
-    }
-};
-SAExposureLevelIncrements saExposureLevelIncrements;
-
-class SAAFIlluminator: public ChoiceInterpreter<>
-{
-public:
-    SAAFIlluminator ()
-    {
-        choices[0] = "Off";
-        choices[1] = "Auto";
-        choices[65535] = "n/a";
-    }
-};
-SAAFIlluminator saAFIlluminator;
-
-class SAColorSpace1_2: public ChoiceInterpreter<>
-{
-public:
-    SAColorSpace1_2 ()
-    {
-        choices[1] = "sRGB";
-        choices[2] = "AdobeRGB";
-    }
-};
-SAColorSpace1_2 saColorSpace1_2;
-
-class SAColorSpace0_5: public ChoiceInterpreter<>
-{
-public:
-    SAColorSpace0_5 ()
-    {
-        choices[0] = "sRGB";
-        choices[1] = "AdobeRGB";
-        choices[5] = "AdobeRGB";
-    }
-};
-SAColorSpace0_5 saColorSpace0_5;
-
-class SAColorSpace5_6: public ChoiceInterpreter<>
-{
-public:
-    SAColorSpace5_6 ()
-    {
-        choices[5] = "AdobeRGB";
-        choices[6] = "sRGB";
-    }
-};
-SAColorSpace5_6 saColorSpace5_6;
-
-class SAReleaseModeInterpreter: public ChoiceInterpreter<>
-{
-public:
-    SAReleaseModeInterpreter ()
-    {
-        choices[0] = "Normal";
-        choices[2] = "Continuous";
-        choices[5] = "Exposure Bracketing";
-        choices[6] = "White Balance Bracketing";
-        choices[8] = "DRO Bracketing";
-        choices[65535] = "n/a";
-    }
-};
-SAReleaseModeInterpreter saReleaseModeInterpreter;
-
-class SAImageStyleInterpreter: public ChoiceInterpreter<>
-{
-public:
-    SAImageStyleInterpreter ()
-    {
-        choices[1] = "Standard";
-        choices[2] = "Vivid";
-        choices[3] = "Portrait";
-        choices[4] = "Landscape";
-        choices[5] = "Sunset";
-        choices[7] = "Night View/Portrait";
-        choices[8] = "B&W";
-        choices[9] = "Adobe RGB";
-        choices[11] = "Neutral";
-        choices[129] = "StyleBox1";
-        choices[130] = "StyleBox2";
-        choices[131] = "StyleBox3";
-        choices[132] = "StyleBox4";
-        choices[133] = "StyleBox5";
-        choices[134] = "StyleBox6";
-    }
-};
-SAImageStyleInterpreter saImageStyleInterpreter;
-
-class SAPictureEffectInterpreter: public ChoiceInterpreter<>
-{
-public:
-    SAPictureEffectInterpreter()
-    {
-        choices[0]  = "Off";
-        choices[1]  = "Toy Camera";
-        choices[2]  = "Pop Color";
-        choices[3]  = "Posterization";
-        choices[4]  = "Posterization B/W";
-        choices[5]  = "Retro Photo";
-        choices[6]  = "Soft High Key";
-        choices[7]  = "Partial Color (red)";
-        choices[8]  = "Partial Color (green)";
-        choices[9]  = "Partial Color (blue)";
-        choices[10] = "Partial Color (yellow)";
-        choices[13] = "High Contrast Monochrome";
-        choices[16] = "Toy Camera (normal)";
-        choices[17] = "Toy Camera (cool)";
-        choices[18] = "Toy Camera (warm)";
-        choices[19] = "Toy Camera (green)";
-        choices[20] = "Toy Camera (magenta)";
-        choices[32] = "Soft Focus (low)";
-        choices[33] = "Soft Focus";
-        choices[34] = "Soft Focus (high)";
-        choices[48] = "Miniature (auto)";
-        choices[49] = "Miniature (top)";
-        choices[50] = "Miniature (middle horizontal)";
-        choices[51] = "Miniature (bottom)";
-        choices[52] = "Miniature (left)";
-        choices[53] = "Miniature (middle vertical)";
-        choices[54] = "Miniature (right)";
-        choices[64] = "HDR Painting (low)";
-        choices[65] = "HDR Painting";
-        choices[66] = "HDR Painting (high)";
-        choices[80] = "Rich-tone Monochrome";
-        choices[97] = "Water Color";
-        choices[98] = "Water Color 2";
-        choices[112] = "Illustration (low)";
-        choices[113] = "Illustration";
-        choices[114] = "Illustration (high)";
-    }
-};
-SAPictureEffectInterpreter saPictureEffectInterpreter;
-
-class SACameraInfoFocusStatusInterpreter : public ChoiceInterpreter<>
-{
-public:
-    SACameraInfoFocusStatusInterpreter()
-    {
-        choices[0] = "Manual - Not confirmed (0)";
-        choices[4] = "Manual - Not confirmed (4)";
-        choices[16] = "AF-C - Confirmed";
-        choices[24] = "AF-C - Not Confirmed";
-        choices[64] = "AF-S - Confirmed";
-    }
-};
-SACameraInfoFocusStatusInterpreter saCameraInfoFocusStatusInterpreter;
-
-class SAExposureTimeInterpreter : public Interpreter
-{
-public:
-    SAExposureTimeInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        double a = t->toDouble();
-
-        if (a > 0) {
-            char buffer[32];
-            snprintf(buffer, sizeof(buffer), "%.4f", a);
-            return buffer;
-        } else {
-            return "n/a";
-        }
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        // Get the value; Depending on the camera model, this parameter can be a BYTE or a SHORT
-        TagType astype = t->getType();
-        int a = 0;
-
-        if (astype == BYTE) {
-            a = t->getValue()[ofs];
-        } else if (astype == SHORT) {
-            a = (int)sget2 (t->getValue() + ofs, t->getOrder());
-        }
-
-        // Decode the value
-        if (a > 0) {
-            return pow (2., 6. - (double (a) / 8.));
-        } else {
-            return 0.;
-        }
-    }
-    int toInt (const Tag* t, int ofs, TagType astype) override
-    {
-        // Get the value; Depending on the camera model, this parameter can be a BYTE or a SHORT
-        int a = 0;
-
-        if (astype == INVALID || astype == AUTO) {
-            astype = t->getType();
-        }
-
-        if (astype == BYTE) {
-            a = t->getValue()[ofs];
-        } else if (astype == SHORT) {
-            a = (int)sget2 (t->getValue() + ofs, t->getOrder());
-        }
-
-        // Decode the value
-        if (a) {
-            return int (powf (2.f, 6.f - (float (a) / 8.f)) + 0.5f);
-        } else {
-            return 0;
-        }
-    }
-};
-SAExposureTimeInterpreter saExposureTimeInterpreter;
-
-class SAFNumberInterpreter : public Interpreter
-{
-public:
-    SAFNumberInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        double a = double (t->toDouble());
-
-        if (a) {
-            char buffer[32];
-            snprintf(buffer, sizeof(buffer), "%.1f", a / 100. );
-            return buffer;
-        } else {
-            return "n/a";
-        }
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        // Get the value; Depending on the camera model, this parameter can be a BYTE or a SHORT
-        TagType astype = t->getType();
-        int a = 0;
-
-        if (astype == BYTE) {
-            a = t->getValue()[ofs];
-        } else if (astype == SHORT) {
-            a = (int)sget2 (t->getValue() + ofs, t->getOrder());
-        }
-
-        // Decode the value
-        if (a > 0) {
-            return pow (2., (double (a) / 8. - 1.) / 2.);
-        } else {
-            return 0.;
-        }
-    }
-    int toInt (const Tag* t, int ofs, TagType astype) override
-    {
-        // Get the value; Depending on the camera model, this parameter can be a BYTE or a SHORT
-        int a = 0;
-
-        if (astype == INVALID || astype == AUTO) {
-            astype = t->getType();
-        }
-
-        if (astype == BYTE) {
-            a = t->getValue()[ofs];
-        } else if (astype == SHORT) {
-            a = (int)sget2 (t->getValue() + ofs, t->getOrder());
-        }
-
-        // Decode the value
-        if (a) {
-            return int (powf (2.f, (float (a) / 8.f - 1.f) / 2.f) + 0.5f);
-        } else {
-            return 0;
-        }
-    }
-};
-SAFNumberInterpreter saFNumberInterpreter;
-
-class SAISOSettingInterpreter : public Interpreter
-{
-public:
-    SAISOSettingInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        int a = t->toInt();
-
-        if (a) {
-            char buffer[32];
-            snprintf(buffer, sizeof(buffer), "%d", a );
-            return buffer;
-        } else {
-            return "Auto";
-        }
-    }
-    int toInt (const Tag* t, int ofs, TagType astype) override
-    {
-        // Get the value; Depending on the camera model, this parameter can be a BYTE or a SHORT
-        int a = 0;
-
-        if (astype == INVALID || astype == AUTO) {
-            astype = t->getType();
-        }
-
-        if (astype == BYTE) {
-            a = t->getValue()[ofs];
-        } else if (astype == SHORT) {
-            a = (int)sget2 (t->getValue() + ofs, t->getOrder());
-        }
-
-        // Decode the value
-        if (a && a != 254) { // 254 = 'Auto' for CameraSettings3, but we might say the same for CameraSettings & CameraSettings2 (?)
-            return std::exp((a / 8.f - 6.f) * std::log(2.f)) * 100.f + 0.5f;
-        } else {
-            return 0;
-        }
-    }
-};
-SAISOSettingInterpreter saISOSettingInterpreter;
-
-class SAExposureCompSetInterpreter : public Interpreter
-{
-public:
-    SAExposureCompSetInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        double a = t->toDouble();
-        char buffer[32];
-        snprintf(buffer, sizeof(buffer), "%.2f", a );
-        return buffer;
-    }
-    double toDouble (const Tag* t, int ofs) override
-    {
-        // Get the value
-        int a = t->getValue()[ofs];
-        // Decode the value
-        return (double (a) - 128.) / 24.;
-    }
-};
-SAExposureCompSetInterpreter saExposureCompSetInterpreter;
-
-class SAAFMicroAdjValueInterpreter : public Interpreter
-{
-public:
-    SAAFMicroAdjValueInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        snprintf(buffer, sizeof(buffer), "%d", t->getValue()[0] - 20);
-        return buffer;
-    }
-    int toInt (const Tag* t, int ofs, TagType astype) override
-    {
-        return t->getValue()[0] - 20;
-    }
-};
-SAAFMicroAdjValueInterpreter saAFMicroAdjValueInterpreter;
-
-class SAAFMicroAdjModeInterpreter : public Interpreter
-{
-public:
-    SAAFMicroAdjModeInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        int a = t->getValue()[0] & 0x80;
-
-        if (a == 0x80) {
-            return "On";
-        }
-
-        return "Off";
-    }
-    int toInt (const Tag* t, int ofs, TagType astype) override
-    {
-        return (t->getValue()[0] & 0x80) == 0x80 ? 1 : 0;
-    }
-};
-
-SAAFMicroAdjModeInterpreter saAFMicroAdjModeInterpreter;
-
-class SAAFMicroAdjRegisteredLensesInterpreter : public Interpreter
-{
-public:
-    SAAFMicroAdjRegisteredLensesInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        snprintf(buffer, sizeof(buffer), "%d", t->getValue()[0] & 0x7f);
-        return buffer;
-    }
-    int toInt (const Tag* t, int ofs, TagType astype) override
-    {
-        return t->getValue()[0] & 0x7f;
-    }
-};
-SAAFMicroAdjRegisteredLensesInterpreter saAFMicroAdjRegisteredLensesInterpreter;
-
-class SAFocusStatusInterpreter : public Interpreter
-{
-public:
-    SAFocusStatusInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        std::string retval;
-        int a = t->toInt();
-
-        if (a == 0) {
-            retval = "Not confirmed";
-        } else if (a == 4) {
-            retval = "Not confirmed, Tracking";
-        } else {
-            if (a & 1) {
-                retval = "Confirmed";
-            }
-
-            if (a & 2) {
-                if (!retval.empty()) {
-                    retval += ", ";
-                }
-
-                retval += "Failed";
-            }
-
-            if (a & 4)
-                if (!retval.empty()) {
-                    retval += ", ";
-                }
-
-            retval += "Tracking";
-        }
-
-        return retval;
-    }
-};
-SAFocusStatusInterpreter saFocusStatusInterpreter;
-
-class SAColorTemperatureSettingInterpreter : public Interpreter
-{
-public:
-    SAColorTemperatureSettingInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        snprintf(buffer, sizeof(buffer), "%d", t->toInt());
-        return buffer;
-    }
-    int toInt (const Tag* t, int ofs, TagType astype) override
-    {
-        int a = 0;
-
-        if (astype == INVALID || astype == AUTO) {
-            astype = t->getType();
-        }
-
-        if (astype == BYTE) {
-            a = t->getValue()[ofs];
-        } else if (astype == SHORT) {
-            a = (int)sget2 (t->getValue() + ofs, t->getOrder());
-        }
-
-        return a * 100;
-    }
-};
-SAColorTemperatureSettingInterpreter saColorTemperatureSettingInterpreter;
-
-const TagAttrib minoltaAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0000, AUTO, "MakerNoteVersion", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0001, AUTO, "MinoltaCameraSettingsOld", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0003, AUTO, "MinoltaCameraSettings", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0004, AUTO, "MinoltaCameraSettings7D", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0018, AUTO, "ImageStabilization", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0040, AUTO, "CompressedImageSize", &stdInterpreter},
-    {1, AC_WRITE, 0, nullptr, 0x0081, AUTO, "PreviewImage", &stdInterpreter},
-    {1, AC_WRITE, 0, nullptr, 0x0088, AUTO, "PreviewImageStart", &stdInterpreter},
-    {1, AC_WRITE, 0, nullptr, 0x0089, AUTO, "PreviewImageLength", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0100, AUTO, "SceneMode", &saSceneModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0101, AUTO, "ColorMode", &saColorModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0102, AUTO, "MinoltaQuality", &maQualityInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0103, AUTO, "MinoltaImageSize", &maImageSizeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0104, AUTO, "FlashExposureComp", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0105, AUTO, "Teleconverter", &maTeleconverterInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0107, AUTO, "ImageStabilization", &saOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010a, AUTO, "ZoneMatching", &saZoneMatchingInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010b, AUTO, "ColorTemperature", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x010c, AUTO, "LensID", &saLensIDInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0113, AUTO, "ImageStabilization", &saOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0114, AUTO, "MinoltaCameraSettings", &stdInterpreter},
-    {1, AC_WRITE, 0, nullptr, 0x0e00, AUTO, "PrintIM", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0f00, AUTO, "MinoltaCameraSettings2", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib sonyAttribs[] = {
-    {0, AC_WRITE, 0, sonyCameraInfoAttribs, 0x0010, AUTO, "CameraInfo", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0102, AUTO, "Quality", &maQualityInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0104, AUTO, "FlashExposureComp", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0106, AUTO, "TeleConverter", &maTeleconverterInterpreter},
-    {0, AC_WRITE, 0, sonyCameraSettingsAttribs, 0x0114, AUTO, "SonyCameraSettings", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0115, AUTO, "WhiteBalance", &saWhiteBalanceInterpreter},
-    {1, AC_WRITE, 0, nullptr, 0x0e00, AUTO, "PrintIM", &stdInterpreter},
-    {1, AC_WRITE, 0, nullptr, 0x2001, AUTO, "PreviewImage", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x2009, AUTO, "HighISONoiseReduction", &saHighISONoiseReduction},
-    {0, AC_WRITE, 0, nullptr, 0x200a, AUTO, "AutoHDR", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x200b, AUTO, "MultiFrameNoiseReduction", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x200e, AUTO, "PictureEffect", &saPictureEffectInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x2011, AUTO, "VignettingCorrection", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x2012, AUTO, "LateralChromaticAberration", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x2013, AUTO, "DistortionCorrection", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb020, AUTO, "ColorReproduction", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb021, AUTO, "ColorTemperature", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb022, AUTO, "ColorCompensationFilter", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb023, AUTO, "SceneMode", &saSceneModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb024, AUTO, "ZoneMatching", &saZoneMatchingInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb025, AUTO, "DynamicRangeOptimizer", &saDynamicRangeOptimizerInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb026, AUTO, "ImageStabilization", &saOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb027, AUTO, "LensID", &saLensIDInterpreter},
-    {0, AC_WRITE, 0, minoltaAttribs, 0xb028, AUTO, "MinoltaMakerNote", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb029, AUTO, "ColorMode", &saColorModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb040, AUTO, "Macro", &saOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb041, AUTO, "ExposureMode", &saExposureModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb042, AUTO, "FocusMode", &saFocusMode},
-    {0, AC_WRITE, 0, nullptr, 0xb043, AUTO, "AFMode", &saAFMode},
-    {0, AC_WRITE, 0, nullptr, 0xb044, AUTO, "AFIlluminator", &saAFIlluminator},
-    {0, AC_WRITE, 0, nullptr, 0xb047, AUTO, "Quality", &saQualityInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb048, AUTO, "FlashLevel", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb049, AUTO, "ReleaseMode", &saReleaseModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb04a, AUTO, "SequenceNumber", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb04b, AUTO, "AntiBlur", &saAntiBlurInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb04e, AUTO, "LongExposureNoiseReduction", &saOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb04f, AUTO, "DynamicRangeOptimizer", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0xb050, AUTO, "HighISONoiseReduction2", &saHighISONoiseReduction2},
-    {0, AC_WRITE, 0, nullptr, 0xb052, AUTO, "IntelligentAuto", &stdInterpreter},
-    {0, AC_WRITE, 0, sonyTag9405Attribs, 0x9405, AUTO, "Tag9405", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib sonyTag9405Attribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x005d, AUTO, "LensFormat", &stdInterpreter},  // 9405b start here
-    {0, AC_WRITE, 0, nullptr, 0x005e, AUTO, "LensMount", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0060, SHORT, "LensType2", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0062, SHORT, "LensType", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0603, AUTO, "LensFormat", &stdInterpreter},  // 9405a start here
-    {0, AC_WRITE, 0, nullptr, 0x0604, AUTO, "LensMount", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0605, SHORT, "LensType2", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0608, SHORT, "LensType", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib sonyCameraInfoAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 14, SHORT, "FocalLength", &saExposureTimeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 16, SHORT, "FocalLengthTeleZoom", &saExposureTimeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 25, AUTO, "FocusStatus", &saCameraInfoFocusStatusInterpreter},
-    {0, AC_WRITE, 0, nullptr, 28, AUTO, "AFPointSelected", &saCameraInfoAFPointSelected},
-    {0, AC_WRITE, 0, nullptr, 29, AUTO, "FocusMode", &saFocusMode2},
-    {0, AC_WRITE, 0, nullptr, 32, AUTO, "AFPoint", &saCameraInfoAFPoint},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib sonyCameraInfo2Attribs[] = {
-    {0, AC_WRITE, 0, nullptr, 304, AUTO, "AFMicroAdjValue", &saAFMicroAdjValueInterpreter},
-    {0, AC_WRITE, 0, nullptr, 305, AUTO, "AFMicroAdjMode", &saAFMicroAdjModeInterpreter},
-    {0, AC_WRITE, 0, nullptr, 305, AUTO, "AFMicroAdjRegisteredLenses", &saAFMicroAdjRegisteredLensesInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib sonyCameraSettingsAttribs[] = {
-    {0, AC_WRITE, 0, nullptr,  0, AUTO, "ExposureTime", &saExposureTimeInterpreter},
-    {0, AC_WRITE, 0, nullptr,  1, AUTO, "FNumber", &saFNumberInterpreter},
-    {0, AC_WRITE, 0, nullptr,  4, AUTO, "DriveMode", &saDriveMode},
-    {0, AC_WRITE, 0, nullptr,  6, AUTO, "WhiteBalanceFineTune", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 16, AUTO, "FocusModeSetting", &saFocusMode},
-    {0, AC_WRITE, 0, nullptr, 17, AUTO, "AFAreaMode", &saAFAreaMode},
-    {0, AC_WRITE, 0, nullptr, 18, AUTO, "AFPointSelected", &saAFPointSelected},
-    {0, AC_WRITE, 0, nullptr, 21, AUTO, "MeteringMode", &saMeteringMode1_4},
-    {0, AC_WRITE, 0, nullptr, 22, AUTO, "ISOSetting", &saISOSettingInterpreter},
-    {0, AC_WRITE, 0, nullptr, 24, AUTO, "DynamicRangeOptimizerMode", &saDynamicRangeOptimizerMode},
-    {0, AC_WRITE, 0, nullptr, 25, AUTO, "DynamicRangeOptimizerLevel", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 26, AUTO, "CreativeStyle", &saCreativeStyle},
-    {0, AC_WRITE, 0, nullptr, 28, AUTO, "Sharpness", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 29, AUTO, "Contrast", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 30, AUTO, "Saturation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 31, AUTO, "ZoneMatchingValue", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 34, AUTO, "Brightness", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 35, AUTO, "FlashMode", &saFlashMode},
-    {0, AC_WRITE, 0, nullptr, 40, AUTO, "PrioritySetupShutterRelease", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 41, AUTO, "AFIlluminator", &saAFIlluminator},
-    {0, AC_WRITE, 0, nullptr, 42, AUTO, "AFWithShutter", &saOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 43, AUTO, "LongExposureNoiseReduction", &saOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 44, AUTO, "HighISONoiseReduction", &saHighISONoiseReduction3},
-    {0, AC_WRITE, 0, nullptr, 45, AUTO, "ImageStyle", &saImageStyleInterpreter},
-    {0, AC_WRITE, 0, nullptr, 60, AUTO, "ExposureProgram", &saExposureProgram},
-    {0, AC_WRITE, 0, nullptr, 61, AUTO, "ImageStabilization", &saOnOffInterpreter},
-    {0, AC_WRITE, 0, nullptr, 63, AUTO, "Rotation", &saRotation},
-    {0, AC_WRITE, 0, nullptr, 77, AUTO, "FocusMode", &saFocusMode},
-    {0, AC_WRITE, 0, nullptr, 83, AUTO, "FocusStatus", &saFocusStatusInterpreter},
-    {0, AC_WRITE, 0, nullptr, 84, AUTO, "SonyImageSize", &saSonyImageSize},
-    {0, AC_WRITE, 0, nullptr, 85, AUTO, "AspectRatio", &saAspectRatio},
-    {0, AC_WRITE, 0, nullptr, 86, AUTO, "Quality", &saQualityInterpreter2},
-    {0, AC_WRITE, 0, nullptr, 88, AUTO, "ExposureLevelIncrements", &saExposureLevelIncrements},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib sonyCameraSettingsAttribs2[] = {
-    {0, AC_WRITE, 0, nullptr,  0, AUTO, "ExposureTime", &saExposureTimeInterpreter},
-    {0, AC_WRITE, 0, nullptr,  1, AUTO, "FNumber", &saFNumberInterpreter},
-    {0, AC_WRITE, 0, nullptr, 11, AUTO, "ColorTemperatureSetting", &saColorTemperatureSettingInterpreter},
-    {0, AC_WRITE, 0, nullptr, 15, AUTO, "FocusMode", &saFocusMode2},
-    {0, AC_WRITE, 0, nullptr, 16, AUTO, "AFAreaMode", &saAFAreaMode},
-    {0, AC_WRITE, 0, nullptr, 17, AUTO, "AFPointSelected", &saAFPointSelected2},
-    {0, AC_WRITE, 0, nullptr, 19, AUTO, "MeteringMode", &saMeteringMode1_4},
-    {0, AC_WRITE, 0, nullptr, 20, AUTO, "ISOSetting", &saISOSettingInterpreter},
-    {0, AC_WRITE, 0, nullptr, 22, AUTO, "DynamicRangeOptimizerMode", &saDynamicRangeOptimizerMode},
-    {0, AC_WRITE, 0, nullptr, 23, AUTO, "DynamicRangeOptimizerLevel", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 24, AUTO, "CreativeStyle", &saCreativeStyle2},
-    {0, AC_WRITE, 0, nullptr, 25, AUTO, "Sharpness", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 26, AUTO, "Contrast", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 27, AUTO, "Saturation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 35, AUTO, "FlashMode", &saFlashMode},
-    {0, AC_WRITE, 0, nullptr, 38, AUTO, "HighISONoiseReduction", &saHighISONoiseReduction4},
-    {0, AC_WRITE, 0, nullptr, 60, AUTO, "ExposureProgram", &saExposureProgram},
-    {0, AC_WRITE, 0, nullptr, 63, AUTO, "Rotation", &saRotation},
-    {0, AC_WRITE, 0, nullptr, 83, AUTO, "FocusStatus", &saFocusStatusInterpreter},
-    {0, AC_WRITE, 0, nullptr, 84, AUTO, "SonyImageSize", &saSonyImageSize},
-    {0, AC_WRITE, 0, nullptr, 85, AUTO, "AspectRatio", &saAspectRatio},
-    {0, AC_WRITE, 0, nullptr, 86, AUTO, "Quality", &saQualityInterpreter2},
-    {0, AC_WRITE, 0, nullptr, 88, AUTO, "ExposureLevelIncrements", &saExposureLevelIncrements},
-    {0, AC_WRITE, 0, nullptr, 126, AUTO, "DriveMode", &saDriveMode2},
-    {0, AC_WRITE, 0, nullptr, 131, AUTO, "ColorSpace", &saColorSpace5_6},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-const TagAttrib sonyCameraSettingsAttribs3[] = {
-    {0, AC_WRITE, 0, nullptr,  0, AUTO, "ShutterSpeedSetting", &saExposureTimeInterpreter},
-    {0, AC_WRITE, 0, nullptr,  1, AUTO, "ApertureSetting", &saFNumberInterpreter},
-    {0, AC_WRITE, 0, nullptr,  2, AUTO, "ISOSetting", &saISOSettingInterpreter},
-    {0, AC_WRITE, 0, nullptr,  3, AUTO, "ExposureCompensationSet", &saExposureCompSetInterpreter},
-    {0, AC_WRITE, 0, nullptr,  3, AUTO, "DriveModeSetting", &saDriveMode3},
-    {0, AC_WRITE, 0, nullptr,  5, AUTO, "ExposureProgram", &saExposureProgram2},
-    {0, AC_WRITE, 0, nullptr,  6, AUTO, "FocusModeSetting", &saFocusModeSetting3},
-    {0, AC_WRITE, 0, nullptr,  7, AUTO, "MeteringMode", &saMeteringMode1_3},
-    {0, AC_WRITE, 0, nullptr,  9, AUTO, "SonyImageSize", &saSonyImageSize3},
-    {0, AC_WRITE, 0, nullptr, 10, AUTO, "AspectRatio", &saAspectRatio2},
-    {0, AC_WRITE, 0, nullptr, 11, AUTO, "Quality", &saQualityInterpreter3},
-    {0, AC_WRITE, 0, nullptr, 12, AUTO, "DynamicRangeOptimizerSetting", &saDynamicRangeOptimizerSetting},
-    {0, AC_WRITE, 0, nullptr, 14, AUTO, "ColorSpace", &saColorSpace1_2},
-    {0, AC_WRITE, 0, nullptr, 15, AUTO, "CreativeStyleSetting", &saCreativeStyleSetting},
-    {0, AC_WRITE, 0, nullptr, 16, AUTO, "Contrast", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 17, AUTO, "Saturation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 18, AUTO, "Sharpness", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 22, AUTO, "WhiteBalance", &saWhiteBalanceSettingInterpreter},
-    {0, AC_WRITE, 0, nullptr, 23, AUTO, "ColorTemperatureSetting", &saColorTemperatureSettingInterpreter},
-    {0, AC_WRITE, 0, nullptr, 23, AUTO, "ColorCompensationFilterSet", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 32, AUTO, "FlashMode", &saFlashMode2},
-    {0, AC_WRITE, 0, nullptr, 33, AUTO, "FlashControl", &saFlashControl},
-    {0, AC_WRITE, 0, nullptr, 35, AUTO, "FlashExposureCompSet", &saExposureCompSetInterpreter},
-    {0, AC_WRITE, 0, nullptr, 36, AUTO, "AFAreaMode", &saAFAreaMode2},
-    {0, AC_WRITE, 0, nullptr, 37, AUTO, "LongExposureNoiseReduction", &saOnOffInterpreter2},
-    {0, AC_WRITE, 0, nullptr, 38, AUTO, "HighISONoiseReduction", &saHighISONoiseReduction5},
-    {0, AC_WRITE, 0, nullptr, 39, AUTO, "SmileShutterMode", &saSmileShutterMode},
-    {0, AC_WRITE, 0, nullptr, 40, AUTO, "RedEyeReduction", &saOnOffInterpreter2},
-    {0, AC_WRITE, 0, nullptr, 45, AUTO, "HDRSetting", &saOnOffInterpreter3},
-    {0, AC_WRITE, 0, nullptr, 46, AUTO, "HDRLevel", &saHDRLevel},
-    {0, AC_WRITE, 0, nullptr, 47, AUTO, "ViewingMode", &saViewingMode},
-    {0, AC_WRITE, 0, nullptr, 48, AUTO, "FaceDetection", &saOnOffInterpreter2},
-    {0, AC_WRITE, 0, nullptr, 49, AUTO, "SmileShutter", &saOnOffInterpreter2},
-    {0, AC_WRITE, 0, nullptr, 50, AUTO, "SweepPanoramaSize", &saSweepPanoramaSize},
-    {0, AC_WRITE, 0, nullptr, 51, AUTO, "SweepPanoramaDirection", &saSweepPanoramaDirection},
-    {0, AC_WRITE, 0, nullptr, 52, AUTO, "DriveMode", &saDriveMode3},
-    {0, AC_WRITE, 0, nullptr, 53, AUTO, "MultiFrameNoiseReduction", &saOnOffInterpreter4},
-    {0, AC_WRITE, 0, nullptr, 54, AUTO, "LiveViewAFSetting", &saLiveViewAFSetting},
-    {0, AC_WRITE, 0, nullptr, 56, AUTO, "PanoramaSize3D", &saPanoramaSize3D},
-    {0, AC_WRITE, 0, nullptr, 131, AUTO, "AFButtonPressed", &saNoYesInterpreter},
-    {0, AC_WRITE, 0, nullptr, 132, AUTO, "LiveViewMetering", &saLiveViewMetering},
-    {0, AC_WRITE, 0, nullptr, 133, AUTO, "ViewingMode2", &saViewingMode},
-    {0, AC_WRITE, 0, nullptr, 134, AUTO, "AELock", &saOnOffInterpreter5},
-    {0, AC_WRITE, 0, nullptr, 135, AUTO, "FlashAction", &saFlashAction},
-    {0, AC_WRITE, 0, nullptr, 139, AUTO, "LiveViewFocusMode", &saLiveViewFocusMode},
-    {0, AC_WRITE, 0, nullptr, 153, AUTO, "LensMount", &saLensMount},
-    {0, AC_WRITE, 0, nullptr, 643, AUTO, "AFButtonPressed", &saNoYesInterpreter},
-    {0, AC_WRITE, 0, nullptr, 644, AUTO, "LiveViewMetering", &saLiveViewMetering},
-    {0, AC_WRITE, 0, nullptr, 645, AUTO, "ViewingMode2", &saViewingMode},
-    {0, AC_WRITE, 0, nullptr, 646, AUTO, "AELock", &saOnOffInterpreter5},
-    {0, AC_WRITE, 0, nullptr, 647, AUTO, "FlashAction", &saFlashAction},
-    {0, AC_WRITE, 0, nullptr, 651, AUTO, "LiveViewFocusMode", &saLiveViewFocusMode},
-    {0, AC_WRITE, 0, nullptr, 1015, SHORT, "LensType2", &saLensID2Interpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-
-/*const TagAttrib sonyDNGMakerNote[]={
- {0, AC_WRITE, 0, 0, 0x7200, AUTO, "SonyOffset", &stdInterpreter},
- {0, AC_WRITE, 0, 0, 0x7201, AUTO, "SonyLength", &stdInterpreter},
- {0, AC_WRITE, 0, 0, 0x7221, AUTO, "SonyKey", &stdInterpreter},
- {-1, AC_DONTWRITE, 0,  0, 0, AUTO, "", NULL}};*/
-
-}
-
diff --git a/rtexif/stdattribs.cc b/rtexif/stdattribs.cc
deleted file mode 100644
index e6e3bb35b..000000000
--- a/rtexif/stdattribs.cc
+++ /dev/null
@@ -1,927 +0,0 @@
-/*
- *  This file is part of RawTherapee.
- *
- *  Copyright (c) 2004-2010 Gabor Horvath <hgabor@rawtherapee.com>
- *  Copyright (c)      2010 Oliver Duis <www.oliverduis.de>
- *
- *  RawTherapee is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  RawTherapee is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-#include <cstdio>
-#include <cstring>
-
-#include "rtexif.h"
-
-namespace rtexif
-{
-
-class ColorSpaceInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    ColorSpaceInterpreter ()
-    {
-        choices[1]      = "sRGB";
-        choices[2]      = "Adobe RGB";
-        choices[0xffff] = "Uncalibrated";
-    }
-};
-ColorSpaceInterpreter colorSpaceInterpreter;
-
-class PreviewColorSpaceInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    PreviewColorSpaceInterpreter ()
-    {
-        choices[0] = "Unknown";
-        choices[1] = "Gray Gamma 2.2";
-        choices[2] = "sRGB";
-        choices[3] = "Adobe RGB";
-        choices[4] = "ProPhoto RGB";
-    }
-};
-PreviewColorSpaceInterpreter previewColorSpaceInterpreter;
-
-class LinearSRGBInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    LinearSRGBInterpreter ()
-    {
-        choices[0] = "Linear";
-        choices[1] = "sRGB";
-    }
-};
-LinearSRGBInterpreter linearSRGBInterpreter;
-
-class DefaultBlackRenderInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    DefaultBlackRenderInterpreter ()
-    {
-        choices[0] = "Auto";
-        choices[1] = "None";
-    }
-};
-DefaultBlackRenderInterpreter defaultBlackRenderInterpreter;
-
-class ExposureProgramInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    ExposureProgramInterpreter ()
-    {
-        choices[0] = "Not defined";
-        choices[1] = "Manual";
-        choices[2] = "Normal program";
-        choices[3] = "Aperture priority";
-        choices[4] = "Shutter priority";
-        choices[5] = "Creative program";
-        choices[6] = "Action program";
-        choices[7] = "Portrait mode";
-        choices[8] = "Landscape mode";
-    }
-};
-ExposureProgramInterpreter exposureProgramInterpreter;
-
-class MeteringModeInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    MeteringModeInterpreter ()
-    {
-        choices[0] = "Unknown";
-        choices[1] = "Average";
-        choices[2] = "Center weighted";
-        choices[3] = "Spot";
-        choices[4] = "Multispot";
-        choices[5] = "Pattern";
-        choices[6] = "Partial";
-        choices[255] = "Other";
-    }
-};
-MeteringModeInterpreter meteringModeInterpreter;
-
-class ExposureModeInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    ExposureModeInterpreter ()
-    {
-        choices[0] = "Auto exposure";
-        choices[1] = "Manual exposure";
-        choices[2] = "Auto bracket";
-    }
-};
-ExposureModeInterpreter exposureModeInterpreter;
-
-class WhiteBalanceInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    WhiteBalanceInterpreter ()
-    {
-        choices[0] = "Auto white balance";
-        choices[1] = "Manual white balance";
-    }
-};
-WhiteBalanceInterpreter whiteBalanceInterpreter;
-
-class SceneCaptureInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    SceneCaptureInterpreter ()
-    {
-        choices[0] = "Standard";
-        choices[1] = "Landscape";
-        choices[2] = "Portrait";
-        choices[3] = "Night scene";
-    }
-};
-SceneCaptureInterpreter sceneCaptureInterpreter;
-
-class GainControlInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    GainControlInterpreter ()
-    {
-        choices[0] = "None";
-        choices[1] = "Low gain up";
-        choices[2] = "High gain up";
-        choices[3] = "Low gain down";
-        choices[4] = "High gain down";
-    }
-};
-GainControlInterpreter gainControlInterpreter;
-
-class ContrastInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    ContrastInterpreter ()
-    {
-        choices[0] = "Normal";
-        choices[1] = "Soft";
-        choices[2] = "Hard";
-    }
-};
-ContrastInterpreter contrastInterpreter;
-
-class SharpnessInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    SharpnessInterpreter ()
-    {
-        choices[0] = "Normal";
-        choices[1] = "Soft";
-        choices[2] = "Hard";
-    }
-};
-SharpnessInterpreter sharpnessInterpreter;
-
-class SaturationInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    SaturationInterpreter ()
-    {
-        choices[0] = "Normal";
-        choices[1] = "Low saturation";
-        choices[2] = "High saturation";
-    }
-};
-SaturationInterpreter saturationInterpreter;
-
-class FlashInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    FlashInterpreter ()
-    {
-        choices[0x0000] = "Flash did not fire";
-        choices[0x0001] = "Flash fired";
-        choices[0x0005] = "Strobe return light not detected";
-        choices[0x0007] = "Strobe return light detected";
-        choices[0x0009] = "Flash fired, compulsory flash mode";
-        choices[0x000D] = "Flash fired, compulsory flash mode, return light not detected";
-        choices[0x000F] = "Flash fired, compulsory flash mode, return light detected";
-        choices[0x0010] = "Flash did not fire, compulsory flash mode";
-        choices[0x0018] = "Flash did not fire, auto mode";
-        choices[0x0019] = "Flash fired, auto mode";
-        choices[0x001D] = "Flash fired, auto mode, return light not detected";
-        choices[0x001F] = "Flash fired, auto mode, return light detected";
-        choices[0x0020] = "No flash function";
-        choices[0x0041] = "Flash fired, red-eye reduction mode";
-        choices[0x0045] = "Flash fired, red-eye reduction mode, return light not detected";
-        choices[0x0047] = "Flash fired, red-eye reduction mode, return light detected";
-        choices[0x0049] = "Flash fired, compulsory flash mode, red-eye reduction mode";
-        choices[0x004D] = "Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected";
-        choices[0x004F] = "Flash fired, compulsory flash mode, red-eye reduction mode, return light detected";
-        choices[0x0059] = "Flash fired, auto mode, red-eye reduction mode";
-        choices[0x005D] = "Flash fired, auto mode, return light not detected, red-eye reduction mode";
-        choices[0x005F] = "Flash fired, auto mode, return light detected, red-eye reduction mode";
-    }
-};
-FlashInterpreter flashInterpreter;
-
-class LightSourceInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    LightSourceInterpreter ()
-    {
-        choices[0] = "Unknown";
-        choices[1] = "Daylight";
-        choices[2] = "Fluorescent";
-        choices[3] = "Tungsten";
-        choices[4] = "Flash";
-        choices[9] = "Fine weather";
-        choices[10] = "Cloudy weather";
-        choices[11] = "Shade";
-        choices[12] = "Daylight fluorescent";
-        choices[13] = "Day white fluorescent";
-        choices[14] = "Cool white fluorescent";
-        choices[15] = "White fluorescent";
-        choices[17] = "Standard light A";
-        choices[18] = "Standard light B";
-        choices[19] = "Standard light C";
-        choices[20] = "D55";
-        choices[21] = "D65";
-        choices[22] = "D75";
-        choices[23] = "D50";
-        choices[24] = "ISO studio tungsten";
-        choices[255] = "Other light source";
-    }
-};
-LightSourceInterpreter lightSourceInterpreter;
-
-class CompressionInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    CompressionInterpreter ()
-    {
-        choices[1] = "Uncompressed";
-        choices[6] = "JPEG Compression";
-    }
-};
-CompressionInterpreter compressionInterpreter;
-
-class PhotometricInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    PhotometricInterpreter ()
-    {
-        choices[2] = "RGB";
-        choices[6] = "YCbCr";
-    }
-};
-PhotometricInterpreter photometricInterpreter;
-
-class ProfileEmbedPolicyInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    ProfileEmbedPolicyInterpreter ()
-    {
-        choices[0] = "Allow Copying";
-        choices[1] = "Embed if Used";
-        choices[2] = "Never Embed";
-        choices[3] = "No Restrictions";
-    }
-};
-ProfileEmbedPolicyInterpreter profileEmbedPolicyInterpreter;
-
-class PlanarConfigInterpreter : public ChoiceInterpreter<>
-{
-
-public:
-    PlanarConfigInterpreter ()
-    {
-        choices[1] = "Chunky format";
-        choices[2] = "Planar format";
-    }
-};
-PlanarConfigInterpreter planarConfigInterpreter;
-
-class FNumberInterpreter : public Interpreter
-{
-public:
-    FNumberInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        double v = t->toDouble();
-
-        if ( v < 0. || v > 1000. ) {
-            return "undef";
-        }
-
-        snprintf(buffer, sizeof(buffer), "%0.1f", v);
-        return buffer;
-    }
-};
-FNumberInterpreter fNumberInterpreter;
-
-class ApertureInterpreter : public Interpreter
-{
-public:
-    ApertureInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        double v = pow (2.0, t->toDouble() / 2.0);
-
-        if ( v < 0. || v > 1000. ) {
-            return "undef";
-        }
-
-        snprintf(buffer, sizeof(buffer), "%.1f", v );
-        return buffer;
-    }
-};
-ApertureInterpreter apertureInterpreter;
-
-class ExposureBiasInterpreter : public Interpreter
-{
-public:
-    ExposureBiasInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        double v = t->toDouble();
-
-        if ( v < -1000. || v > 1000. ) {
-            return "undef";
-        }
-
-        snprintf(buffer, sizeof(buffer), "%+0.2f", v );
-        return buffer;
-    }
-};
-ExposureBiasInterpreter exposureBiasInterpreter;
-
-class ShutterSpeedInterpreter : public Interpreter
-{
-public:
-    ShutterSpeedInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        double d = pow (2.0, -t->toDouble());
-
-        if (d > 0.0 && d <= 0.5) {
-            snprintf(buffer, sizeof(buffer), "1/%.0f", 1.0 / d);
-        } else {
-            snprintf(buffer, sizeof(buffer), "%.1f", d);
-        }
-
-        return buffer;
-    }
-};
-ShutterSpeedInterpreter shutterSpeedInterpreter;
-
-class ExposureTimeInterpreter : public Interpreter
-{
-public:
-    ExposureTimeInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        double d = t->toDouble();
-
-        if (d > 0.0 && d <= 0.5) {
-            snprintf(buffer, sizeof(buffer), "1/%.0f", 1.0 / d);
-        } else {
-            snprintf(buffer, sizeof(buffer), "%.1f", d);
-        }
-
-        return buffer;
-    }
-};
-ExposureTimeInterpreter exposureTimeInterpreter;
-
-class FocalLengthInterpreter : public Interpreter
-{
-public:
-    FocalLengthInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        char buffer[32];
-        double v = t->toDouble();
-
-        if ( v > 1000000. || v < 0 ) {
-            return "undef";
-        }
-
-        snprintf(buffer, sizeof(buffer), "%.1f", v );
-        return buffer;
-    }
-};
-FocalLengthInterpreter focalLengthInterpreter;
-
-class UserCommentInterpreter : public Interpreter
-{
-public:
-    UserCommentInterpreter () {}
-    std::string toString (const Tag* t) const override
-    {
-        int count = t->getCount();
-
-        if (count <= 8) {
-            return std::string();
-        }
-
-        count = std::min (count, 65535); // limit to 65535 chars to avoid crashes in case of corrupted metadata
-        unsigned char *buffer = new unsigned char[count - 6]; // include 2 ending null chars for UCS-2 string (possibly)
-        unsigned char *value = t->getValue();
-
-        if (!memcmp(value, "ASCII\0\0\0", 8)) {
-            memcpy(buffer, value + 8, count - 8);
-            buffer[count - 8] = '\0';
-        } else if (!memcmp(value, "UNICODE\0", 8)) {
-            memcpy(buffer, value + 8, count - 8);
-            buffer[count - 7] = buffer[count - 8] = '\0';
-            Glib::ustring tmp1((char*)buffer);
-
-
-            bool hasBOM = false;
-            enum ByteOrder bo = UNKNOWN;
-            if (count % 2 || (count >= 11 && (buffer[0] == 0xEF && buffer[1] == 0xBB && buffer[2] == 0xBF))) {
-                // odd string length can only be UTF-8, don't change anything
-                std::string retVal ((char*)buffer + 3);
-                delete [] buffer;
-                return retVal;
-            } else if (count >= 10) {
-                if (buffer[0] == 0xFF && buffer[1] == 0xFE) {
-                    bo = INTEL; // little endian
-                    hasBOM = true;
-                } else if (buffer[0] == 0xFE && buffer[1] == 0xFF) {
-                    bo = MOTOROLA; // big endian
-                    hasBOM = true;
-                }
-            }
-            if (bo == UNKNOWN) {
-                // auto-detecting byte order; we still don't know if it's UCS-2 or UTF-8
-                int a = 0, b = 0, c = 0, d = 0;
-                for (int j = 8; j < count; j++) {
-                    unsigned char cc = value[j];
-                    if (!(j%2)) {
-                        // counting zeros for first byte
-                        if (!cc) {
-                            ++a;
-                        }
-                    } else {
-                        // counting zeros for second byte
-                        if (!cc) {
-                            ++b;
-                        }
-                    }
-                    if (!(cc & 0x80) || ((cc & 0xC0) == 0xC0) || ((cc & 0xC0) == 0x80)) {
-                        ++c;
-                    }
-                    if ((cc & 0xC0) == 0x80) {
-                        ++d;
-                    }
-                }
-                if (c == (count - 8) && d) {
-                    // this is an UTF-8 string
-                    std::string retVal ((char*)buffer);
-                    delete [] buffer;
-                    return retVal;
-                }
-                if ((a || b) && a != b) {
-                    bo = a > b ? MOTOROLA : INTEL;
-                }
-            }
-            if (bo == UNKNOWN) {
-                // assuming platform's byte order
-#if __BYTE_ORDER__==__ORDER_LITTLE_ENDIAN__
-                bo = INTEL;
-#else
-                bo = MOTOROLA;
-#endif
-            }
-
-            // now swapping if necessary
-            if (!hasBOM && bo != HOSTORDER) {
-                if (t->getOrder() != HOSTORDER) {
-                    Tag::swapByteOrder2(buffer, count - 8);
-                }
-            }
-
-            glong written;
-            char* utf8Str = g_utf16_to_utf8((unsigned short int*)buffer, -1, nullptr, &written, nullptr);
-            delete [] buffer;
-            buffer = new unsigned char[written + 1];
-            memcpy(buffer, utf8Str, written);
-            buffer[written] = 0;
-            g_free(utf8Str);
-        } else if (!memcmp(value, "\0\0\0\0\0\0\0\0", 8)) {
-            // local charset string, whatever it is
-            memcpy(buffer, value + 8, count - 8);
-            buffer[count - 7] = buffer[count - 8] = '\0';
-
-            gsize written = 0;
-            char *utf8Str = g_locale_to_utf8((char*)buffer, count - 8, nullptr, &written, nullptr);
-            if (utf8Str && written) {
-                delete [] buffer;
-                size_t length = strlen(utf8Str);
-                buffer = new unsigned char[length + 1];
-                strcpy((char*)buffer, utf8Str);
-            } else {
-                buffer[0] = 0;
-            }
-            if (utf8Str) {
-                g_free(utf8Str);
-            }
-        } else {
-            // JIS: unsupported
-            buffer[0] = 0;
-        }
-
-        std::string retVal ((char*)buffer);
-        delete [] buffer;
-        return retVal;
-    }
-    void fromString (Tag* t, const std::string& value) override
-    {
-        Glib::ustring tmpStr(value);
-        t->userCommentFromString (tmpStr);
-    }
-};
-UserCommentInterpreter userCommentInterpreter;
-
-class CFAInterpreter : public Interpreter
-{
-public:
-    CFAInterpreter() {}
-    std::string toString (const Tag* t) const override
-    {
-        char colors[] = "RGB";
-        char buffer[1024];
-
-        for ( int i = 0; i < t->getCount(); i++) {
-            unsigned char c = t->toInt (i, BYTE);
-            buffer[i] = c < 3 ? colors[c] : ' ';
-        }
-
-        buffer[t->getCount()] = 0;
-        return buffer;
-    }
-};
-CFAInterpreter cfaInterpreter;
-
-class OrientationInterpreter : public ChoiceInterpreter<>
-{
-public:
-    OrientationInterpreter ()
-    {
-        choices[1] = "Horizontal (normal)";
-        choices[2] = "Mirror horizontal ";
-        choices[3] = "Rotate 180";
-        choices[4] = "Mirror vertical";
-        choices[5] = "Mirror horizontal and rotate 270 CW";
-        choices[6] = "Rotate 90 CW";
-        choices[7] = "Mirror horizontal and rotate 90 CW";
-        choices[8] = "Rotate 270 CW";
-        // '9' is an "unofficial" value for Orientation but used by some older cameras that lacks orientation sensor, such as Kodak DCS
-        choices[9] = "Unknown";
-    }
-};
-OrientationInterpreter orientationInterpreter;
-
-class UnitsInterpreter : public ChoiceInterpreter<>
-{
-public:
-    UnitsInterpreter()
-    {
-        choices[0] = "Unknown";
-        choices[1] = "inches";
-        choices[2] = "cm";
-    }
-};
-UnitsInterpreter unitsInterpreter;
-
-class UTF8BinInterpreter : public Interpreter
-{
-public:
-    UTF8BinInterpreter () {}
-};
-UTF8BinInterpreter utf8BinInterpreter;
-
-class RawImageSegmentationInterpreter : public Interpreter
-{
-public:
-    std::string toString (const Tag* t) const override
-    {
-        int segmentNumber = t->toInt(0, SHORT);
-        int segmentWidth = t->toInt(2, SHORT);
-        int lastSegmentWidth = t->toInt(4, SHORT);
-
-        char buffer[32];
-        snprintf(buffer, sizeof(buffer), "%d %d %d", segmentNumber, segmentWidth, lastSegmentWidth);
-        return buffer;
-    }
-};
-RawImageSegmentationInterpreter rawImageSegmentationInterpreter;
-
-const TagAttrib exifAttribs[] = {
-    {0, AC_SYSTEM,    0, nullptr, 0x0100, AUTO, "ImageWidth", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0101, AUTO, "ImageHeight", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0102, AUTO, "BitsPerSample", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0103, AUTO, "Compression", &compressionInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0153, AUTO, "SampleFormat", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x828d, AUTO, "CFAPatternDim", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x828e, AUTO, "CFAPattern", &cfaInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x829A, AUTO, "ExposureTime", &exposureTimeInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x829D, AUTO, "FNumber", &fNumberInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x8822, AUTO, "ExposureProgram", &exposureProgramInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x8824, AUTO, "SpectralSensitivity", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x8827, AUTO, "ISOSpeedRatings", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x8828, AUTO, "OECF", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x8832, AUTO, "RecommendedExposureIndex", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9000, AUTO, "ExifVersion", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9003, AUTO, "DateTimeOriginal", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9004, AUTO, "DateTimeDigitized", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x9101, AUTO, "ComponentsConfiguration", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x9102, AUTO, "CompressedBitsPerPixel", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9201, AUTO, "ShutterSpeedValue", &shutterSpeedInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9202, AUTO, "ApertureValue", &apertureInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9203, AUTO, "BrightnessValue", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9204, AUTO, "ExposureBiasValue", &exposureBiasInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9205, AUTO, "MaxApertureValue", &apertureInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9206, AUTO, "SubjectDistance", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9207, AUTO, "MeteringMode", &meteringModeInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9208, AUTO, "LightSource", &lightSourceInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9209, AUTO, "Flash", &flashInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x920A, AUTO, "FocalLength", &focalLengthInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9214, AUTO, "SubjectArea", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9215, AUTO, "ExposureIndex", &stdInterpreter}, // Note: exists as 0xA215 too, it should be that way
-    {0, AC_DONTWRITE, 0, nullptr, 0x9216, AUTO, "TIFFEPSStandardID", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9217, AUTO, "SensingMethod", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x927C, AUTO, "MakerNote", &stdInterpreter},
-    {0, AC_WRITE,     1, nullptr, 0x9286, AUTO, "UserComment", &userCommentInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9290, AUTO, "SubSecTime", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9291, AUTO, "SubSecTimeOriginal", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9292, AUTO, "SubSecTimeDigitized", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0xA000, AUTO, "FlashpixVersion", &stdInterpreter},
-    {0, AC_DONTWRITE, 0, nullptr, 0xA001, AUTO, "ColorSpace", &colorSpaceInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0xA002, AUTO, "PixelXDimension", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0xA003, AUTO, "PixelYDimension", &stdInterpreter},
-    {1, AC_DONTWRITE, 0, nullptr, 0xA004, AUTO, "RelatedSoundFile", &stdInterpreter},
-    {0, AC_SYSTEM,    0, iopAttribs,  0xA005, AUTO, "Interoperability", &stdInterpreter},  // do not enable, as it causes trouble with FUJI files
-    {0, AC_WRITE,     0, nullptr, 0xA20B, AUTO, "FlashEnergy", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA20C, AUTO, "SpatialFrequencyResponse", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA20E, AUTO, "FocalPlaneXResolution", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA20F, AUTO, "FocalPlaneYResolution", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA210, AUTO, "FocalPlaneResolutionUnit", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA214, AUTO, "SubjectLocation", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA215, AUTO, "ExposureIndex", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA217, AUTO, "SensingMethod", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA300, AUTO, "FileSource", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA301, AUTO, "SceneType", &stdInterpreter},
-    {0, AC_DONTWRITE, 0, nullptr, 0xA302, AUTO, "CFAPattern", &cfaInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA401, AUTO, "CustomRendered", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA402, AUTO, "ExposureMode", &exposureModeInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA403, AUTO, "WhiteBalance", &whiteBalanceInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA404, AUTO, "DigitalZoomRatio", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA405, AUTO, "FocalLengthIn35mmFilm", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA406, AUTO, "SceneCaptureType", &sceneCaptureInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA407, AUTO, "GainControl", &gainControlInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA408, AUTO, "Contrast", &contrastInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA409, AUTO, "Saturation", &saturationInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA40A, AUTO, "Sharpness", &sharpnessInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA40B, AUTO, "DeviceSettingDescription", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA40C, AUTO, "SubjectDistanceRange", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA420, AUTO, "ImageUniqueID", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA431, AUTO, "SerialNumber", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA432, AUTO, "LensInfo", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA433, AUTO, "LensMake", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA434, AUTO, "LensModel", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA435, AUTO, "LensSerialNumber", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xA500, AUTO, "Gamma", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC618, AUTO, "LinearizationTable", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC619, AUTO, "BlackLevelRepeatDim", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC61A, AUTO, "BlackLevel", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC61B, AUTO, "BlackLevelDeltaH", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC61C, AUTO, "BlackLevelDeltaV", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC61D, AUTO, "WhiteLevel", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC61E, AUTO, "DefaultScale", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC61F, AUTO, "DefaultCropOrigin", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC620, AUTO, "DefaultCropSize", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC621, AUTO, "ColorMatrix1", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC622, AUTO, "ColorMatrix2", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC623, AUTO, "CameraCalibration1", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC624, AUTO, "CameraCalibration2", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC625, AUTO, "ReductionMatrix1", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC626, AUTO, "ReductionMatrix2", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC627, AUTO, "AnalogBalance", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC628, AUTO, "AsShotNeutral", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC629, AUTO, "AsShotWhiteXY", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC62A, AUTO, "BaselineExposure", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC62B, AUTO, "BaselineNoise", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC62C, AUTO, "BaselineSharpness", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC62D, AUTO, "BayerGreenSplit", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC62E, AUTO, "LinearResponseLimit", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC62F, AUTO, "CameraSerialNumber", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC630, AUTO, "DNGLensInfo", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC631, AUTO, "ChromaBlurRadius", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC632, AUTO, "AntiAliasStrength", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC633, AUTO, "ShadowScale", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC65A, AUTO, "CalibrationIlluminant1", &lightSourceInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC65B, AUTO, "CalibrationIlluminant2", &lightSourceInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC65C, AUTO, "BestQualityScale", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC65D, AUTO, "RawDataUniqueID", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC68B, AUTO, "OriginalRawFileName", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC68D, AUTO, "ActiveArea", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC68E, AUTO, "MaskedAreas", &stdInterpreter},
-//  {0, AC_WRITE,     0, nullptr, 0xC68F, AUTO, "AsShotICCProfile", & ???},
-    {0, AC_WRITE,     0, nullptr, 0xC690, AUTO, "AsShotPreProfileMatrix", &stdInterpreter},
-//  {0, AC_WRITE,     0, nullptr, 0xC691, AUTO, "CurrentICCProfile", & ???},
-    {0, AC_WRITE,     0, nullptr, 0xC692, AUTO, "CurrentPreProfileMatrix", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC6BF, AUTO, "ColorimetricReference", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC6F3, AUTO, "CameraCalibrationSig", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC6F4, AUTO, "ProfileCalibrationSig", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC6F5, AUTO, "ProfileIFD", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC6F6, AUTO, "AsShotProfileName", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC6F7, AUTO, "NoiseReductionApplied", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC6F8, AUTO, "ProfileName", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC6F9, AUTO, "ProfileHueSatMapDims", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC6FA, AUTO, "ProfileHueSatMapData1", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC6FB, AUTO, "ProfileHueSatMapData2", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC6FC, AUTO, "ProfileToneCurve", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC6FD, AUTO, "ProfileEmbedPolicy", &profileEmbedPolicyInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC6FE, AUTO, "ProfileCopyright", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC714, AUTO, "ForwardMatrix1", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC715, AUTO, "ForwardMatrix2", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC716, AUTO, "PreviewApplicationName", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC717, AUTO, "PreviewApplicationVersion", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC718, AUTO, "PreviewSettingsName", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC719, AUTO, "PreviewSettingsDigest", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC71A, AUTO, "PreviewColorSpace", &previewColorSpaceInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC71B, AUTO, "PreviewDateTime", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC71C, AUTO, "RawImageDigest", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC71D, AUTO, "OriginalRawFileDigest", &stdInterpreter},
-//  {0, AC_WRITE,     0, nullptr, 0xC71E, AUTO, "SubTileBlockSize", & ???},
-//  {0, AC_WRITE,     0, nullptr, 0xC71F, AUTO, "RowInterleaveFactor", & ???},
-    {0, AC_WRITE,     0, nullptr, 0xC725, AUTO, "ProfileLookTableDims", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC726, AUTO, "ProfileLookTableData", &stdInterpreter},
-//  {0, AC_WRITE,     0, nullptr, 0xC740, AUTO, "OpcodeList1", & ???},
-//  {0, AC_WRITE,     0, nullptr, 0xC741, AUTO, "OpcodeList2", & ???},
-//  {0, AC_WRITE,     0, nullptr, 0xC74E, AUTO, "OpcodeList3", & ???},
-    {0, AC_WRITE,     0, nullptr, 0xC761, AUTO, "NoiseProfile", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC763, AUTO, "TimeCodes", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC764, AUTO, "FrameRate", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC772, AUTO, "TStop", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC789, AUTO, "ReelName", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC791, AUTO, "OriginalDefaultFinalSize", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC792, AUTO, "OriginalBestQualitySize", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC793, AUTO, "OriginalDefaultCropSize", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC7A1, AUTO, "CameraLabel", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC7A3, AUTO, "ProfileHueSatMapEncoding", &linearSRGBInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC7A4, AUTO, "ProfileLookTableEncoding", &linearSRGBInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC7A5, AUTO, "BaselineExposureOffset", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC7A6, AUTO, "DefaultBlackRender", &defaultBlackRenderInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC7A7, AUTO, "NewRawImageDigest", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC7A8, AUTO, "RawToPreviewGain", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC7B5, AUTO, "DefaultUserCrop", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xFDE9, AUTO, "SerialNumber", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xFDEA, AUTO, "Lens", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xFE4C, AUTO, "RawFile", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xFE4D, AUTO, "Converter", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xFE4E, AUTO, "WhiteBalance", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xFE51, AUTO, "Exposure", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xFE52, AUTO, "Shadows", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xFE53, AUTO, "Brightness", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xFE54, AUTO, "Contrast", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xFE55, AUTO, "Saturation", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xFE56, AUTO, "Sharpness", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xFE57, AUTO, "Smoothness", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xFE58, AUTO, "MoireFilter", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0, nullptr, 0, AUTO, "", nullptr }
-};
-
-
-const TagAttrib gpsAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0000, AUTO, "GPSVersionID", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0001, AUTO, "GPSLatitudeRef", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0002, AUTO, "GPSLatitude", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0003, AUTO, "GPSLongitudeRef", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0004, AUTO, "GPSLongitude", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0005, AUTO, "GPSAltitudeRef", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0006, AUTO, "GPSAltitude", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0007, AUTO, "GPSTimeStamp", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0008, AUTO, "GPSSatelites", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0009, AUTO, "GPSStatus", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000a, AUTO, "GPSMeasureMode", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000b, AUTO, "GPSDOP", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000c, AUTO, "GPSSpeedRef", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000d, AUTO, "GPSSpeed", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000e, AUTO, "GPSTrackRef", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x000f, AUTO, "GPSTrack", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0010, AUTO, "GPSImgDirectionRef", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0011, AUTO, "GPSImgDirection", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0012, AUTO, "GPSMapDatum", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0013, AUTO, "GPSDestLatitudeRef", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0014, AUTO, "GPSDestLatitude", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0015, AUTO, "GPSDestLongitudeRef", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0016, AUTO, "GPSDestLongitude", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0017, AUTO, "GPSDestBearingRef", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0018, AUTO, "GPSDestBearing", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0019, AUTO, "GPSDestDistanceRef", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x001a, AUTO, "GPSDestDistance", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x001b, AUTO, "GPSProcessingMethod", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x001c, AUTO, "GPSAreaInformation", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x001d, AUTO, "GPSDateStamp", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x001e, AUTO, "GPSDifferential", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr }
-};
-
-const TagAttrib iopAttribs[] = {
-    {0, AC_WRITE, 0, nullptr, 0x0001, AUTO, "InteroperabilityIndex", &stdInterpreter},
-    {0, AC_WRITE, 0, nullptr, 0x0002, AUTO, "InteroperabilityVersion", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0, nullptr, 0, AUTO, "", nullptr }
-};
-
-const TagAttrib ifdAttribs[] = {
-    {0, AC_SYSTEM,    0, nullptr, 0x0017, AUTO, "PanaISO", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x00fe, AUTO, "NewSubFileType", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0100, AUTO, "ImageWidth", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0101, AUTO, "ImageHeight", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0102, AUTO, "BitsPerSample", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0103, AUTO, "Compression", &compressionInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0106, AUTO, "PhotometricInterpretation", &photometricInterpreter},
-    {0, AC_WRITE,     1, nullptr, 0x010E, AUTO, "ImageDescription", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x010F, AUTO, "Make", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x0110, AUTO, "Model", &stdInterpreter},
-    {1, AC_DONTWRITE, 0, nullptr, 0x0111, AUTO, "StripOffsets", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0112, AUTO, "Orientation", &orientationInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0115, AUTO, "SamplesPerPixel", &stdInterpreter},
-    {1, AC_DONTWRITE, 0, nullptr, 0x0116, AUTO, "RowsPerStrip", &stdInterpreter},
-    {1, AC_DONTWRITE, 0, nullptr, 0x0117, AUTO, "StripByteCounts", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x011A, AUTO, "XResolution", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x011B, AUTO, "YResolution", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x011C, AUTO, "PlanarConfiguration", &planarConfigInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0128, AUTO, "ResolutionUnit", &unitsInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x012D, AUTO, "TransferFunction", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0131, AUTO, "Software", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x0132, AUTO, "DateTime", &stdInterpreter},
-    {0, AC_WRITE,     1, nullptr, 0x013B, AUTO, "Artist", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x013E, AUTO, "WhitePoint", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x013F, AUTO, "PriomaryChromaticities", &stdInterpreter},
-    {0, AC_WRITE,     0, ifdAttribs, 0x014A, AUTO, "SubIFD", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0153, AUTO, "SampleFormat", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0201, AUTO, "JPEGInterchangeFormat", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0202, AUTO, "JPEGInterchangeFormatLength", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0211, AUTO, "YCbCrCoefficients", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0212, AUTO, "YCbCrSubSampling", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0213, AUTO, "YCbCrPositioning", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x0214, AUTO, "ReferenceBlackWhite", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x02bc, AUTO, "ApplicationNotes", &utf8BinInterpreter},  // XMP
-    {0, AC_WRITE,     0, nullptr, 0x4746, AUTO, "Rating", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x4749, AUTO, "RatingPercent", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x828d, AUTO, "CFAPatternDim", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x828e, AUTO, "CFAPattern", &cfaInterpreter},
-    {0, AC_WRITE,     0, kodakIfdAttribs, 0x8290, AUTO, "KodakIFD", &stdInterpreter},
-    {0, AC_WRITE,     1, nullptr, 0x8298, AUTO, "Copyright", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x83BB, AUTO, "IPTCData", &stdInterpreter},
-    {0, AC_DONTWRITE, 0, nullptr, 0x8606, AUTO, "LeafData", &stdInterpreter}, // is actually a subdir, but a proprietary format
-    {0, AC_WRITE,     0, exifAttribs, 0x8769, AUTO, "Exif", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0x8773, AUTO, "ICCProfile", &stdInterpreter},
-    {0, AC_WRITE,     0, gpsAttribs,  0x8825, AUTO, "GPSInfo", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9003, AUTO, "DateTimeOriginal", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9004, AUTO, "DateTimeDigitized", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0x9211, AUTO, "ImageNumber", &stdInterpreter},
-    {0, AC_WRITE,     0, iopAttribs,  0xA005, AUTO, "Interoperability", &stdInterpreter},
-    {0, AC_DONTWRITE, 0, nullptr, 0xC4A5, AUTO, "PrintIMInformation", &stdInterpreter},
-    {0, AC_DONTWRITE, 0, nullptr, 0xC612, AUTO, "DNGVersion", &stdInterpreter},
-    {0, AC_DONTWRITE, 0, nullptr, 0xC613, AUTO, "DNGBackwardVersion", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC614, AUTO, "UniqueCameraModel", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xC615, AUTO, "LocalizedCameraModel", &stdInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xc62f, AUTO, "CameraSerialNumber", &stdInterpreter},
-    {0, AC_SYSTEM,    0, nullptr, 0xc630, AUTO, "DNGLensInfo", &stdInterpreter},
-    {0, AC_DONTWRITE, 0, nullptr, 0xC634, AUTO, "MakerNote", &stdInterpreter}, //DNGPrivateData
-    {0, AC_SYSTEM,    0, nullptr, 0xC640, AUTO, "RawImageSegmentation", &rawImageSegmentationInterpreter},
-    {0, AC_WRITE,     0, nullptr, 0xc65d, AUTO, "RawDataUniqueID", &stdInterpreter},
-    {0, AC_DONTWRITE, 0, nullptr, 0xc761, AUTO, "NoiseProfile", &stdInterpreter},
-    { -1, AC_DONTWRITE, 0,  nullptr, 0, AUTO, "", nullptr}
-};
-}
diff --git a/rtgui/CMakeLists.txt b/rtgui/CMakeLists.txt
index 7f5c2dfe3..cb5126631 100644
--- a/rtgui/CMakeLists.txt
+++ b/rtgui/CMakeLists.txt
@@ -198,7 +198,7 @@ if(WIN32)
         ${RSVG_INCLUDE_DIRS}
         ${TIFF_INCLUDE_DIRS}
         )
-    link_directories(. "${PROJECT_SOURCE_DIR}/rtexif"
+    link_directories(.
         ${EXTRA_LIBDIR}
         ${GIOMM_LIBRARY_DIRS}
         ${GIO_LIBRARY_DIRS}
diff --git a/rtgui/cacheimagedata.cc b/rtgui/cacheimagedata.cc
index d44ca28ec..bfc4e920a 100644
--- a/rtgui/cacheimagedata.cc
+++ b/rtgui/cacheimagedata.cc
@@ -26,6 +26,15 @@
 #include "../rtengine/procparams.h"
 #include "../rtengine/settings.h"
 
+
+namespace
+{
+
+const Glib::ustring INI_GROUP_XMP_SIDECAR = "XmpSidecar";
+const Glib::ustring INI_XMP_SIDECAR_MD5 = "MD5";
+
+}
+
 CacheImageData::CacheImageData() :
     supported(false),
     format(FT_Invalid),
@@ -56,7 +65,9 @@ CacheImageData::CacheImageData() :
     greenAWBMul(-1.0),
     blueAWBMul(-1.0),
     rotate(0),
-    thumbImgType(0)
+    thumbImgType(0),
+    width(-1),
+    height(-1)
 {
 }
 
@@ -106,6 +117,12 @@ int CacheImageData::load (const Glib::ustring& fname)
                 }
             }
 
+            if (keyFile.has_group(INI_GROUP_XMP_SIDECAR)) {
+                if (keyFile.has_key(INI_GROUP_XMP_SIDECAR, INI_XMP_SIDECAR_MD5)) {
+                    xmpSidecarMd5 = keyFile.get_string(INI_GROUP_XMP_SIDECAR, INI_XMP_SIDECAR_MD5);
+                }
+            }
+
             timeValid = keyFile.has_group ("DateTime");
 
             if (timeValid) {
@@ -208,6 +225,12 @@ int CacheImageData::load (const Glib::ustring& fname)
                 if (keyFile.has_key ("FileInfo", "SampleFormat")) {
                     sampleFormat = (rtengine::IIO_Sample_Format)keyFile.get_integer ("FileInfo", "SampleFormat");
                 }
+                if (keyFile.has_key("FileInfo", "Width")) {
+                    width = keyFile.get_integer("FileInfo", "Width");
+                }
+                if (keyFile.has_key("FileInfo", "Height")) {
+                    height = keyFile.get_integer("FileInfo", "Height");
+                }
             }
 
             if (format == FT_Raw && keyFile.has_group ("ExtraRawInfo")) {
@@ -260,6 +283,8 @@ int CacheImageData::save (const Glib::ustring& fname)
     keyFile.set_boolean ("General", "RecentlySaved", recentlySaved);
     keyFile.set_integer ("General", "Rating", rating);
 
+    keyFile.set_string(INI_GROUP_XMP_SIDECAR, INI_XMP_SIDECAR_MD5, xmpSidecarMd5);
+
     // remove the old implementation of Rank and InTrash from cache
     if (keyFile.has_key ("General", "Rank")) {
         keyFile.remove_key("General", "Rank");
@@ -298,6 +323,8 @@ int CacheImageData::save (const Glib::ustring& fname)
     keyFile.set_string  ("FileInfo", "Filetype", filetype);
     keyFile.set_integer ("FileInfo", "FrameCount", frameCount);
     keyFile.set_integer ("FileInfo", "SampleFormat", sampleFormat);
+    keyFile.set_integer("FileInfo", "Width", width);
+    keyFile.set_integer("FileInfo", "Height", height);
 
     if (format == FT_Raw) {
         keyFile.set_integer ("ExtraRawInfo", "ThumbImageType", thumbImgType);
@@ -335,7 +362,3 @@ int CacheImageData::save (const Glib::ustring& fname)
     }
 }
 
-rtengine::procparams::IPTCPairs CacheImageData::getIPTCData(unsigned int frame) const
-{
-    return {};
-}
diff --git a/rtgui/cacheimagedata.h b/rtgui/cacheimagedata.h
index caab1de5b..8c0fa6513 100644
--- a/rtgui/cacheimagedata.h
+++ b/rtgui/cacheimagedata.h
@@ -39,6 +39,9 @@ public:
     bool  inTrashOld; // old implementation of inTrash
     bool  recentlySaved;
 
+    // XMP sidecar info.
+    Glib::ustring xmpSidecarMd5;
+
     // time/date info
     bool  timeValid;
     short year;
@@ -80,6 +83,9 @@ public:
         QUICK_THUMBNAIL = 1  // was the thumbnail generated from embedded jpeg
     };
 
+    int width;
+    int height;
+
     CacheImageData ();
 
     int load (const Glib::ustring& fname);
@@ -89,30 +95,30 @@ public:
     // FramesMetaData interface
     //-------------------------------------------------------------------------
 
-    unsigned int getRootCount () const override { return -1; }
     unsigned int getFrameCount () const override { return frameCount; }
-    bool hasExif (unsigned int frame = 0) const override  { return false; }
-    rtexif::TagDirectory* getRootExifData (unsigned int root = 0) const override { return nullptr; }
-    rtexif::TagDirectory* getFrameExifData (unsigned int frame = 0) const override { return nullptr; }
-    rtexif::TagDirectory* getBestExifData (rtengine::ImageSource *imgSource, rtengine::procparams::RAWParams *rawParams) const override { return nullptr; }
-    bool hasIPTC (unsigned int frame = 0) const override { return false; }
-    rtengine::procparams::IPTCPairs getIPTCData (unsigned int frame = 0) const override;
-    tm getDateTime (unsigned int frame = 0) const override { return tm{}; }
-    time_t getDateTimeAsTS(unsigned int frame = 0) const override { return time_t(-1); }
-    int getISOSpeed (unsigned int frame = 0) const override { return iso; }
-    double getFNumber  (unsigned int frame = 0) const override { return fnumber; }
-    double getFocalLen (unsigned int frame = 0) const override { return focalLen; }
-    double getFocalLen35mm (unsigned int frame = 0) const override { return focalLen35mm; }
-    float getFocusDist (unsigned int frame = 0) const override { return focusDist; }
-    double getShutterSpeed (unsigned int frame = 0) const override { return shutter; }
-    double getExpComp (unsigned int frame = 0) const override { return atof(expcomp.c_str()); }
-    std::string getMake     (unsigned int frame = 0) const override { return camMake; }
-    std::string getModel    (unsigned int frame = 0) const override { return camModel; }
-    std::string getLens     (unsigned int frame = 0) const override { return lens; }
-    std::string getOrientation (unsigned int frame = 0) const override { return ""; } // TODO
-    int getRating (unsigned int frame = 0) const override { return rating; } // FIXME-piotr : missing rating
+    bool hasExif() const override  { return false; }
+    tm getDateTime() const override { return tm{}; }
+    time_t getDateTimeAsTS() const override { return time_t(-1); }
+    int getISOSpeed() const override { return iso; }
+    double getFNumber() const override { return fnumber; }
+    double getFocalLen() const override { return focalLen; }
+    double getFocalLen35mm() const override { return focalLen35mm; }
+    float getFocusDist() const override { return focusDist; }
+    double getShutterSpeed() const override { return shutter; }
+    double getExpComp() const override { return atof(expcomp.c_str()); }
+    std::string getMake() const override { return camMake; }
+    std::string getModel() const override { return camModel; }
+    std::string getLens() const override { return lens; }
+    std::string getOrientation() const override { return ""; } // TODO
+    Glib::ustring getFileName() const override { return ""; }
+    int getRating () const override { return rating; } // FIXME-piotr : missing rating
     bool getPixelShift () const override { return isPixelShift; }
-    bool getHDR (unsigned int frame = 0) const override { return isHDR; }
-    std::string getImageType (unsigned int frame) const override { return isPixelShift ? "PS" : isHDR ? "HDR" : "STD"; }
-    rtengine::IIOSampleFormat getSampleFormat (unsigned int frame = 0) const override { return sampleFormat; }
+    bool getHDR() const override { return isHDR; }
+    std::string getImageType() const override { return isPixelShift ? "PS" : isHDR ? "HDR" : "STD"; }
+    rtengine::IIOSampleFormat getSampleFormat() const override { return sampleFormat; }
+    void getDimensions(int &w, int &h) const override
+    {
+        w = width;
+        h = height;
+    }
 };
diff --git a/rtgui/cachemanager.cc b/rtgui/cachemanager.cc
index 5e540b604..4d865ce76 100644
--- a/rtgui/cachemanager.cc
+++ b/rtgui/cachemanager.cc
@@ -97,6 +97,10 @@ Thumbnail* CacheManager::getEntry (const Glib::ustring& fname)
     }
 
     const auto cacheName = getCacheFileName ("data", fname, ".txt", md5);
+    const auto xmpSidecarMd5 =
+        rtengine::settings->metadata_xmp_sync != rtengine::Settings::MetadataXmpSync::NONE
+        ? getMD5(Thumbnail::xmpSidecarPath(fname))
+        : "";
 
     // let's see if we have it in the cache
     {
@@ -106,6 +110,11 @@ Thumbnail* CacheManager::getEntry (const Glib::ustring& fname)
 
         if (error == 0 && imageData.supported) {
 
+            if (xmpSidecarMd5 != imageData.xmpSidecarMd5) {
+                updateImageInfo(fname, imageData, xmpSidecarMd5);
+                imageData.save(cacheName);
+            }
+
             thumbnail.reset (new Thumbnail (this, fname, &imageData));
 
             if (!thumbnail->isSupported ()) {
@@ -117,7 +126,7 @@ Thumbnail* CacheManager::getEntry (const Glib::ustring& fname)
     // if not, create a new one
     if (!thumbnail) {
 
-        thumbnail.reset (new Thumbnail (this, fname, md5));
+        thumbnail.reset (new Thumbnail (this, fname, md5, xmpSidecarMd5));
 
         if (!thumbnail->isSupported ()) {
             thumbnail.reset ();
@@ -413,3 +422,9 @@ void CacheManager::applyCacheSizeLimitation () const
     }
 }
 
+void CacheManager::updateImageInfo(const Glib::ustring &fname, CacheImageData &imageData, const Glib::ustring &xmpSidecarMd5) const
+{
+    Thumbnail::infoFromImage(fname, imageData);
+    imageData.xmpSidecarMd5 = xmpSidecarMd5;
+}
+
diff --git a/rtgui/cachemanager.h b/rtgui/cachemanager.h
index 61602aeba..a7ab14f0a 100644
--- a/rtgui/cachemanager.h
+++ b/rtgui/cachemanager.h
@@ -27,6 +27,7 @@
 
 #include "../rtengine/noncopyable.h"
 
+class CacheImageData;
 class Thumbnail;
 
 class CacheManager :
@@ -42,6 +43,7 @@ private:
     void deleteFiles (const Glib::ustring& fname, const std::string& md5, bool purgeData, bool purgeProfile) const;
 
     void applyCacheSizeLimitation () const;
+    void updateImageInfo(const Glib::ustring &fname, CacheImageData &imageData, const Glib::ustring &xmpSidecarMd5) const;
 
 public:
     static CacheManager* getInstance ();
diff --git a/rtgui/controllines.cc b/rtgui/controllines.cc
index d28ef12ca..08f9eda37 100644
--- a/rtgui/controllines.cc
+++ b/rtgui/controllines.cc
@@ -79,7 +79,7 @@ constexpr int mouseOverIdToLineId(int mouse_over_id)
 
 ControlLineManager::ControlLineManager():
     EditSubscriber(ET_OBJECTS),
-    canvas_area(new Rectangle()),
+    canvas_area(new EditRectangle()),
     cursor(CSHandOpen),
     draw_mode(false),
     drawing_line(false),
diff --git a/rtgui/controllines.h b/rtgui/controllines.h
index 9e850da1c..7f3f74b7b 100644
--- a/rtgui/controllines.h
+++ b/rtgui/controllines.h
@@ -26,9 +26,10 @@
 class Circle;
 class Line;
 class OPIcon;
-class Rectangle;
+class EditRectangle; 
 class RTSurface;
 
+
 struct ControlLine {
     enum ObjectIndex {
         LINE,
@@ -52,7 +53,7 @@ class ControlLineManager: EditSubscriber
 
 protected:
     /** Hidden object for capturing mouse events. */
-    std::unique_ptr<Rectangle> canvas_area;
+    std::unique_ptr<EditRectangle> canvas_area;
     rtengine::Coord drag_delta;
     std::vector<std::unique_ptr<ControlLine>> control_lines;
     CursorShape cursor;
diff --git a/rtgui/controlspotpanel.cc b/rtgui/controlspotpanel.cc
index 60fde12a6..a29a3a885 100644
--- a/rtgui/controlspotpanel.cc
+++ b/rtgui/controlspotpanel.cc
@@ -1977,8 +1977,8 @@ void ControlSpotPanel::addControlSpotCurve(Gtk::TreeModel::Row& row)
     shape_ellipse = new Ellipse();
     shape_ellipse->datum = Geometry::IMAGE;
     shape_ellipse->radiusInImageSpace = true;
-    Rectangle* shape_rectangle;
-    shape_rectangle = new Rectangle();
+    EditRectangle* shape_rectangle;
+    shape_rectangle = new EditRectangle();
     shape_rectangle->datum = Geometry::IMAGE;
     EditSubscriber::visibleGeometry.push_back(centerCircle); // (curveid - 1) * 7
     EditSubscriber::visibleGeometry.push_back(shape_ellipse); // (curveid - 1) * 7 + 1
@@ -2012,7 +2012,7 @@ void ControlSpotPanel::addControlSpotCurve(Gtk::TreeModel::Row& row)
     shape_ellipse = new Ellipse();
     shape_ellipse->datum = Geometry::IMAGE;
     shape_ellipse->radiusInImageSpace = true;
-    shape_rectangle = new Rectangle();
+    shape_rectangle = new EditRectangle();
     shape_rectangle->datum = Geometry::IMAGE;
     EditSubscriber::mouseOverGeometry.push_back(centerCircle);  // (curveid - 1) * 7
     EditSubscriber::mouseOverGeometry.push_back(shape_ellipse);  // (curveid - 1) * 7 + 1
@@ -2082,7 +2082,7 @@ void ControlSpotPanel::updateControlSpotCurve(const Gtk::TreeModel::Row& row)
     };
 
     const auto updateRectangle = [&](Geometry * geometry) {
-        const auto rectangle = static_cast<Rectangle*>(geometry);
+        const auto rectangle = static_cast<EditRectangle*>(geometry);
         rectangle->bottomRight.x = origin.x + decayX;
         rectangle->bottomRight.y = origin.y + decayY;
         rectangle->topLeft.x = origin.x - decayXL;
diff --git a/rtgui/editorpanel.cc b/rtgui/editorpanel.cc
index 420717b7e..8df43aeed 100644
--- a/rtgui/editorpanel.cc
+++ b/rtgui/editorpanel.cc
@@ -721,7 +721,8 @@ EditorPanel::EditorPanel (FilePanel* filePanel)
     firstProcessingDone = false;
 
     // construct toolpanelcoordinator
-    tpc = new ToolPanelCoordinator ();
+    tpc = new ToolPanelCoordinator();
+    tpc->setProgressListener(this);
 
     // build GUI
 
@@ -1464,6 +1465,7 @@ void EditorPanel::setProgressState(bool inProcessing)
 
 void EditorPanel::error(const Glib::ustring& descr)
 {
+    parent->error(descr);
 }
 
 void EditorPanel::error(const Glib::ustring& title, const Glib::ustring& descr)
@@ -1570,16 +1572,16 @@ void EditorPanel::info_toggled ()
 
     const rtengine::FramesMetaData* idata = ipc->getInitialImage()->getMetaData();
 
-    if (idata && idata->hasExif(selectedFrame)) {
+    if (idata && idata->hasExif()) {
         infoString = Glib::ustring::compose ("%1 + %2\n<span size=\"small\">f/</span><span size=\"large\">%3</span>  <span size=\"large\">%4</span><span size=\"small\">s</span>  <span size=\"small\">%5</span><span size=\"large\">%6</span>  <span size=\"large\">%7</span><span size=\"small\">mm</span>",
                                               escapeHtmlChars (idata->getMake() + " " + idata->getModel()),
                                               escapeHtmlChars (idata->getLens()),
-                                              Glib::ustring (idata->apertureToString (idata->getFNumber(selectedFrame))),
-                                              Glib::ustring (idata->shutterToString (idata->getShutterSpeed(selectedFrame))),
-                                              M ("QINFO_ISO"), idata->getISOSpeed(selectedFrame),
-                                              Glib::ustring::format (std::setw (3), std::fixed, std::setprecision (2), idata->getFocalLen(selectedFrame)));
+                                              Glib::ustring (idata->apertureToString (idata->getFNumber())),
+                                              Glib::ustring (idata->shutterToString (idata->getShutterSpeed())),
+                                              M ("QINFO_ISO"), idata->getISOSpeed(),
+                                              Glib::ustring::format (std::setw (3), std::fixed, std::setprecision (2), idata->getFocalLen()));
 
-        expcomp = Glib::ustring (idata->expcompToString (idata->getExpComp(selectedFrame), true)); // maskZeroexpcomp
+        expcomp = Glib::ustring (idata->expcompToString (idata->getExpComp(), true)); // maskZeroexpcomp
 
         if (!expcomp.empty ()) {
             infoString = Glib::ustring::compose ("%1  <span size=\"large\">%2</span><span size=\"small\">EV</span>",
@@ -1592,8 +1594,13 @@ void EditorPanel::info_toggled ()
                                               escapeHtmlChars (Glib::path_get_dirname (openThm->getFileName())) + G_DIR_SEPARATOR_S,
                                               escapeHtmlChars (Glib::path_get_basename (openThm->getFileName()))  );
 
-        int ww = ipc->getFullWidth();
-        int hh = ipc->getFullHeight();
+        int ww = -1, hh = -1;
+        idata->getDimensions(ww, hh);
+        if (ww <= 0) {
+            ww = ipc->getFullWidth();
+            hh = ipc->getFullHeight();
+        }
+
         //megapixels
         infoString = Glib::ustring::compose ("%1\n<span size=\"small\">%2 MP (%3x%4)</span>",
                                              infoString,
@@ -1607,7 +1614,7 @@ void EditorPanel::info_toggled ()
         if (isHDR) {
             infoString = Glib::ustring::compose ("%1\n" + M("QINFO_HDR"), infoString, numFrames);
             if (numFrames == 1) {
-                int sampleFormat = idata->getSampleFormat(selectedFrame);
+                int sampleFormat = idata->getSampleFormat();
                 infoString = Glib::ustring::compose ("%1 / %2", infoString, M(Glib::ustring::compose("SAMPLEFORMAT_%1", sampleFormat)));
             }
         } else if (isPixelShift) {
@@ -2361,7 +2368,7 @@ bool EditorPanel::idle_sendToGimp ( ProgressConnector<rtengine::IImagefloat*> *p
             sf.tiffBits = 16;
             sf.tiffFloat = false;
         }
-        
+
         sf.tiffUncompressed = true;
         sf.saveParams = true;
 
diff --git a/rtgui/editwidgets.cc b/rtgui/editwidgets.cc
index f9c9b3781..7ae874673 100644
--- a/rtgui/editwidgets.cc
+++ b/rtgui/editwidgets.cc
@@ -475,31 +475,31 @@ void Polyline::drawToMOChannel (Cairo::RefPtr<Cairo::Context> &cr, unsigned shor
     }
 }
 
-void Rectangle::setXYWH(int left, int top, int width, int height)
+void EditRectangle::setXYWH(int left, int top, int width, int height)
 {
     topLeft.set(left, top);
     bottomRight.set(left + width, top + height);
 }
 
-void Rectangle::setXYXY(int left, int top, int right, int bottom)
+void EditRectangle::setXYXY(int left, int top, int right, int bottom)
 {
     topLeft.set(left, top);
     bottomRight.set(right, bottom);
 }
 
-void Rectangle::setXYWH(rtengine::Coord topLeft, rtengine::Coord widthHeight)
+void EditRectangle::setXYWH(rtengine::Coord topLeft, rtengine::Coord widthHeight)
 {
     this->topLeft = topLeft;
     this->bottomRight = topLeft + widthHeight;
 }
 
-void Rectangle::setXYXY(rtengine::Coord topLeft, rtengine::Coord bottomRight)
+void EditRectangle::setXYXY(rtengine::Coord topLeft, rtengine::Coord bottomRight)
 {
     this->topLeft = topLeft;
     this->bottomRight = bottomRight;
 }
 
-void Rectangle::drawOuterGeometry(Cairo::RefPtr<Cairo::Context> &cr, ObjectMOBuffer *objectBuffer, EditCoordSystem &coordSystem)
+void EditRectangle::drawOuterGeometry(Cairo::RefPtr<Cairo::Context> &cr, ObjectMOBuffer *objectBuffer, EditCoordSystem &coordSystem)
 {
     double lineWidth = getOuterLineWidth();
     if ((flags & F_VISIBLE) && state != INSENSITIVE && lineWidth > 0. && innerLineWidth > 0.) {
@@ -544,7 +544,7 @@ void Rectangle::drawOuterGeometry(Cairo::RefPtr<Cairo::Context> &cr, ObjectMOBuf
     }
 }
 
-void Rectangle::drawInnerGeometry(Cairo::RefPtr<Cairo::Context> &cr, ObjectMOBuffer *objectBuffer, EditCoordSystem &coordSystem)
+void EditRectangle::drawInnerGeometry(Cairo::RefPtr<Cairo::Context> &cr, ObjectMOBuffer *objectBuffer, EditCoordSystem &coordSystem)
 {
     if (flags & F_VISIBLE) {
         if (state != INSENSITIVE) {
@@ -604,7 +604,7 @@ void Rectangle::drawInnerGeometry(Cairo::RefPtr<Cairo::Context> &cr, ObjectMOBuf
     }
 }
 
-void Rectangle::drawToMOChannel(Cairo::RefPtr<Cairo::Context> &cr, unsigned short id, ObjectMOBuffer *objectBuffer, EditCoordSystem &coordSystem)
+void EditRectangle::drawToMOChannel(Cairo::RefPtr<Cairo::Context> &cr, unsigned short id, ObjectMOBuffer *objectBuffer, EditCoordSystem &coordSystem)
 {
     if (flags & F_HOVERABLE) {
         cr->set_line_width( getMouseOverLineWidth() );
diff --git a/rtgui/editwidgets.h b/rtgui/editwidgets.h
index fd539c355..f1cdcf87f 100644
--- a/rtgui/editwidgets.h
+++ b/rtgui/editwidgets.h
@@ -313,14 +313,14 @@ public:
     void drawToMOChannel (Cairo::RefPtr<Cairo::Context> &cr, unsigned short id, ObjectMOBuffer *objectBuffer, EditCoordSystem &coordSystem) override;
 };
 
-class Rectangle : public Geometry
+class EditRectangle : public Geometry // New class name to avoid conflict elsewhere (exiv2), would be nicer to put in namespace?
 {
 public:
     rtengine::Coord topLeft;
     rtengine::Coord bottomRight;
     bool filled;
 
-    Rectangle ();
+    EditRectangle ();
 
     void setXYWH(int left, int top, int width, int height);
     void setXYXY(int left, int top, int right, int bottom);
@@ -546,7 +546,7 @@ inline Circle::Circle () :
                 false) {
 }
 
-inline Rectangle::Rectangle () :
+inline EditRectangle::EditRectangle () :
         topLeft (0, 0), bottomRight (10, 10), filled (false) {
 }
 
diff --git a/rtgui/exifpanel.cc b/rtgui/exifpanel.cc
index eeff0c8c7..487635f5b 100644
--- a/rtgui/exifpanel.cc
+++ b/rtgui/exifpanel.cc
@@ -16,26 +16,34 @@
  *  You should have received a copy of the GNU General Public License
  *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
  */
+#include <unordered_set>
+
 #include "exifpanel.h"
 
 #include "guiutils.h"
 #include "rtimage.h"
 #include "options.h"
 
+#include "../rtengine/imagedata.h"
+#include "../rtengine/metadata.h"
 #include "../rtengine/procparams.h"
 
+#include <glibmm/regex.h>
+
 using namespace rtengine;
 using namespace rtengine::procparams;
-using namespace rtexif;
 
 ExifPanel::ExifPanel() :
     idata(nullptr),
     changeList(new rtengine::procparams::ExifPairs),
-    defChangeList(new rtengine::procparams::ExifPairs)
+    defChangeList(new rtengine::procparams::ExifPairs),
+    pl_(nullptr)
 {
-    set_orientation(Gtk::ORIENTATION_VERTICAL);
-    recursiveOp = true;
+    for (auto &k : MetaDataParams::basicExifKeys) {
+        editableTags.push_back(std::make_pair(k, ""));
+    }
 
+    set_orientation(Gtk::ORIENTATION_VERTICAL);
     exifTree = Gtk::manage (new Gtk::TreeView());
     scrolledWindow = Gtk::manage (new Gtk::ScrolledWindow());
 
@@ -43,47 +51,58 @@ ExifPanel::ExifPanel() :
     exifTree->set_rules_hint (false);
     exifTree->set_reorderable (false);
     exifTree->set_enable_search (false);
-    exifTree->get_selection()->set_mode (Gtk::SELECTION_MULTIPLE);
-    scrolledWindow->set_shadow_type (Gtk::SHADOW_NONE);
-    scrolledWindow->set_policy (Gtk::POLICY_ALWAYS, Gtk::POLICY_ALWAYS);
-    scrolledWindow->property_window_placement().set_value (Gtk::CORNER_TOP_LEFT);
-    scrolledWindow->add (*exifTree);
-
-    exifTreeModel = Gtk::TreeStore::create (exifColumns);
-    exifTree->set_model (exifTreeModel);
-    exifTree->set_grid_lines (Gtk::TREE_VIEW_GRID_LINES_NONE);
-    exifTree->set_row_separator_func (sigc::mem_fun(*this, &ExifPanel::rowSeperatorFunc));
-
-    delicon = RTImage::createPixbufFromFile ("cancel-small.png");
-    keepicon = RTImage::createPixbufFromFile ("tick-small.png");
-    editicon = RTImage::createPixbufFromFile ("add-small.png");
+    exifTree->get_selection()->set_mode(Gtk::SELECTION_SINGLE);
+    scrolledWindow->set_shadow_type(Gtk::SHADOW_NONE);
+    scrolledWindow->set_policy(Gtk::POLICY_ALWAYS, Gtk::POLICY_ALWAYS);
+    scrolledWindow->property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+    scrolledWindow->add(*exifTree);
+
+    exifTreeModel = Gtk::TreeStore::create(exifColumns);
+    exifTree->set_model(exifTreeModel);
+    exifTree->set_grid_lines(Gtk::TREE_VIEW_GRID_LINES_NONE);
+    exifTree->set_show_expanders(false);
+    exifTree->set_tooltip_column(0);
+    exifTree->set_enable_search(false);
+
+    //keepicon = RTImage::createPixbufFromFile("tick-small.png");
+    editicon = RTImage::createPixbufFromFile("edit-small.png");
+    open_icon_ = RTImage::createPixbufFromFile("expander-open-small.png");
+    closed_icon_ = RTImage::createPixbufFromFile("expander-closed-small.png");
+
+    exif_active_renderer_.property_mode() = Gtk::CELL_RENDERER_MODE_ACTIVATABLE;
+    exif_active_renderer_.signal_toggled().connect(sigc::mem_fun(this, &ExifPanel::onKeyActiveToggled));
+    exif_active_column_.pack_start(exif_active_renderer_);
+    exif_active_column_.set_cell_data_func(exif_active_renderer_, sigc::mem_fun(this, &ExifPanel::setKeyActive));
+
+    exifTree->append_column(exif_active_column_);
 
     Gtk::TreeView::Column *viewcol = Gtk::manage (new Gtk::TreeView::Column ("Field Name"));
     Gtk::CellRendererPixbuf* render_pb = Gtk::manage (new Gtk::CellRendererPixbuf ());
     Gtk::CellRendererText *render_txt = Gtk::manage (new Gtk::CellRendererText());
     render_txt->property_ellipsize() = Pango::ELLIPSIZE_END;
-    viewcol->pack_start (*render_pb, false);
-    viewcol->pack_start (*render_txt, true);
-    viewcol->add_attribute (*render_pb, "pixbuf", exifColumns.icon);
-    viewcol->add_attribute (*render_txt, "markup", exifColumns.field);
-    viewcol->set_expand (true);
-    viewcol->set_resizable (true);
-    viewcol->set_fixed_width (35);
-    viewcol->set_min_width (35);
-    viewcol->set_sizing (Gtk::TREE_VIEW_COLUMN_AUTOSIZE);
+    viewcol->pack_start(*render_pb, false);
+    viewcol->pack_start(*render_txt, true);
+    viewcol->add_attribute(*render_pb, "pixbuf", exifColumns.icon);
+    viewcol->add_attribute(*render_txt, "markup", exifColumns.label);
+    viewcol->set_expand(true);
+    viewcol->set_resizable(true);
+    viewcol->set_fixed_width(35);
+    viewcol->set_min_width(35);
+    viewcol->set_sizing(Gtk::TREE_VIEW_COLUMN_AUTOSIZE);
 
     render_pb->property_ypad() = 0;
     render_txt->property_ypad() = 0;
     render_pb->property_yalign() = 0;
     render_txt->property_yalign() = 0;
 
-    exifTree->append_column (*viewcol);
+    exifTree->append_column(*viewcol);
+    //exifTree->set_expander_column(*viewcol);
 
-    Gtk::TreeView::Column *viewcolv = Gtk::manage (new Gtk::TreeView::Column ("Value"));
-    Gtk::CellRendererText *render_txtv = Gtk::manage (new Gtk::CellRendererText());
+    Gtk::TreeView::Column *viewcolv = Gtk::manage(new Gtk::TreeView::Column ("Value"));
+    Gtk::CellRendererText *render_txtv = Gtk::manage(new Gtk::CellRendererText());
     render_txtv->property_ellipsize() = Pango::ELLIPSIZE_END;
     viewcolv->pack_start (*render_txtv, true);
-    viewcolv->add_attribute (*render_txtv, "markup", exifColumns.value);
+    // viewcolv->add_attribute (*render_txtv, "markup", exifColumns.value);
     viewcolv->set_expand (true);
     viewcolv->set_resizable (true);
     viewcol->set_fixed_width (35);
@@ -91,8 +110,10 @@ ExifPanel::ExifPanel() :
     viewcolv->set_sizing (Gtk::TREE_VIEW_COLUMN_AUTOSIZE);
 
     render_txtv->property_ypad() = 0;
+    viewcolv->set_cell_data_func(*render_txtv, sigc::mem_fun(this, &ExifPanel::setExifTagValue));
+    render_txtv->signal_edited().connect(sigc::mem_fun(this, &ExifPanel::onEditExifTagValue));
 
-    exifTree->append_column (*viewcolv);
+    exifTree->append_column(*viewcolv);
 
     pack_start (*scrolledWindow);
 
@@ -100,65 +121,38 @@ ExifPanel::ExifPanel() :
     buttons1->set_row_homogeneous (true);
     buttons1->set_column_homogeneous (true);
     setExpandAlignProperties (buttons1, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    Gtk::Grid* buttons2 = Gtk::manage (new Gtk::Grid());
-    buttons2->set_row_homogeneous (true);
-    buttons2->set_column_homogeneous (true);
-    setExpandAlignProperties (buttons2, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-
-    remove = Gtk::manage (new Gtk::Button ()); // M("EXIFPANEL_REMOVE")
-    remove->set_image (*Gtk::manage (new RTImage(delicon)));
-    remove->set_tooltip_text (M ("EXIFPANEL_REMOVEHINT"));
-    remove->get_style_context()->add_class ("Left");
-    setExpandAlignProperties (remove, true, true, Gtk::ALIGN_FILL, Gtk::ALIGN_FILL);
-    buttons1->attach_next_to (*remove, Gtk::POS_LEFT, 1, 1);
-
-    keep = Gtk::manage (new Gtk::Button ()); // M("EXIFPANEL_KEEP")
-    keep->set_image (*Gtk::manage (new RTImage(keepicon)));
-    keep->set_tooltip_text (M ("EXIFPANEL_KEEPHINT"));
-    keep->get_style_context()->add_class ("MiddleH");
-    setExpandAlignProperties (keep, true, true, Gtk::ALIGN_FILL, Gtk::ALIGN_FILL);
-    buttons1->attach_next_to (*keep, Gtk::POS_RIGHT, 1, 1);
-
-    add = Gtk::manage (new Gtk::Button ()); // M("EXIFPANEL_ADDEDIT")
-    add->set_image (*Gtk::manage (new RTImage(editicon)));
-    add->set_tooltip_text (M ("EXIFPANEL_ADDEDITHINT"));
-    add->get_style_context()->add_class ("Right");
-    setExpandAlignProperties (add, true, true, Gtk::ALIGN_FILL, Gtk::ALIGN_FILL);
-    buttons1->attach_next_to (*add, Gtk::POS_RIGHT, 1, 1);
-
-    showAll = Gtk::manage (new Gtk::ToggleButton (M ("EXIFPANEL_SHOWALL")));
-    //add->set_tooltip_text (M("EXIFPANEL_SHOWALL"));
-    showAll->get_style_context()->add_class ("Left");
-    setExpandAlignProperties (showAll, false, true, Gtk::ALIGN_FILL, Gtk::ALIGN_FILL);
-    showAll->set_active (options.lastShowAllExif);
-    buttons2->attach_next_to (*showAll, Gtk::POS_LEFT, 1, 1);
-
-    reset = Gtk::manage (new Gtk::Button ()); // M("EXIFPANEL_RESET")
-    reset->set_image (*Gtk::manage (new RTImage("undo.png", "redo.png")));
-    reset->set_tooltip_text (M ("EXIFPANEL_RESETHINT"));
-    reset->get_style_context()->add_class ("MiddleH");
-    setExpandAlignProperties (reset, true, true, Gtk::ALIGN_FILL, Gtk::ALIGN_FILL);
-    buttons2->attach_next_to (*reset, Gtk::POS_RIGHT, 1, 1);
-
-    resetAll = Gtk::manage (new Gtk::Button ()); // M("EXIFPANEL_RESETALL")
-    resetAll->set_image (*Gtk::manage (new RTImage ("undo-all.png", "redo-all.png")));
-    resetAll->set_tooltip_text (M ("EXIFPANEL_RESETALLHINT"));
-    resetAll->get_style_context()->add_class ("Right");
-    setExpandAlignProperties (resetAll, false, false, Gtk::ALIGN_FILL, Gtk::ALIGN_FILL);
-    buttons2->attach_next_to (*resetAll, Gtk::POS_RIGHT, 1, 1);
-
-    pack_end (*buttons2, Gtk::PACK_SHRINK);
+
+    const auto addbtn =
+        [&](const Glib::ustring &tip, const Glib::ustring &icon1, const Glib::ustring &icon2=Glib::ustring()) -> Gtk::Button *
+        {
+            Gtk::Button *b = Gtk::manage(new Gtk::Button());
+            b->set_image(*Gtk::manage(new RTImage(icon1, icon2)));
+            b->set_tooltip_text(M(tip));
+            b->get_style_context()->add_class("Right");
+            setExpandAlignProperties(b, true, true, Gtk::ALIGN_FILL, Gtk::ALIGN_FILL);
+            buttons1->attach_next_to(*b, Gtk::POS_RIGHT, 1, 1);
+            return b;
+        };
+
+    activate_all_ = addbtn("EXIFPANEL_ACTIVATE_ALL_HINT", "tick.png");
+    activate_none_ = addbtn("EXIFPANEL_ACTIVATE_NONE_HINT", "box.png");
+    add = addbtn("EXIFPANEL_ADDEDIT", "edit.png");
+    reset = addbtn("EXIFPANEL_RESETHINT", "undo.png", "redo.png");
+    resetAll = addbtn("EXIFPANEL_RESETALLHINT", "undo-all.png", "redo-all.png");
+
     pack_end (*buttons1, Gtk::PACK_SHRINK);
 
     exifTree->get_selection()->signal_changed().connect (sigc::mem_fun (*this, &ExifPanel::exifSelectionChanged));
-    exifTree->signal_row_activated().connect (sigc::mem_fun (*this, &ExifPanel::row_activated));
 
-    remove->signal_clicked().connect ( sigc::mem_fun (*this, &ExifPanel::removePressed) );
-    keep->signal_clicked().connect ( sigc::mem_fun (*this, &ExifPanel::keepPressed) );
     reset->signal_clicked().connect ( sigc::mem_fun (*this, &ExifPanel::resetPressed) );
     resetAll->signal_clicked().connect ( sigc::mem_fun (*this, &ExifPanel::resetAllPressed) );
     add->signal_clicked().connect ( sigc::mem_fun (*this, &ExifPanel::addPressed) );
-    showAll->signal_toggled().connect ( sigc::mem_fun (*this, &ExifPanel::showAlltoggled) );
+    activate_all_->signal_clicked().connect(sigc::mem_fun(*this, &ExifPanel::activateAllPressed));
+    activate_none_->signal_clicked().connect(sigc::mem_fun(*this, &ExifPanel::activateNonePressed));
+
+    exifTree->signal_button_press_event().connect_notify(sigc::mem_fun(*this, &ExifPanel::onExifTreeClick));
+    exifTree->signal_row_expanded().connect(sigc::mem_fun(*this, &ExifPanel::onExifRowExpanded));
+    exifTree->signal_row_collapsed().connect(sigc::mem_fun(*this, &ExifPanel::onExifRowCollapsed));
 
     show_all ();
 }
@@ -169,557 +163,593 @@ ExifPanel::~ExifPanel ()
 
 void ExifPanel::read (const ProcParams* pp, const ParamsEdited* pedited)
 {
+    disableListener();
 
-    disableListener ();
-
-    *changeList = pp->exif;
-    setImageData (idata);
-    applyChangeList ();
-    exifSelectionChanged ();
+    *changeList = pp->metadata.exif;
+    initial_active_keys_.clear();
+    initial_active_keys_.insert(pp->metadata.exifKeys.begin(), pp->metadata.exifKeys.end());
+    cur_active_keys_ = initial_active_keys_;
+    setImageData(idata);
+    refreshTags();
 
-    enableListener ();
+    enableListener();
 }
 
+
 void ExifPanel::write (ProcParams* pp, ParamsEdited* pedited)
 {
-
-//    updateChangeList ();
-    pp->exif = *changeList;
+    pp->metadata.exif = *changeList;
+    cur_active_keys_ = get_active_keys();
+    pp->metadata.exifKeys.assign(cur_active_keys_.begin(), cur_active_keys_.end());
+    std::sort(pp->metadata.exifKeys.begin(), pp->metadata.exifKeys.end());
 }
 
 void ExifPanel::setDefaults (const ProcParams* defParams, const ParamsEdited* pedited)
 {
-
-    *defChangeList = defParams->exif;
+    *defChangeList = defParams->metadata.exif;
 }
 
 void ExifPanel::setImageData (const FramesMetaData* id)
 {
-
     idata = id;
-    exifTreeModel->clear ();
-
-    if (idata) {
-        for (unsigned int rootNum = 0; rootNum < id->getRootCount (); ++rootNum) {
-            if ( id->getRootExifData (rootNum)) {
-                addDirectory (id->getRootExifData (rootNum), exifTreeModel->children(), rootNum > 0);
-            }
-        }
-    }
 }
 
-Gtk::TreeModel::Children ExifPanel::addTag (const Gtk::TreeModel::Children& root, Glib::ustring field, Glib::ustring value, rtexif::ActionCode action, bool editable)
+void ExifPanel::addTag(const std::string &key, const std::pair<Glib::ustring, Glib::ustring> &label, const Glib::ustring &exifValue, bool editable, bool edited)
 {
-    if (!value.validate()) {
-        value = "???";
-    }
 
-    Gtk::TreeModel::Row row = * (exifTreeModel->append (root));
-    row[exifColumns.action]   = action;
+    const Glib::ustring& value = exifValue.validate() ? exifValue : "???";
+
+//    auto root = exifTreeModel->children();
+
+    const auto getgroup =
+        [&]() -> Gtk::TreeNodeChildren
+        {
+            auto root = exifTreeModel->children();
+
+            // for (auto it = root.rbegin(), end = root.rend(); it != end; ++it) {
+            //     auto row = *it;
+            for (auto &row : root) {
+                // auto row = *it;
+                std::string key = row[exifColumns.key];
+                if (row[exifColumns.is_group] && key == label.first) {
+                    return row./*it->*/children();
+                }
+            }
+            auto it = exifTreeModel->append(root);
+            auto row = *it;
+
+            row[exifColumns.editable] = false;
+            row[exifColumns.edited] = false;
+            row[exifColumns.key] = label.first;
+            row[exifColumns.label] = "<b>" + label.first + "</b>";
+            row[exifColumns.value_nopango] = "";
+            row[exifColumns.value] = "";
+            row[exifColumns.is_group] = true;
+
+            return it->children();
+        };
+
+    auto root = getgroup();
+
+    Gtk::TreeModel::Row row = *(exifTreeModel->append(root));
     row[exifColumns.editable] = editable;
-    row[exifColumns.edited]   = false;
-    row[exifColumns.field_nopango] = field;
+    row[exifColumns.edited] = edited;
+    row[exifColumns.key] = key;
+    row[exifColumns.is_group] = false;
+    //row[exifColumns.label] = label.second;
     row[exifColumns.value_nopango] = value;
-    row[exifColumns.orig_value]    = value;
+    //row[exifColumns.value] = value;
 
-    if (action == AC_WRITE) {
-        row[exifColumns.icon] = keepicon;
-    } else if (action == AC_DONTWRITE) {
-        row[exifColumns.icon] = delicon;
-    }
+    row[exifColumns.label] = escapeHtmlChars(label.second);
+    row[exifColumns.value] = value;//escapeHtmlChars(value);
 
-    if (editable) {
-        row[exifColumns.field] = Glib::ustring ("<b>") + escapeHtmlChars (field) + "</b>";
-        row[exifColumns.value] = Glib::ustring ("<b>") + escapeHtmlChars (value) + "</b>";
-    } else if (action == AC_SYSTEM) {
-        row[exifColumns.field] = Glib::ustring ("<i>") + escapeHtmlChars (field) + "</i>";
-        row[exifColumns.value] = Glib::ustring ("<i>") + escapeHtmlChars (value) + "</i>";
-    } else {
-        row[exifColumns.field] = escapeHtmlChars (field);
-        row[exifColumns.value] = escapeHtmlChars (value);
-    }
+    bool active = all_keys_active() || cur_active_keys_.find(key) != cur_active_keys_.end();
+    row[exifColumns.active] = active;
 
-    return row.children();
+    if (edited) {
+        row[exifColumns.icon] = editicon;
+    // } else if (editable) {
+    //     row[exifColumns.icon] = keepicon;
+    }
 }
 
-Gtk::TreeModel::Children ExifPanel::addSeparator ()
+void ExifPanel::refreshTags()
 {
+    Glib::RefPtr<Gtk::TreeSelection> selection = exifTree->get_selection();
+    std::vector<Gtk::TreeModel::Path> sel = selection->get_selected_rows();
 
-    Gtk::TreeModel::Row row = * (exifTreeModel->append (exifTreeModel->children()));
-    row[exifColumns.action] = rtexif::ActionCode::AC_INVALID;
-    row[exifColumns.editable] = false;
-    row[exifColumns.edited] = false;
-    row[exifColumns.field_nopango] = "";
-    row[exifColumns.value_nopango] = "";
-    row[exifColumns.orig_value] = "";
-    row[exifColumns.isSeparator] = true;
-
-    return row.children();
-}
+    exifTreeModel->clear();
 
-void ExifPanel::addDirectory (const TagDirectory* dir, Gtk::TreeModel::Children root, bool checkForSeparator)
-{
+    if (!idata) {
+        return;
+    }
 
-    for (int i = 0; i < dir->getCount(); ++i) {
-        Tag* t = (const_cast<TagDirectory*> (dir))->getTagByIndex (i);
+    const Glib::ustring fn = idata->getFileName();
+    if (fn.empty()) {
+        return;
+    }
 
-        bool hasContent = false;
+    std::unordered_set<std::string> ed;
+    for (const auto &p : editableTags) {
+        ed.insert(p.first);
+    }
 
-        if (checkForSeparator && i == 0) {
-            for (int j = 0; j < dir->getCount(); ++j) {
-                Tag* t2 = (const_cast<TagDirectory*> (dir))->getTagByIndex (j);
-                const TagAttrib* currAttrib = t2->getAttrib();
+    const auto to_label =
+        [](const Exiv2::Exifdatum &tag) -> std::pair<Glib::ustring, Glib::ustring>
+        {
+            auto s = tag.key();
+            auto pos = s.find('.');
+            if (pos != std::string::npos) {
+                s = s.substr(pos+1);
+            }
+            Glib::ustring g = "";
+            pos = s.find('.');
+            if (pos != std::string::npos) {
+                g = s.substr(0, pos);
+                s = s.substr(pos+1);
+            }
+            auto l = tag.tagLabel();
+            if (!l.empty()) {
+                s = l;
+            }
+            return std::make_pair(g, Glib::ustring(s));
+        };
+
+    try {
+        rtengine::Exiv2Metadata meta(fn);
+        meta.load();
+        Exiv2::ExifData exif = meta.exifData();
+
+        const auto to_value =
+            [&](Exiv2::Exifdatum &tag) -> Glib::ustring
+            {
+                try {
+                    if (!tag.tagLabel().empty() && //tag.typeId() != Exiv2::undefined &&
+                        (tag.typeId() == Exiv2::asciiString || tag.size() < 256)) {
+                        return escapeHtmlChars(tag.print(&exif));
+                    }
+                } catch (std::exception &) {}
+                return "<i>(" + M("EXIFPANEL_VALUE_NOT_SHOWN") + ")</i>";
+            };
+
+        if (const rtengine::FramesData *fd = dynamic_cast<const rtengine::FramesData *>(idata)) {
+            fd->fillBasicTags(exif);
+        }
 
-                if (currAttrib && (options.lastShowAllExif || currAttrib->action != AC_SYSTEM)) {
-                    addSeparator();
-                    hasContent = true;
-                    break;
+        for (const auto& p : *changeList) {
+            try {
+                auto &datum = exif[p.first];
+                if (datum.setValue(p.second) != 0) {
+                    if (pl_) {
+                        pl_->error(Glib::ustring::compose(M("ERROR_MSG_METADATA_VALUE"), p.first, p.second));
+                    }
+                }
+            } catch (const std::exception& exc) {
+                if (pl_) {
+                    pl_->error(Glib::ustring::compose(M("ERROR_MSG_METADATA_VALUE"), p.first, p.second));
                 }
             }
-        } else {
-            hasContent = true;
         }
 
-        if (!hasContent) {
-            return;
+        for (auto& p : editableTags) {
+            Exiv2::ExifKey k(p.first);
+            const auto pos = exif.findKey(k);
+            bool edited = false;
+            Glib::ustring value = "";
+            auto lbl = std::make_pair(M("EXIFPANEL_BASIC_GROUP"), k.tagLabel());
+            p.second = k.tagLabel();
+            if (pos != exif.end() && pos->size()) {
+                edited = changeList->find(pos->key()) != changeList->end();
+                value = escapeHtmlChars(pos->print(&exif));
+            }
+            addTag(p.first, lbl, value, true, edited);
         }
+        struct KeyLt {
+            KeyLt():
+                order_{
+                    {"Exif.GPSInfo", 0},
+                    {"Exif.Photo", 1},
+                    {"Exif.Image", 2}
+                }
+            {}
+            bool operator()(const std::string &a, const std::string &b) const
+            {
+                auto p1 = a.find_last_of('.');
+                auto p2 = b.find_last_of('.');
+                const char *sa = a.c_str();
+                const char *sb = b.c_str();
+                if (p1 != std::string::npos && p2 != std::string::npos) {
+                    bool hex_a = strncmp(sa+p1+1, "0x", 2) == 0;
+                    bool hex_b = strncmp(sb+p2+1, "0x", 2) == 0;
+                    if (hex_a != hex_b) {
+                        return !hex_a;
+                    }
+                }
+                if (p1 != p2 || strncmp(sa, sb, p1) != 0) {
+                    std::string ga(sa, sa+p1);
+                    std::string gb(sb, sb+p2);
+                    int ia = getorder(ga);
+                    int ib = getorder(gb);
+                    if (ia != ib) {
+                        return ia < ib;
+                    }
+                }
+                return strcmp(sa, sb) < 0;
+            }
 
-        const TagAttrib* currAttrib = t->getAttrib();
-
-        if (!options.lastShowAllExif && currAttrib && currAttrib->action == AC_SYSTEM) {
-            continue;
-        }
+            int getorder(const std::string &key) const
+            {
+                auto it = order_.find(key);
+                if (it == order_.end()) {
+                    return 1000;
+                }
+                return it->second;
+            }
 
-        if (t->isDirectory()) {
-            for (int j = 0; t->getDirectory (j); j++) {
-                Gtk::TreeModel::Children ch = addTag (root, t->nameToString (j), M ("EXIFPANEL_SUBDIRECTORY"), currAttrib ? currAttrib->action : AC_DONTWRITE, currAttrib && currAttrib->editable);
-                addDirectory (t->getDirectory (j), ch);
+            std::unordered_map<std::string, int> order_;
+        };
+        std::set<std::string, KeyLt> keyset;
+        for (const auto& tag : exif) {
+            const bool editable = ed.find(tag.key()) != ed.end();
+            if (!editable) {
+                keyset.insert(tag.key());
             }
-        } else {
-            addTag (root, t->nameToString (), t->valueToString (), currAttrib ? (t->getOwnMemory() ? currAttrib->action : AC_SYSTEM) : AC_DONTWRITE, currAttrib && currAttrib->editable);
         }
+        for (auto &k : keyset) {
+            auto &tag = *(exif.findKey(Exiv2::ExifKey(k)));
+            addTag(tag.key(), to_label(tag), to_value(tag), false, false);
+        }
+    } catch (const std::exception& exc) {
+        return;
+    }
+
+    for (const auto& p : sel) {
+        exifTree->get_selection()->select(p);
     }
+
+    exifTree->expand_all();
 }
 
 void ExifPanel::exifSelectionChanged ()
 {
-
     Glib::RefPtr<Gtk::TreeSelection> selection = exifTree->get_selection();
     std::vector<Gtk::TreeModel::Path> sel = selection->get_selected_rows();
 
-    if (sel.size() > 1) {
-        remove->set_sensitive (1);
-        keep->set_sensitive (1);
-        reset->set_sensitive (1);
-    } else if (sel.size() == 1) {
+    if (sel.size() >= 1) {
         Gtk::TreeModel::iterator iter = exifTreeModel->get_iter (sel[0]);
-
-        if (iter->get_value (exifColumns.action) == AC_SYSTEM) {
-            remove->set_sensitive (0);
-            keep->set_sensitive (0);
-            reset->set_sensitive (0);
-        } else if (!iter->children().empty()) {
-            remove->set_sensitive (1);
-            keep->set_sensitive (1);
-            reset->set_sensitive (1);
-        } else if (iter->get_value (exifColumns.icon) == delicon) {
-            remove->set_sensitive (0);
-            keep->set_sensitive (1);
-            reset->set_sensitive (1);
-        } else if (iter->get_value (exifColumns.icon) == keepicon || iter->get_value (exifColumns.icon) == editicon) {
-            keep->set_sensitive (0);
-            remove->set_sensitive (1);
-            reset->set_sensitive (1);
+        if (iter->get_value(exifColumns.editable)) {
+            reset->set_sensitive(true);
+            add->set_sensitive(true);
         }
     } else {
-        remove->set_sensitive (0);
-        keep->set_sensitive (0);
-        reset->set_sensitive (0);
+        reset->set_sensitive(false);
+        add->set_sensitive(false);
     }
 }
 
-void ExifPanel::delIt (Gtk::TreeModel::iterator iter)
+void ExifPanel::resetIt(const Gtk::TreeModel::const_iterator& iter)
 {
-
     if (!iter) {
         return;
     }
 
-    if (iter->get_value (exifColumns.action) != AC_SYSTEM) {
-        iter->set_value (exifColumns.icon, delicon);
-    }
-
-    if (recursiveOp)
-        for (Gtk::TreeModel::iterator i = iter->children().begin(); i != iter->children().end(); ++i) {
-            delIt (i);
-        }
+    const auto key = iter->get_value(exifColumns.key);
+    changeList->erase(key);
 }
 
-void ExifPanel::removePressed ()
+void ExifPanel::resetPressed()
 {
+    cur_active_keys_ = get_active_keys();
 
-    std::vector<Gtk::TreeModel::Path> sel = exifTree->get_selection()->get_selected_rows();
-
+    auto sel = exifTree->get_selection()->get_selected_rows();
     for (size_t i = 0; i < sel.size(); i++) {
-        delIt (exifTreeModel->get_iter (sel[i]));
+        resetIt(exifTreeModel->get_iter(sel[i]));
     }
 
-    exifSelectionChanged ();
-    updateChangeList ();
-    notifyListener ();
-}
-
-void ExifPanel::keepIt (Gtk::TreeModel::iterator iter)
-{
-
-    if (!iter) {
-        return;
-    }
+    refreshTags();
 
-    if (iter->get_value (exifColumns.action) != AC_SYSTEM) {
-        iter->set_value (exifColumns.icon, iter->get_value (exifColumns.edited) ? editicon : keepicon);
+    if (!sel.empty()) {
+        exifTree->get_selection()->select(sel[0]);
     }
 
-    if (recursiveOp)
-        for (Gtk::TreeModel::iterator i = iter->children().begin(); i != iter->children().end(); ++i) {
-            keepIt (i);
-        }
+    notifyListener();
 }
 
-void ExifPanel::keepPressed ()
+void ExifPanel::resetAllPressed()
 {
-
-    std::vector<Gtk::TreeModel::Path> sel = exifTree->get_selection()->get_selected_rows();
-
-    for (size_t i = 0; i < sel.size(); i++) {
-        keepIt (exifTreeModel->get_iter (sel[i]));
+    auto sel = exifTree->get_selection()->get_selected_rows();
+    setImageData(idata);
+    *changeList = *defChangeList;
+    cur_active_keys_ = initial_active_keys_;
+    refreshTags();
+    if (!sel.empty()) {
+        exifTree->get_selection()->select(sel[0]);
     }
-
-    exifSelectionChanged ();
-    updateChangeList ();
-    notifyListener ();
+    notifyListener();
 }
 
-/*void ExifPanel::resetIt (Gtk::TreeModel::iterator  iter) {
-
-    if (!iter)
-        return;
-
-    if (iter->get_value (exifColumns.action)!=AC_SYSTEM)
-        iter->set_value (exifColumns.icon, iter->get_value (exifColumns.action) ? keepicon : delicon);
-    if (iter->get_value (exifColumns.edited)) {
-        iter->set_value (exifColumns.value, Glib::ustring("<b>") + iter->get_value(exifColumns.orig_value) + "</b>");
-        iter->set_value (exifColumns.value_nopango, iter->get_value(exifColumns.orig_value));
-        iter->set_value (exifColumns.edited, false);
-    }
-    if (iter->get_value (exifColumns.action)==AC_INVALID)
-        exifTreeModel->erase (iter);
-    else
-    if (recursiveOp)
-        for (Gtk::TreeModel::iterator i=iter->children().begin(); i!=iter->children().end(); i++)
-            resetIt (i);
-}*/
-Gtk::TreeModel::iterator ExifPanel::resetIt (Gtk::TreeModel::iterator  iter)
+void ExifPanel::addPressed()
 {
+    Gtk::TreeModel::Path path;
+    Gtk::TreeViewColumn *col;
 
-    if (!iter) {
-        return iter;
-    }
-
-    if (iter->get_value (exifColumns.action) != AC_SYSTEM) {
-        iter->set_value (exifColumns.icon, iter->get_value (exifColumns.action) ? keepicon : delicon);
+    exifTree->get_cursor(path, col);
+    const auto it = exifTreeModel->get_iter(path);
+    if (it && it->get_value(exifColumns.editable)) {
+        exifTree->set_cursor(path, *col, true);
     }
+}
 
-    if (iter->get_value (exifColumns.edited)) {
-        iter->set_value (exifColumns.value, Glib::ustring ("<b>") + iter->get_value (exifColumns.orig_value) + "</b>");
-        iter->set_value (exifColumns.value_nopango, iter->get_value (exifColumns.orig_value));
-        iter->set_value (exifColumns.edited, false);
+void ExifPanel::activateAllPressed()
+{
+    disableListener();
+    auto root = exifTreeModel->children();
+    for (auto &group : root->children()) {
+        group[exifColumns.active] = true;
+        for (auto &row : group.children()) {
+            row[exifColumns.active] = true;
+        }
     }
+    enableListener();
+    notifyListener();
+}
 
-    if (iter->get_value (exifColumns.action) == AC_INVALID) {
-        return exifTreeModel->erase (iter);
-    } else if (recursiveOp) {
-        Gtk::TreeModel::iterator i = iter->children().begin();
 
-        while (i && i != iter->children().end()) {
-            i = resetIt (i);
+void ExifPanel::activateNonePressed()
+{
+    disableListener();
+    auto root = exifTreeModel->children();
+    for (auto &group : root->children()) {
+        group[exifColumns.active] = false;
+        for (auto &row : group.children()) {
+            row[exifColumns.active] = false;
         }
     }
-
-    return ++iter;
+    enableListener();
+    notifyListener();
 }
-void ExifPanel::resetPressed ()
-{
 
-    std::vector<Gtk::TreeModel::Path> sel = exifTree->get_selection()->get_selected_rows();
 
-    for (size_t i = 0; i < sel.size(); i++) {
-        resetIt (exifTreeModel->get_iter (sel[i]));
+void ExifPanel::notifyListener()
+{
+    if (listener) {
+        listener->panelChanged(EvExif, M("HISTORY_CHANGED"));
     }
-
-    exifSelectionChanged ();
-    updateChangeList ();
-    notifyListener ();
 }
 
-void ExifPanel::resetAllPressed ()
-{
-
-    setImageData (idata);
-    *changeList = *defChangeList;
-    applyChangeList ();
-    exifSelectionChanged ();
-    notifyListener ();
-}
 
-void ExifPanel::addPressed ()
+void ExifPanel::onKeyActiveToggled(const Glib::ustring &path)
 {
-
-    Gtk::Dialog* dialog = new Gtk::Dialog (M ("EXIFPANEL_ADDTAGDLG_TITLE"), * ((Gtk::Window*)get_toplevel()), true);
-    dialog->add_button ("_OK", Gtk::RESPONSE_OK);
-    dialog->add_button ("_Cancel", Gtk::RESPONSE_CANCEL);
-
-    Gtk::Box* hb1 = new Gtk::Box ();
-    Gtk::Box* hb2 = new Gtk::Box ();
-
-    Gtk::Label* tlabel = new Gtk::Label (M ("EXIFPANEL_ADDTAGDLG_SELECTTAG") + ":");
-    MyComboBoxText* tcombo = new MyComboBoxText ();
-
-    tcombo->append ("Artist");
-    tcombo->append ("Copyright");
-    tcombo->append ("ImageDescription");
-    tcombo->append ("Exif.UserComment");
-
-    hb1->pack_start (*tlabel, Gtk::PACK_SHRINK, 4);
-    hb1->pack_start (*tcombo);
-
-    Gtk::Label* vlabel = new Gtk::Label (M ("EXIFPANEL_ADDTAGDLG_ENTERVALUE") + ":");
-    Gtk::Entry* ventry = new Gtk::Entry ();
-    hb2->pack_start (*vlabel, Gtk::PACK_SHRINK, 4);
-    hb2->pack_start (*ventry);
-
-    Glib::ustring sel = getSelection (true);
-
-    if (sel.empty()) {
-        tcombo->set_active_text ("Exif.UserComment");
-    } else {
-        tcombo->set_active_text (sel);
-
-        if (!tcombo->get_active ()) {
-            tcombo->append (sel);
-            tcombo->set_active_text (sel);
+    auto it = exifTreeModel->get_iter(path);
+    if (it) {
+        auto row = *it;
+        bool b = !row[exifColumns.active];
+        row[exifColumns.active] = b;
+        if (row[exifColumns.is_group]) {
+            for (auto &c : row.children()) {
+                c[exifColumns.active] = b;
+            }
         }
-
-        ventry->set_text (getSelectedValue ());
-    }
-
-    ventry->set_activates_default (true);
-    dialog->set_default_response (Gtk::RESPONSE_OK);
-    dialog->get_content_area()->pack_start (*hb1, Gtk::PACK_SHRINK);
-    dialog->get_content_area()->pack_start (*hb2, Gtk::PACK_SHRINK, 4);
-    tlabel->show ();
-    tcombo->show ();
-    vlabel->show ();
-    ventry->show ();
-    hb1->show ();
-    hb2->show ();
-
-    if (dialog->run () == Gtk::RESPONSE_OK) {
-        editTag (exifTreeModel->children(), tcombo->get_active_text(), ventry->get_text());
-        updateChangeList ();
-        notifyListener ();
+        notifyListener();
     }
-
-    delete dialog;
-    delete tlabel;
-    delete tcombo;
-    delete vlabel;
-    delete ventry;
-    delete hb1;
-    delete hb2;
 }
 
-void ExifPanel::showAlltoggled ()
-{
-    options.lastShowAllExif = showAll->get_active();
-    setImageData (idata);
-}
 
-bool ExifPanel::rowSeperatorFunc(const Glib::RefPtr<Gtk::TreeModel>& model, const Gtk::TreeModel::iterator& iter)
+void ExifPanel::setKeyActive(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &it)
 {
-    return iter->get_value(exifColumns.isSeparator);
+    auto row = *it;
+    Gtk::CellRendererToggle *toggle = static_cast<Gtk::CellRendererToggle *>(renderer);
+    if (row[exifColumns.is_group]) {
+        bool all_true = true, all_false = true;
+        for (auto &c : row.children()) {
+            if (c[exifColumns.active]) {
+                all_false = false;
+            } else {
+                all_true = false;
+            }
+        }
+        if (!all_true && !all_false) {
+            toggle->property_inconsistent() = true;
+        } else {
+            toggle->property_inconsistent() = false;
+            toggle->set_active(all_true);
+        }
+    } else {
+        toggle->property_inconsistent() = false;
+        toggle->set_active(row[exifColumns.active]);
+    }
 }
 
-void ExifPanel::editTag (Gtk::TreeModel::Children root, Glib::ustring name, Glib::ustring value)
-{
 
-    Glib::ustring::size_type dp = name.find_first_of ('.');
-    Glib::ustring fseg = name.substr (0, dp);
-    // look up first segment of the path
-    Gtk::TreeModel::iterator iter;
+bool ExifPanel::all_keys_active() const
+{
+    return (cur_active_keys_.size() == 1 && *(cur_active_keys_.begin()) == "*");
+}
 
-    for (iter = root.begin(); iter != root.end(); ++iter)
-        if (iter->get_value (exifColumns.field_nopango) == fseg) {
-            break;
-        }
 
-    if (iter == root.end() && value != "#keep" && value != "#delete") {
-        iter = exifTreeModel->append (root);
-        iter->set_value (exifColumns.field_nopango, fseg);
-        iter->set_value (exifColumns.action, AC_INVALID);
-
-        if (dp == Glib::ustring::npos) {
-            iter->set_value (exifColumns.value, Glib::ustring ("<b>") + value + "</b>");
-            iter->set_value (exifColumns.value_nopango, value);
-            iter->set_value (exifColumns.orig_value, value);
-            iter->set_value (exifColumns.field, Glib::ustring ("<b>") + fseg + "</b>");
-            iter->set_value (exifColumns.edited, true);
-            iter->set_value (exifColumns.editable, true);
-            iter->set_value (exifColumns.icon, editicon);
-        } else {
-            iter->set_value (exifColumns.value, Glib::ustring (M ("EXIFPANEL_SUBDIRECTORY")));
-            iter->set_value (exifColumns.value_nopango, Glib::ustring (M ("EXIFPANEL_SUBDIRECTORY")));
-            iter->set_value (exifColumns.field, fseg);
-            iter->set_value (exifColumns.icon, keepicon);
-            iter->set_value (exifColumns.orig_value, Glib::ustring (M ("EXIFPANEL_SUBDIRECTORY")));
+std::unordered_set<std::string> ExifPanel::get_active_keys() const
+{
+    bool all_active = true;
+    std::unordered_set<std::string> ret;
+    auto root = exifTreeModel->children();
+    for (auto &group : root->children()) {
+        for (auto &entry : group.children()) {
+            std::string key = entry[exifColumns.key];
+            if (entry[exifColumns.active]) {
+                ret.insert(key);
+            } else {
+                all_active = false;
+            }
         }
     }
-
-    if (iter == root.end()) {
-        return;
+    if (all_active) {
+        ret.clear();
+        ret.insert("*");
     }
+    return ret;
+}
 
-    if (dp == Glib::ustring::npos) {
-        if (value == "#keep" && iter->get_value (exifColumns.action) != AC_SYSTEM) {
-            iter->set_value (exifColumns.icon, iter->get_value (exifColumns.edited) ? editicon : keepicon);
-        } else if (value == "#delete" && iter->get_value (exifColumns.action) != AC_SYSTEM) {
-            iter->set_value (exifColumns.icon, delicon);
-        } else {
-            iter->set_value (exifColumns.value, Glib::ustring ("<b>") + value + "</b>");
-            iter->set_value (exifColumns.value_nopango, value);
-            iter->set_value (exifColumns.edited, true);
-            iter->set_value (exifColumns.icon, editicon);
+void ExifPanel::onExifTreeClick(GdkEventButton *event)
+{
+    Gtk::TreeModel::Path pth;
+    Gtk::TreeViewColumn *col;
+    int cell_x;
+    int cell_y;
+    if (exifTree->get_path_at_pos(event->x, event->y, pth, col, cell_x, cell_y) && col == exifTree->get_column(1) && cell_x <= 22) {
+        auto it = exifTreeModel->get_iter(pth);
+        auto row = *it;
+        if (row[exifColumns.is_group]) {
+            if (exifTree->row_expanded(pth)) {
+                exifTree->collapse_row(pth);
+            } else {
+                exifTree->expand_row(pth, false);
+            }
         }
-    } else {
-        editTag (iter->children(), name.substr (dp + 1, Glib::ustring::npos), value);
     }
 }
 
-Glib::ustring ExifPanel::getSelectedValue ()
-{
-
-    Glib::RefPtr<Gtk::TreeSelection> selection = exifTree->get_selection();
-    std::vector<Gtk::TreeModel::Path> rows = selection->get_selected_rows();
 
-    if (rows.size() != 1) {
-        return "";
+void ExifPanel::onExifRowExpanded(const Gtk::TreeModel::iterator &it, const Gtk::TreeModel::Path &path)
+{
+    auto row = *it;
+    if (row[exifColumns.is_group]) {
+        row[exifColumns.icon] = open_icon_;
     }
+}
 
-    Gtk::TreeModel::iterator iter = exifTreeModel->get_iter (rows[0]);
 
-    if (iter) {
-        return iter->get_value (exifColumns.value_nopango);
+void ExifPanel::onExifRowCollapsed(const Gtk::TreeModel::iterator &it, const Gtk::TreeModel::Path &path)
+{
+    auto row = *it;
+    if (row[exifColumns.is_group]) {
+        row[exifColumns.icon] = closed_icon_;
     }
-
-    return "";
 }
 
-Glib::ustring ExifPanel::getSelection (bool onlyeditable)
-{
-
-    Glib::RefPtr<Gtk::TreeSelection> selection = exifTree->get_selection();
-    std::vector<Gtk::TreeModel::Path> rows = selection->get_selected_rows();
-
-    if (rows.size() != 1) {
-        return "";
-    }
 
-    Gtk::TreeModel::iterator iter = exifTreeModel->get_iter (rows[0]);
+void ExifPanel::setExifTagValue(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &it)
+{
+    auto row = *it;
+    Gtk::CellRendererText *txt = static_cast<Gtk::CellRendererText *>(renderer);
+    txt->property_editable() = row[exifColumns.editable];
+    txt->property_markup() = row[exifColumns.value];
+}
 
-    Glib::ustring ret;
-    bool first = true;
-    bool editable = false;
 
-    while (iter) {
-        if (first) {
-            ret = iter->get_value (exifColumns.field_nopango);
-            editable = iter->get_value (exifColumns.editable);
-        } else {
-            ret = iter->get_value (exifColumns.field_nopango) + "." + ret;
-        }
+namespace {
 
-        iter = iter->parent ();
-        first = false;
-    }
 
-    if (!editable && onlyeditable) {
-        return "";
+Glib::ustring to_fraction(const Glib::ustring &s)
+{
+    auto i = s.find(".");
+    if (i != Glib::ustring::npos) {
+        return s.substr(0, i) + s.substr(i+1) + "/1" + Glib::ustring(s.size() - i - 1, '0');
     }
-
-    return ret;
+    return s;
 }
 
-void ExifPanel::updateChangeList (Gtk::TreeModel::Children root, std::string prefix)
-{
+typedef Glib::ustring (*validator_func)(const Glib::ustring &);
 
-    if (!prefix.empty()) {
-        prefix = prefix + ".";
+Glib::ustring get_fnumber(const Glib::ustring &val)
+{
+    Glib::MatchInfo m;
+    auto re = Glib::Regex::create("f? *([0-9.]+) *", Glib::REGEX_CASELESS);
+    if (re->match(val, m)) {
+        auto s = m.fetch(1);
+        return to_fraction(s);
     }
+    return val;
+}
 
-    Gtk::TreeModel::iterator iter;
-
-    for (iter = root.begin(); iter != root.end(); ++iter)  {
-        if (iter->get_value (exifColumns.edited)) {
-            (*changeList)[ prefix + iter->get_value (exifColumns.field_nopango) ] = iter->get_value (exifColumns.value_nopango);
-        } else if (iter->get_value (exifColumns.action) == AC_WRITE && iter->get_value (exifColumns.icon) == delicon) {
-            (*changeList)[ prefix + iter->get_value (exifColumns.field_nopango) ] = "#delete";
-        } else if (iter->get_value (exifColumns.action) == AC_DONTWRITE && iter->get_value (exifColumns.icon) == keepicon) {
-            (*changeList)[ prefix + iter->get_value (exifColumns.field_nopango) ] = "#keep";
-        }
-
-        if (iter->get_value (exifColumns.icon) == keepicon) {
-            updateChangeList (iter->children(), prefix + iter->get_value (exifColumns.field_nopango));
-        }
+Glib::ustring get_shutterspeed(const Glib::ustring &val)
+{
+    Glib::MatchInfo m;
+    auto re = Glib::Regex::create(" *([0-9/]+) *s? *", Glib::REGEX_CASELESS);
+    if (re->match(val, m)) {
+        auto s = m.fetch(1);
+        return s;
     }
+    return val;
 }
 
-void ExifPanel::updateChangeList ()
+Glib::ustring get_focallen(const Glib::ustring &val)
 {
-
-    changeList->clear ();
-    updateChangeList (exifTreeModel->children(), "");
+    Glib::MatchInfo m;
+    auto re = Glib::Regex::create(" *([0-9.]+) *(mm)? *", Glib::REGEX_CASELESS);
+    if (re->match(val, m)) {
+        auto s = m.fetch(1);
+        return to_fraction(s);
+    }
+    return val;
 }
 
-void ExifPanel::applyChangeList ()
+Glib::ustring get_expcomp(const Glib::ustring &val)
 {
-
-    for (rtengine::procparams::ExifPairs::const_iterator i = changeList->begin(); i != changeList->end(); ++i) {
-        editTag (exifTreeModel->children(), i->first, i->second);
+    Glib::MatchInfo m;
+    auto re = Glib::Regex::create(" *(-?[0-9.]+) *(EV)? *", Glib::REGEX_CASELESS);
+    if (re->match(val, m)) {
+        auto s = m.fetch(1);
+        return to_fraction(s);
     }
+    return val;
 }
 
-void ExifPanel::row_activated (const Gtk::TreeModel::Path& path, Gtk::TreeViewColumn* column)
-{
+std::unordered_map<std::string, validator_func> validators = {
+    {"Exif.Photo.FNumber", get_fnumber},
+    {"Exif.Photo.ExposureTime", get_shutterspeed},
+    {"Exif.Photo.FocalLength", get_focallen},
+    {"Exif.Photo.ExposureBiasValue", get_expcomp}
+};
 
-    Gtk::TreeModel::iterator iter = exifTreeModel->get_iter (path);
+} // namespace
 
-    if (iter) {
-        if (!iter->children().empty())
-            if (exifTree->row_expanded (path)) {
-                exifTree->collapse_row (path);
+
+void ExifPanel::onEditExifTagValue(const Glib::ustring &path, const Glib::ustring &val)
+{
+    auto it = exifTreeModel->get_iter(path);
+    auto row = *it;
+    std::string key = row[exifColumns.key];
+    auto value = val;
+
+    bool good = true;
+    try {
+        Exiv2::ExifData data;
+        auto &datum = data[key];
+        auto it = validators.find(key);
+        if (it != validators.end()) {
+            auto v = it->second(value);
+            if (datum.setValue(v) == 0) {
+                value = v;
+            }
+        }
+        if (datum.setValue(value) != 0) {
+            if ((datum.typeId() == Exiv2::signedRational || datum.typeId() == Exiv2::unsignedRational) && datum.setValue(value + "/1") == 0) {
+                value += "/1";
             } else {
-                exifTree->expand_row (path, false);
-            } else if (iter->get_value (exifColumns.editable)) {
-            addPressed ();
+                good = false;
+            }
+        }
+    } catch (std::exception &exc) {
+        good = false;
+    }
+
+    if (good) {
+        (*changeList)[key] = value;
+        if (!all_keys_active()) {
+            cur_active_keys_.insert(key);
         }
+        refreshTags();
+
+        it = exifTreeModel->get_iter(path);
+        exifTree->get_selection()->select(it);
+        notifyListener();
+    } else if (pl_) {
+        pl_->error(Glib::ustring::compose(M("ERROR_MSG_METADATA_VALUE"), key, value));
     }
 }
 
 
-void ExifPanel::notifyListener ()
+void ExifPanel::setProgressListener(rtengine::ProgressListener *pl)
 {
-
-    if (listener) {
-        listener->panelChanged (EvExif, M ("HISTORY_CHANGED"));
-    }
+    pl_ = pl;
 }
diff --git a/rtgui/exifpanel.h b/rtgui/exifpanel.h
index 4c28af289..bc8d6229f 100644
--- a/rtgui/exifpanel.h
+++ b/rtgui/exifpanel.h
@@ -21,9 +21,21 @@
 #include <memory>
 
 #include <gtkmm.h>
+#include <unordered_set>
 
 #include "toolpanel.h"
-#include "../rtexif/rtexif.h"
+
+namespace rtengine
+{
+
+namespace procparams
+{
+
+class ExifPairs;
+
+}
+
+}
 
 class ExifPanel final :
     public Gtk::Box,
@@ -34,72 +46,83 @@ private:
     const rtengine::FramesMetaData* idata;
     const std::unique_ptr<rtengine::procparams::ExifPairs> changeList;
     const std::unique_ptr<rtengine::procparams::ExifPairs> defChangeList;
-    bool recursiveOp;
 
     class ExifColumns : public Gtk::TreeModelColumnRecord
     {
     public:
-        Gtk::TreeModelColumn<Glib::RefPtr<Gdk::Pixbuf> > icon;
-        Gtk::TreeModelColumn<Glib::ustring> field;
-        Gtk::TreeModelColumn<Glib::ustring> field_nopango;
+        // Gtk::TreeModelColumn<Glib::RefPtr<Gdk::Pixbuf>> expander_icon;
+        Gtk::TreeModelColumn<Glib::RefPtr<Gdk::Pixbuf>> icon;
+        Gtk::TreeModelColumn<std::string> key;
+        Gtk::TreeModelColumn<Glib::ustring> label;
         Gtk::TreeModelColumn<Glib::ustring> value;
         Gtk::TreeModelColumn<Glib::ustring> value_nopango;
-        Gtk::TreeModelColumn<Glib::ustring> orig_value;
-        Gtk::TreeModelColumn<rtexif::ActionCode> action;
         Gtk::TreeModelColumn<bool> editable;
         Gtk::TreeModelColumn<bool> edited;
-        Gtk::TreeModelColumn<bool> isSeparator;
+        Gtk::TreeModelColumn<bool> active;
+        Gtk::TreeModelColumn<bool> is_group;
 
         ExifColumns()
         {
-            add (field);
-            add (value);
-            add (icon);
-            add (action);
-            add (edited);
-            add (field_nopango);
-            add (value_nopango);
-            add (editable);
-            add (orig_value);
-            add (isSeparator);
+            add(key);
+            add(label);
+            add(value);
+            add(icon);
+            add(edited);
+            add(value_nopango);
+            add(editable);
+            add(active);
+            add(is_group);
+            // add(expander_icon);
         }
     };
-    Glib::RefPtr<Gdk::Pixbuf> delicon;
-    Glib::RefPtr<Gdk::Pixbuf> keepicon;
+    //Glib::RefPtr<Gdk::Pixbuf> keepicon;
     Glib::RefPtr<Gdk::Pixbuf> editicon;
+    Glib::RefPtr<Gdk::Pixbuf> open_icon_;
+    Glib::RefPtr<Gdk::Pixbuf> closed_icon_;
 
     ExifColumns exifColumns;
     Gtk::TreeView* exifTree;
     Gtk::ScrolledWindow* scrolledWindow;
     Glib::RefPtr<Gtk::TreeStore> exifTreeModel;
 
-    Gtk::Button* remove;
-    Gtk::Button* keep;
     Gtk::Button* add;
     Gtk::Button* reset;
     Gtk::Button* resetAll;
-    Gtk::ToggleButton* showAll;
-
-    Gtk::TreeModel::Children addTag (const Gtk::TreeModel::Children& root, Glib::ustring field, Glib::ustring value, rtexif::ActionCode action, bool editable);
-    void editTag (Gtk::TreeModel::Children root, Glib::ustring name, Glib::ustring value);
-    void updateChangeList (Gtk::TreeModel::Children root, std::string prefix);
-    void addDirectory (const rtexif::TagDirectory* dir, Gtk::TreeModel::Children root, bool checkForSeparator = false);
-    Gtk::TreeModel::Children addSeparator();
-    Glib::ustring getSelection (bool onlyifeditable = false);
-    Glib::ustring getSelectedValue();
-    void updateChangeList();
-    void applyChangeList();
-    void keepIt (Gtk::TreeModel::iterator iter);
-    void delIt (Gtk::TreeModel::iterator iter);
-    Gtk::TreeModel::iterator resetIt (Gtk::TreeModel::iterator iter);
-    void removePressed();
-    void keepPressed();
+    Gtk::Button *activate_all_;
+    Gtk::Button *activate_none_;
+
+    Gtk::CellRendererToggle exif_active_renderer_;
+    Gtk::TreeView::Column exif_active_column_;
+
+    std::vector<std::pair<std::string, Glib::ustring>> editableTags;
+
+    std::unordered_set<std::string> initial_active_keys_;
+    std::unordered_set<std::string> cur_active_keys_;
+
+    rtengine::ProgressListener *pl_;
+
+    void addTag(const std::string &key, const std::pair<Glib::ustring, Glib::ustring> &label, const Glib::ustring &value, bool editable, bool edited);
+    void refreshTags();
+    void resetIt(const Gtk::TreeModel::const_iterator& iter);
     void resetPressed();
     void resetAllPressed();
     void addPressed();
-    void showAlltoggled();
-    bool rowSeperatorFunc(const Glib::RefPtr<Gtk::TreeModel>& model, const Gtk::TreeModel::iterator& iter);
+    void activateAllPressed();
+    void activateNonePressed();
+
+    void setKeyActive(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &it);
+    void onKeyActiveToggled(const Glib::ustring &path);
+
+    bool all_keys_active() const;
+    std::unordered_set<std::string> get_active_keys() const;
+
+    void onExifTreeClick(GdkEventButton *event);
+    void onExifRowExpanded(const Gtk::TreeModel::iterator &it, const Gtk::TreeModel::Path &path);
+    void onExifRowCollapsed(const Gtk::TreeModel::iterator &it, const Gtk::TreeModel::Path &path);
 
+    void setExifTagValue(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &it);
+    void onEditExifTagValue(const Glib::ustring &path, const Glib::ustring &value);
+    
 public:
     ExifPanel ();
     ~ExifPanel() override;
@@ -111,8 +134,9 @@ public:
     void setImageData (const rtengine::FramesMetaData* id);
 
     void exifSelectionChanged();
-    void row_activated (const Gtk::TreeModel::Path& path, Gtk::TreeViewColumn* column);
+    // void row_activated (const Gtk::TreeModel::Path& path, Gtk::TreeViewColumn* column);
 
     void notifyListener();
 
+    void setProgressListener(rtengine::ProgressListener *pl);
 };
diff --git a/rtgui/filmnegative.cc b/rtgui/filmnegative.cc
index 4f1ae9311..39890babe 100644
--- a/rtgui/filmnegative.cc
+++ b/rtgui/filmnegative.cc
@@ -291,14 +291,14 @@ FilmNegative::FilmNegative() :
     refSpotButton->signal_toggled().connect(sigc::mem_fun(*this, &FilmNegative::refSpotToggled));
 
     // Editing geometry; create the spot rectangle
-    Rectangle* const spotRect = new Rectangle();
+    EditRectangle* const spotRect = new EditRectangle();
     spotRect->filled = false;
 
     visibleGeometry.push_back(spotRect);
 
     // Stick a dummy rectangle over the whole image in mouseOverGeometry.
     // This is to make sure the getCursor() call is fired everywhere.
-    Rectangle* const imgRect = new Rectangle();
+    EditRectangle* const imgRect = new EditRectangle();
     imgRect->filled = true;
 
     mouseOverGeometry.push_back(imgRect);
@@ -564,7 +564,7 @@ CursorShape FilmNegative::getCursor(int objectID, int xPos, int yPos) const
 bool FilmNegative::mouseOver(int modifierKey)
 {
     EditDataProvider* const provider = getEditProvider();
-    Rectangle* const spotRect = static_cast<Rectangle*>(visibleGeometry.at(0));
+    EditRectangle* const spotRect = static_cast<EditRectangle*>(visibleGeometry.at(0));
     spotRect->setXYWH(provider->posImage.x - 16, provider->posImage.y - 16, 32, 32);
 
     return true;
@@ -716,7 +716,7 @@ void FilmNegative::editToggled()
 
         // Stick a dummy rectangle over the whole image in mouseOverGeometry.
         // This is to make sure the getCursor() call is fired everywhere.
-        Rectangle* const imgRect = static_cast<Rectangle*>(mouseOverGeometry.at(0));
+        EditRectangle* const imgRect = static_cast<EditRectangle*>(mouseOverGeometry.at(0));
         imgRect->setXYWH(0, 0, w, h);
     } else {
         refSpotCoords.clear();
@@ -739,7 +739,7 @@ void FilmNegative::refSpotToggled()
 
         // Stick a dummy rectangle over the whole image in mouseOverGeometry.
         // This is to make sure the getCursor() call is fired everywhere.
-        Rectangle* const imgRect = static_cast<Rectangle*>(mouseOverGeometry.at(0));
+        EditRectangle* const imgRect = static_cast<EditRectangle*>(mouseOverGeometry.at(0));
         imgRect->setXYWH(0, 0, w, h);
 
     } else {
diff --git a/rtgui/iptcpanel.cc b/rtgui/iptcpanel.cc
index 1134b36da..eb6366fac 100644
--- a/rtgui/iptcpanel.cc
+++ b/rtgui/iptcpanel.cc
@@ -16,700 +16,790 @@
  *  You should have received a copy of the GNU General Public License
  *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
  */
+#include <set>
+
 #include "iptcpanel.h"
+
 #include "clipboard.h"
 #include "rtimage.h"
 
+#include "../rtengine/imagedata.h"
+#include "../rtengine/metadata.h"
 #include "../rtengine/procparams.h"
 
 using namespace rtengine;
 using namespace rtengine::procparams;
 
-IPTCPanel::IPTCPanel () :
+namespace {
+
+const std::string CAPTION("Iptc.Application2.Caption");
+const std::string CAPTION_WRITER("Iptc.Application2.Writer");
+const std::string CATEGORY("Iptc.Application2.Category");
+const std::string CITY("Iptc.Application2.City");
+const std::string COPYRIGHT("Iptc.Application2.Copyright");
+const std::string COUNTRY("Iptc.Application2.CountryName");
+const std::string CREATOR("Iptc.Application2.Byline");
+const std::string CREATOR_JOB_TITLE("Iptc.Application2.BylineTitle");
+const std::string CREDIT("Iptc.Application2.Credit");
+const std::string DATE_CREATED("Iptc.Application2.DateCreated");
+const std::string HEADLINE("Iptc.Application2.Headline");
+const std::string INSTRUCTIONS("Iptc.Application2.SpecialInstructions");
+const std::string KEYWORDS("Iptc.Application2.Keywords");
+const std::string PROVINCE("Iptc.Application2.ProvinceState");
+const std::string SOURCE("Iptc.Application2.Source");
+const std::string SUPPLEMENTAL_CATEGORIES("Iptc.Application2.SuppCategory");
+const std::string TITLE("Iptc.Application2.ObjectName");
+const std::string TRANS_REFERENCE("Iptc.Application2.TransmissionReference");
+
+const std::set<std::string> iptc_keys = {
+    CAPTION,
+    CAPTION_WRITER,
+    CATEGORY,
+    CITY,
+    COPYRIGHT,
+    COUNTRY,
+    CREATOR,
+    CREATOR_JOB_TITLE,
+    CREDIT,
+    DATE_CREATED,
+    HEADLINE,
+    INSTRUCTIONS,
+    KEYWORDS,
+    PROVINCE,
+    SOURCE,
+    SUPPLEMENTAL_CATEGORIES,
+    TITLE,
+    TRANS_REFERENCE
+};
+
+} // namespace
+
+IPTCPanel::IPTCPanel():
     changeList(new rtengine::procparams::IPTCPairs),
     defChangeList(new rtengine::procparams::IPTCPairs),
     embeddedData(new rtengine::procparams::IPTCPairs)
 {
 
     set_orientation(Gtk::ORIENTATION_VERTICAL);
-    set_spacing (4);
+    set_spacing(4);
 
-    Gtk::Grid* iptc = Gtk::manage( new Gtk::Grid () );
+    Gtk::Grid* iptc = Gtk::manage(new Gtk::Grid());
     setExpandAlignProperties(iptc, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_START);
     iptc->set_row_spacing(3);
 
     int row = 0;
 
-    Gtk::Label* capl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_DESCRIPTION") + ":") );
+    Gtk::Label* capl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_DESCRIPTION") + ":"));
     setExpandAlignProperties(capl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    captionText = Gtk::TextBuffer::create ();
-    captionView = Gtk::manage( new Gtk::TextView (captionText) );
+    captionText = Gtk::TextBuffer::create();
+    captionView = Gtk::manage(new Gtk::TextView(captionText));
     setExpandAlignProperties(captionView, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    Gtk::ScrolledWindow* scrolledWindowc = Gtk::manage( new Gtk::ScrolledWindow() );
+    Gtk::ScrolledWindow* scrolledWindowc = Gtk::manage(new Gtk::ScrolledWindow());
     setExpandAlignProperties(scrolledWindowc, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_START);
-    scrolledWindowc->set_min_content_height (100);
+    scrolledWindowc->set_min_content_height(100);
     scrolledWindowc->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_ALWAYS);
     scrolledWindowc->add(*captionView);
-    capl->set_tooltip_text (M("IPTCPANEL_DESCRIPTIONHINT"));
-    captionView->set_tooltip_text (M("IPTCPANEL_DESCRIPTIONHINT"));
+    capl->set_tooltip_text(M("IPTCPANEL_DESCRIPTIONHINT"));
+    captionView->set_tooltip_text(M("IPTCPANEL_DESCRIPTIONHINT"));
     captionView->set_size_request(35, 95);
-    iptc->attach (*capl, 0, row++, 1, 1);
-    iptc->attach (*scrolledWindowc, 0, row++, 1, 1);
+    iptc->attach(*capl, 0, row++, 1, 1);
+    iptc->attach(*scrolledWindowc, 0, row++, 1, 1);
 
     // --------------------------
 
-    Gtk::Label* capwl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_DESCRIPTIONWRITER") + ":") );
+    Gtk::Label* capwl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_DESCRIPTIONWRITER") + ":"));
     setExpandAlignProperties(capwl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    captionWriter = Gtk::manage( new Gtk::Entry () );
+    captionWriter = Gtk::manage(new Gtk::Entry());
     setExpandAlignProperties(captionWriter, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    capwl->set_tooltip_text (M("IPTCPANEL_DESCRIPTIONWRITERHINT"));
-    captionWriter->set_tooltip_text (M("IPTCPANEL_DESCRIPTIONWRITERHINT"));
-    iptc->attach (*capwl, 0, row++, 1, 1);
-    iptc->attach (*captionWriter, 0, row++, 1, 1);
+    capwl->set_tooltip_text(M("IPTCPANEL_DESCRIPTIONWRITERHINT"));
+    captionWriter->set_tooltip_text(M("IPTCPANEL_DESCRIPTIONWRITERHINT"));
+    iptc->attach(*capwl, 0, row++, 1, 1);
+    iptc->attach(*captionWriter, 0, row++, 1, 1);
 
     // --------------------------
 
-    Gtk::Label* headl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_HEADLINE") + ":") );
+    Gtk::Label* headl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_HEADLINE") + ":"));
     setExpandAlignProperties(headl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    headline = Gtk::manage( new Gtk::Entry () );
+    headline = Gtk::manage(new Gtk::Entry());
     setExpandAlignProperties(headline, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_BASELINE);
-    headl->set_tooltip_text (M("IPTCPANEL_HEADLINEHINT"));
-    headline->set_tooltip_text (M("IPTCPANEL_HEADLINEHINT"));
-    iptc->attach (*headl, 0, row++, 1, 1);
-    iptc->attach (*headline, 0, row++, 1, 1);
+    headl->set_tooltip_text(M("IPTCPANEL_HEADLINEHINT"));
+    headline->set_tooltip_text(M("IPTCPANEL_HEADLINEHINT"));
+    iptc->attach(*headl, 0, row++, 1, 1);
+    iptc->attach(*headline, 0, row++, 1, 1);
 
     // --------------------------
 
-    Gtk::Label* instl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_INSTRUCTIONS") + ":") );
+    Gtk::Label* instl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_INSTRUCTIONS") + ":"));
     setExpandAlignProperties(instl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    instructions = Gtk::manage( new Gtk::Entry () );
+    instructions = Gtk::manage(new Gtk::Entry());
     setExpandAlignProperties(instructions, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    instl->set_tooltip_text (M("IPTCPANEL_INSTRUCTIONSHINT"));
-    instructions->set_tooltip_text (M("IPTCPANEL_INSTRUCTIONSHINT"));
-    iptc->attach (*instl, 0, row++, 1, 1);
-    iptc->attach (*instructions, 0, row++, 1, 1);
+    instl->set_tooltip_text(M("IPTCPANEL_INSTRUCTIONSHINT"));
+    instructions->set_tooltip_text(M("IPTCPANEL_INSTRUCTIONSHINT"));
+    iptc->attach(*instl, 0, row++, 1, 1);
+    iptc->attach(*instructions, 0, row++, 1, 1);
 
     // --------------------------
 
-    Gtk::Separator* hsep1 = Gtk::manage( new Gtk::Separator(Gtk::ORIENTATION_HORIZONTAL) );
+    Gtk::Separator* hsep1 = Gtk::manage(new Gtk::Separator(Gtk::ORIENTATION_HORIZONTAL));
     setExpandAlignProperties(hsep1, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    iptc->attach (*hsep1, 0, row++, 2, 1);
+    iptc->attach(*hsep1, 0, row++, 2, 1);
 
     // --------------------------
 
-    Gtk::Label* keyl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_KEYWORDS") + ":"));
+    Gtk::Label* keyl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_KEYWORDS") + ":"));
     setExpandAlignProperties(keyl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    keyl->set_tooltip_text (M("IPTCPANEL_KEYWORDSHINT"));
-    keywords = Gtk::manage( new Gtk::ListViewText (1, false, Gtk::SELECTION_MULTIPLE) );
+    keyl->set_tooltip_text(M("IPTCPANEL_KEYWORDSHINT"));
+    keywords = Gtk::manage(new Gtk::ListViewText(1, false, Gtk::SELECTION_MULTIPLE));
     setExpandAlignProperties(keywords, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_START);
-    keywords->set_headers_visible (false);
-    keywords->set_size_request (50, 95);
-    Gtk::ScrolledWindow* scrolledWindowkw = Gtk::manage( new Gtk::ScrolledWindow() );
+    keywords->set_headers_visible(false);
+    keywords->set_size_request(50, 95);
+    Gtk::ScrolledWindow* scrolledWindowkw = Gtk::manage(new Gtk::ScrolledWindow());
     setExpandAlignProperties(scrolledWindowkw, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_START);
-    scrolledWindowkw->set_min_content_height (100);
+    scrolledWindowkw->set_min_content_height(100);
     scrolledWindowkw->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_ALWAYS);
     scrolledWindowkw->add(*keywords);
-    keyword  = Gtk::manage(new MyComboBoxText (true));
+    keyword  = Gtk::manage(new MyComboBoxText(true));
     setExpandAlignProperties(keyword, true, true, Gtk::ALIGN_FILL, Gtk::ALIGN_FILL);
     keyword->set_size_request(75);
-    keywords->set_tooltip_text (M("IPTCPANEL_KEYWORDSHINT"));
-    keyword->set_tooltip_text (M("IPTCPANEL_KEYWORDSHINT"));
-    addKW = Gtk::manage( new Gtk::Button () );
+    keywords->set_tooltip_text(M("IPTCPANEL_KEYWORDSHINT"));
+    keyword->set_tooltip_text(M("IPTCPANEL_KEYWORDSHINT"));
+    addKW = Gtk::manage(new Gtk::Button());
     setExpandAlignProperties(addKW, false, true, Gtk::ALIGN_CENTER, Gtk::ALIGN_FILL);
-    delKW = Gtk::manage( new Gtk::Button () );
+    delKW = Gtk::manage(new Gtk::Button());
     setExpandAlignProperties(delKW, false, true, Gtk::ALIGN_CENTER, Gtk::ALIGN_FILL);
-    Gtk::Image* addKWImg = Gtk::manage( new RTImage ("add-small.png") );
+    Gtk::Image* addKWImg = Gtk::manage(new RTImage("add-small.png"));
     setExpandAlignProperties(addKWImg, false, false, Gtk::ALIGN_CENTER, Gtk::ALIGN_CENTER);
-    Gtk::Image* delKWImg = Gtk::manage( new RTImage ("remove-small.png") );
+    Gtk::Image* delKWImg = Gtk::manage(new RTImage("remove-small.png"));
     setExpandAlignProperties(delKWImg, false, false, Gtk::ALIGN_CENTER, Gtk::ALIGN_CENTER);
-    addKW->add (*addKWImg);
-    delKW->add (*delKWImg);
-    Gtk::Grid* kwgrid = Gtk::manage( new Gtk::Grid () );
+    addKW->add(*addKWImg);
+    delKW->add(*delKWImg);
+    Gtk::Grid* kwgrid = Gtk::manage(new Gtk::Grid());
     setExpandAlignProperties(kwgrid, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    kwgrid->attach (*keyword, 0, 0, 1, 1);
-    kwgrid->attach (*addKW, 1, 0, 1, 1);
-    kwgrid->attach (*delKW, 2, 0, 1, 1);
-    iptc->attach (*keyl, 0, row++, 1, 1);
-    iptc->attach (*kwgrid, 0, row++, 1, 1);
+    kwgrid->attach(*keyword, 0, 0, 1, 1);
+    kwgrid->attach(*addKW, 1, 0, 1, 1);
+    kwgrid->attach(*delKW, 2, 0, 1, 1);
+    iptc->attach(*keyl, 0, row++, 1, 1);
+    iptc->attach(*kwgrid, 0, row++, 1, 1);
     // --------------------------
-    iptc->attach (*scrolledWindowkw, 0, row++, 2, 1);
+    iptc->attach(*scrolledWindowkw, 0, row++, 2, 1);
     // --------------------------
 
-    Gtk::Separator* hsep2 = Gtk::manage( new Gtk::Separator(Gtk::ORIENTATION_HORIZONTAL) );
+    Gtk::Separator* hsep2 = Gtk::manage(new Gtk::Separator(Gtk::ORIENTATION_HORIZONTAL));
     setExpandAlignProperties(hsep2, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    iptc->attach (*hsep2, 0, row++, 2, 1);
+    iptc->attach(*hsep2, 0, row++, 2, 1);
     // --------------------------
 
-    Gtk::Label* catl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_CATEGORY") + ":") );
+    Gtk::Label* catl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_CATEGORY") + ":"));
     setExpandAlignProperties(catl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    category = Gtk::manage(new MyComboBoxText (true));
+    category = Gtk::manage(new MyComboBoxText(true));
     category->set_size_request(75);
     setExpandAlignProperties(category, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    catl->set_tooltip_text (M("IPTCPANEL_CATEGORYHINT"));
-    category->set_tooltip_text (M("IPTCPANEL_CATEGORYHINT"));
-    Gtk::Label* scl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_SUPPCATEGORIES") + ":") );
+    catl->set_tooltip_text(M("IPTCPANEL_CATEGORYHINT"));
+    category->set_tooltip_text(M("IPTCPANEL_CATEGORYHINT"));
+    Gtk::Label* scl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_SUPPCATEGORIES") + ":"));
     setExpandAlignProperties(scl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    suppCategories = Gtk::manage( new Gtk::ListViewText (1, false, Gtk::SELECTION_MULTIPLE) );
+    suppCategories = Gtk::manage(new Gtk::ListViewText(1, false, Gtk::SELECTION_MULTIPLE));
     setExpandAlignProperties(suppCategories, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    suppCategories->set_headers_visible (false);
+    suppCategories->set_headers_visible(false);
     suppCategories->set_size_request(50, 95);
-    Gtk::ScrolledWindow* scrolledWindowsc = Gtk::manage( new Gtk::ScrolledWindow() );
+    Gtk::ScrolledWindow* scrolledWindowsc = Gtk::manage(new Gtk::ScrolledWindow());
     setExpandAlignProperties(scrolledWindowsc, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_START);
-    scrolledWindowsc->set_min_content_height (100);
+    scrolledWindowsc->set_min_content_height(100);
     scrolledWindowsc->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_ALWAYS);
     scrolledWindowsc->add(*suppCategories);
-    suppCategory  = Gtk::manage(new MyComboBoxText (true));
+    suppCategory  = Gtk::manage(new MyComboBoxText(true));
     suppCategory->set_size_request(75);
     setExpandAlignProperties(suppCategory, true, true, Gtk::ALIGN_FILL, Gtk::ALIGN_FILL);
-    scl->set_tooltip_text (M("IPTCPANEL_SUPPCATEGORIESHINT"));
-    suppCategories->set_tooltip_text (M("IPTCPANEL_SUPPCATEGORIESHINT"));
-    suppCategory->set_tooltip_text (M("IPTCPANEL_SUPPCATEGORIESHINT"));
-    addSC = Gtk::manage( new Gtk::Button () );
+    scl->set_tooltip_text(M("IPTCPANEL_SUPPCATEGORIESHINT"));
+    suppCategories->set_tooltip_text(M("IPTCPANEL_SUPPCATEGORIESHINT"));
+    suppCategory->set_tooltip_text(M("IPTCPANEL_SUPPCATEGORIESHINT"));
+    addSC = Gtk::manage(new Gtk::Button());
     setExpandAlignProperties(addSC, false, true, Gtk::ALIGN_CENTER, Gtk::ALIGN_FILL);
-    delSC = Gtk::manage( new Gtk::Button () );
+    delSC = Gtk::manage(new Gtk::Button());
     setExpandAlignProperties(delSC, false, true, Gtk::ALIGN_CENTER, Gtk::ALIGN_FILL);
-    Gtk::Image* addSCImg = Gtk::manage( new RTImage ("add-small.png") );
+    Gtk::Image* addSCImg = Gtk::manage(new RTImage("add-small.png"));
     setExpandAlignProperties(addSCImg, false, false, Gtk::ALIGN_CENTER, Gtk::ALIGN_CENTER);
-    Gtk::Image* delSCImg = Gtk::manage( new RTImage ("remove-small.png") );
+    Gtk::Image* delSCImg = Gtk::manage(new RTImage("remove-small.png"));
     setExpandAlignProperties(delSCImg, false, false, Gtk::ALIGN_CENTER, Gtk::ALIGN_CENTER);
-    addSC->add (*addSCImg);
-    delSC->add (*delSCImg);
-    Gtk::Grid* scgrid = Gtk::manage( new Gtk::Grid () );
+    addSC->add(*addSCImg);
+    delSC->add(*delSCImg);
+    Gtk::Grid* scgrid = Gtk::manage(new Gtk::Grid());
     setExpandAlignProperties(scgrid, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    scgrid->attach (*suppCategory, 0, 0, 1, 1);
-    scgrid->attach (*addSC, 1, 0, 1, 1);
-    scgrid->attach (*delSC, 2, 0, 1, 1);
-    iptc->attach (*catl, 0, row++, 1, 1);
-    iptc->attach (*category, 0, row++, 1, 1);
+    scgrid->attach(*suppCategory, 0, 0, 1, 1);
+    scgrid->attach(*addSC, 1, 0, 1, 1);
+    scgrid->attach(*delSC, 2, 0, 1, 1);
+    iptc->attach(*catl, 0, row++, 1, 1);
+    iptc->attach(*category, 0, row++, 1, 1);
     // --------------------------
-    iptc->attach (*scl, 0, row++, 1, 1);
-    iptc->attach (*scgrid, 0, row++, 1, 1);
+    iptc->attach(*scl, 0, row++, 1, 1);
+    iptc->attach(*scgrid, 0, row++, 1, 1);
     // --------------------------
-    iptc->attach (*scrolledWindowsc, 0, row++, 2, 1);
+    iptc->attach(*scrolledWindowsc, 0, row++, 2, 1);
     // --------------------------
 
-    Gtk::Separator* hsep3 = Gtk::manage( new Gtk::Separator(Gtk::ORIENTATION_HORIZONTAL) );
+    Gtk::Separator* hsep3 = Gtk::manage(new Gtk::Separator(Gtk::ORIENTATION_HORIZONTAL));
     setExpandAlignProperties(hsep3, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    iptc->attach (*hsep3, 0, row++, 2, 1);
+    iptc->attach(*hsep3, 0, row++, 2, 1);
     // --------------------------
 
-    Gtk::Label* creatorLbl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_CREATOR") + ":") );
+    Gtk::Label* creatorLbl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_CREATOR") + ":"));
     setExpandAlignProperties(creatorLbl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    creator = Gtk::manage( new Gtk::Entry () );
+    creator = Gtk::manage(new Gtk::Entry());
     setExpandAlignProperties(creator, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    creatorLbl->set_tooltip_text (M("IPTCPANEL_CREATORHINT"));
-    creator->set_tooltip_text (M("IPTCPANEL_CREATORHINT"));
-    iptc->attach (*creatorLbl, 0, row++, 1, 1);
-    iptc->attach (*creator, 0, row++, 1, 1);
+    creatorLbl->set_tooltip_text(M("IPTCPANEL_CREATORHINT"));
+    creator->set_tooltip_text(M("IPTCPANEL_CREATORHINT"));
+    iptc->attach(*creatorLbl, 0, row++, 1, 1);
+    iptc->attach(*creator, 0, row++, 1, 1);
 
     // --------------------------
 
-    Gtk::Label* creatorJobTitleLbl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_CREATORJOBTITLE") + ":") );
+    Gtk::Label* creatorJobTitleLbl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_CREATORJOBTITLE") + ":"));
     setExpandAlignProperties(creatorJobTitleLbl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    creatorJobTitle = Gtk::manage(  new Gtk::Entry () );
+    creatorJobTitle = Gtk::manage(  new Gtk::Entry());
     setExpandAlignProperties(creatorJobTitle, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    creatorJobTitleLbl->set_tooltip_text (M("IPTCPANEL_CREATORJOBTITLEHINT"));
-    creatorJobTitle->set_tooltip_text (M("IPTCPANEL_CREATORJOBTITLEHINT"));
-    iptc->attach (*creatorJobTitleLbl, 0, row++, 1, 1);
-    iptc->attach (*creatorJobTitle, 0, row++, 1, 1);
+    creatorJobTitleLbl->set_tooltip_text(M("IPTCPANEL_CREATORJOBTITLEHINT"));
+    creatorJobTitle->set_tooltip_text(M("IPTCPANEL_CREATORJOBTITLEHINT"));
+    iptc->attach(*creatorJobTitleLbl, 0, row++, 1, 1);
+    iptc->attach(*creatorJobTitle, 0, row++, 1, 1);
 
     // --------------------------
 
-    Gtk::Label* credl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_CREDIT") + ":") );
+    Gtk::Label* credl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_CREDIT") + ":"));
     setExpandAlignProperties(credl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    credit = Gtk::manage( new Gtk::Entry () );
+    credit = Gtk::manage(new Gtk::Entry());
     setExpandAlignProperties(credit, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    credl->set_tooltip_text (M("IPTCPANEL_CREDITHINT"));
-    credit->set_tooltip_text (M("IPTCPANEL_CREDITHINT"));
-    iptc->attach (*credl, 0, row++, 1, 1);
-    iptc->attach (*credit, 0, row++, 1, 1);
+    credl->set_tooltip_text(M("IPTCPANEL_CREDITHINT"));
+    credit->set_tooltip_text(M("IPTCPANEL_CREDITHINT"));
+    iptc->attach(*credl, 0, row++, 1, 1);
+    iptc->attach(*credit, 0, row++, 1, 1);
 
     // --------------------------
 
-    Gtk::Label* sourl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_SOURCE") + ":") );
+    Gtk::Label* sourl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_SOURCE") + ":"));
     setExpandAlignProperties(sourl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    source = Gtk::manage( new Gtk::Entry () );
+    source = Gtk::manage(new Gtk::Entry());
     setExpandAlignProperties(source, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    sourl->set_tooltip_text (M("IPTCPANEL_SOURCEHINT"));
-    source->set_tooltip_text (M("IPTCPANEL_SOURCEHINT"));
-    iptc->attach (*sourl, 0, row++, 1, 1);
-    iptc->attach (*source, 0, row++, 1, 1);
+    sourl->set_tooltip_text(M("IPTCPANEL_SOURCEHINT"));
+    source->set_tooltip_text(M("IPTCPANEL_SOURCEHINT"));
+    iptc->attach(*sourl, 0, row++, 1, 1);
+    iptc->attach(*source, 0, row++, 1, 1);
 
     // --------------------------
 
-    Gtk::Label* cprl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_COPYRIGHT") + ":") );
+    Gtk::Label* cprl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_COPYRIGHT") + ":"));
     setExpandAlignProperties(cprl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    copyright = Gtk::manage( new Gtk::Entry () );
+    copyright = Gtk::manage(new Gtk::Entry());
     setExpandAlignProperties(copyright, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    cprl->set_tooltip_text (M("IPTCPANEL_COPYRIGHTHINT"));
-    copyright->set_tooltip_text (M("IPTCPANEL_COPYRIGHTHINT"));
-    iptc->attach (*cprl, 0, row++, 1, 1);
-    iptc->attach (*copyright, 0, row++, 1, 1);
+    cprl->set_tooltip_text(M("IPTCPANEL_COPYRIGHTHINT"));
+    copyright->set_tooltip_text(M("IPTCPANEL_COPYRIGHTHINT"));
+    iptc->attach(*cprl, 0, row++, 1, 1);
+    iptc->attach(*copyright, 0, row++, 1, 1);
 
     // --------------------------
 
-    Gtk::Separator* hsep4 = Gtk::manage( new Gtk::Separator(Gtk::ORIENTATION_HORIZONTAL) );
+    Gtk::Separator* hsep4 = Gtk::manage(new Gtk::Separator(Gtk::ORIENTATION_HORIZONTAL));
     setExpandAlignProperties(hsep4, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    iptc->attach (*hsep4, 0, row++, 2, 1);
+    iptc->attach(*hsep4, 0, row++, 2, 1);
 
     // --------------------------
 
-    Gtk::Label* cityl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_CITY") + ":") );
+    Gtk::Label* cityl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_CITY") + ":"));
     setExpandAlignProperties(cityl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    city = Gtk::manage( new Gtk::Entry () );
+    city = Gtk::manage(new Gtk::Entry());
     setExpandAlignProperties(city, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    cityl->set_tooltip_text (M("IPTCPANEL_CITYHINT"));
-    city->set_tooltip_text (M("IPTCPANEL_CITYHINT"));
-    iptc->attach (*cityl, 0, row++, 1, 1);
-    iptc->attach (*city, 0, row++, 1, 1);
+    cityl->set_tooltip_text(M("IPTCPANEL_CITYHINT"));
+    city->set_tooltip_text(M("IPTCPANEL_CITYHINT"));
+    iptc->attach(*cityl, 0, row++, 1, 1);
+    iptc->attach(*city, 0, row++, 1, 1);
 
     // --------------------------
 
-    Gtk::Label* provl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_PROVINCE") + ":") );
+    Gtk::Label* provl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_PROVINCE") + ":"));
     setExpandAlignProperties(provl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    province = Gtk::manage( new Gtk::Entry () );
+    province = Gtk::manage(new Gtk::Entry());
     setExpandAlignProperties(province, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    provl->set_tooltip_text (M("IPTCPANEL_PROVINCEHINT"));
-    province->set_tooltip_text (M("IPTCPANEL_PROVINCEHINT"));
-    iptc->attach (*provl, 0, row++, 1, 1);
-    iptc->attach (*province, 0, row++, 1, 1);
+    provl->set_tooltip_text(M("IPTCPANEL_PROVINCEHINT"));
+    province->set_tooltip_text(M("IPTCPANEL_PROVINCEHINT"));
+    iptc->attach(*provl, 0, row++, 1, 1);
+    iptc->attach(*province, 0, row++, 1, 1);
 
     // --------------------------
 
-    Gtk::Label* ctrl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_COUNTRY") + ":") );
+    Gtk::Label* ctrl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_COUNTRY") + ":"));
     setExpandAlignProperties(ctrl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    country = Gtk::manage( new Gtk::Entry () );
+    country = Gtk::manage(new Gtk::Entry());
     setExpandAlignProperties(country, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    ctrl->set_tooltip_text (M("IPTCPANEL_COUNTRYHINT"));
-    country->set_tooltip_text (M("IPTCPANEL_COUNTRYHINT"));
-    iptc->attach (*ctrl, 0, row++, 1, 1);
-    iptc->attach (*country, 0, row++, 1, 1);
+    ctrl->set_tooltip_text(M("IPTCPANEL_COUNTRYHINT"));
+    country->set_tooltip_text(M("IPTCPANEL_COUNTRYHINT"));
+    iptc->attach(*ctrl, 0, row++, 1, 1);
+    iptc->attach(*country, 0, row++, 1, 1);
 
     // --------------------------
 
-    Gtk::Label* titll = Gtk::manage( new Gtk::Label (M("IPTCPANEL_TITLE") + ":") );
+    Gtk::Label* titll = Gtk::manage(new Gtk::Label(M("IPTCPANEL_TITLE") + ":"));
     setExpandAlignProperties(titll, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    title = Gtk::manage( new Gtk::Entry () );
+    title = Gtk::manage(new Gtk::Entry());
     setExpandAlignProperties(title, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    titll->set_tooltip_text (M("IPTCPANEL_TITLEHINT"));
-    title->set_tooltip_text (M("IPTCPANEL_TITLEHINT"));
-    iptc->attach (*titll, 0, row++, 1, 1);
-    iptc->attach (*title, 0, row++, 1, 1);
+    titll->set_tooltip_text(M("IPTCPANEL_TITLEHINT"));
+    title->set_tooltip_text(M("IPTCPANEL_TITLEHINT"));
+    iptc->attach(*titll, 0, row++, 1, 1);
+    iptc->attach(*title, 0, row++, 1, 1);
 
     // --------------------------
 
-    Gtk::Label* dcl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_DATECREATED") + ":") );
+    Gtk::Label* dcl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_DATECREATED") + ":"));
     setExpandAlignProperties(dcl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    dateCreated = Gtk::manage(  new Gtk::Entry () );
+    dateCreated = Gtk::manage(  new Gtk::Entry());
     setExpandAlignProperties(dateCreated, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    dcl->set_tooltip_text (M("IPTCPANEL_DATECREATEDHINT"));
-    dateCreated->set_tooltip_text (M("IPTCPANEL_DATECREATEDHINT"));
-    iptc->attach (*dcl, 0, row++, 1, 1);
-    iptc->attach (*dateCreated, 0, row++, 1, 1);
+    dcl->set_tooltip_text(M("IPTCPANEL_DATECREATEDHINT"));
+    dateCreated->set_tooltip_text(M("IPTCPANEL_DATECREATEDHINT"));
+    iptc->attach(*dcl, 0, row++, 1, 1);
+    iptc->attach(*dateCreated, 0, row++, 1, 1);
 
     // --------------------------
 
-    Gtk::Label* trl = Gtk::manage( new Gtk::Label (M("IPTCPANEL_TRANSREFERENCE") + ":") );
+    Gtk::Label* trl = Gtk::manage(new Gtk::Label(M("IPTCPANEL_TRANSREFERENCE") + ":"));
     setExpandAlignProperties(trl, true, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
-    transReference = Gtk::manage( new Gtk::Entry () );
+    transReference = Gtk::manage(new Gtk::Entry());
     setExpandAlignProperties(transReference, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
-    trl->set_tooltip_text (M("IPTCPANEL_TRANSREFERENCEHINT"));
-    transReference->set_tooltip_text (M("IPTCPANEL_TRANSREFERENCEHINT"));
-    iptc->attach (*trl, 0, row++, 1, 1);
-    iptc->attach (*transReference, 0, row++, 1, 1);
+    trl->set_tooltip_text(M("IPTCPANEL_TRANSREFERENCEHINT"));
+    transReference->set_tooltip_text(M("IPTCPANEL_TRANSREFERENCEHINT"));
+    iptc->attach(*trl, 0, row++, 1, 1);
+    iptc->attach(*transReference, 0, row++, 1, 1);
 
     // --------------------------
 
-    Gtk::ScrolledWindow* scrolledWindow = Gtk::manage( new Gtk::ScrolledWindow() );
+    Gtk::ScrolledWindow* scrolledWindow = Gtk::manage(new Gtk::ScrolledWindow());
     setExpandAlignProperties(scrolledWindow, false, true, Gtk::ALIGN_FILL, Gtk::ALIGN_FILL);
     scrolledWindow->set_shadow_type(Gtk::SHADOW_NONE);
     scrolledWindow->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_ALWAYS);
     scrolledWindow->property_window_placement().set_value(Gtk::CORNER_TOP_RIGHT);
     scrolledWindow->add(*iptc);
 
-    pack_start (*scrolledWindow);
+    pack_start(*scrolledWindow);
 
-    Gtk::Grid* bbox = Gtk::manage( new Gtk::Grid () );
+    Gtk::Grid* bbox = Gtk::manage(new Gtk::Grid());
     setExpandAlignProperties(bbox, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
 
-    reset = Gtk::manage( new Gtk::Button () );  // M("IPTCPANEL_RESET")
+    reset = Gtk::manage(new Gtk::Button());  // M("IPTCPANEL_RESET")
     reset->get_style_context()->add_class("Left");
-    reset->set_image (*Gtk::manage(new RTImage ("undo.png", "redo.png")));
+    reset->set_image(*Gtk::manage(new RTImage("undo.png", "redo.png")));
     setExpandAlignProperties(reset, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_FILL);
-    bbox->attach_next_to (*reset, Gtk::POS_LEFT, 1, 1);
+    bbox->attach_next_to(*reset, Gtk::POS_LEFT, 1, 1);
 
-    file = Gtk::manage( new Gtk::Button () );  // M("IPTCPANEL_EMBEDDED")
+    file = Gtk::manage(new Gtk::Button());  // M("IPTCPANEL_EMBEDDED")
     file->get_style_context()->add_class("MiddleH");
-    file->set_image (*Gtk::manage(new RTImage ("folder-open.png")));
+    file->set_image(*Gtk::manage(new RTImage("folder-open.png")));
     setExpandAlignProperties(file, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_FILL);
-    bbox->attach_next_to (*file, Gtk::POS_RIGHT, 1, 1);
+    bbox->attach_next_to(*file, Gtk::POS_RIGHT, 1, 1);
 
-    copy = Gtk::manage( new Gtk::Button () );
+    copy = Gtk::manage(new Gtk::Button());
     copy->get_style_context()->add_class("MiddleH");
-    copy->set_image (*Gtk::manage(new RTImage ("copy.png")));
+    copy->set_image(*Gtk::manage(new RTImage("copy.png")));
     setExpandAlignProperties(copy, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_FILL);
-    bbox->attach_next_to (*copy, Gtk::POS_RIGHT, 1, 1);
+    bbox->attach_next_to(*copy, Gtk::POS_RIGHT, 1, 1);
 
-    paste = Gtk::manage( new Gtk::Button () );
+    paste = Gtk::manage(new Gtk::Button());
     paste->get_style_context()->add_class("Right");
-    paste->set_image (*Gtk::manage(new RTImage ("paste.png")));
+    paste->set_image(*Gtk::manage(new RTImage("paste.png")));
     setExpandAlignProperties(paste, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_FILL);
-    bbox->attach_next_to (*paste, Gtk::POS_RIGHT, 1, 1);
+    bbox->attach_next_to(*paste, Gtk::POS_RIGHT, 1, 1);
 
-    pack_end (*bbox, Gtk::PACK_SHRINK, 2);
+    pack_end(*bbox, Gtk::PACK_SHRINK, 2);
 
     reset->set_tooltip_text(M("IPTCPANEL_RESETHINT"));
     file->set_tooltip_text(M("IPTCPANEL_EMBEDDEDHINT"));
     copy->set_tooltip_text(M("IPTCPANEL_COPYHINT"));
     paste->set_tooltip_text(M("IPTCPANEL_PASTEHINT"));
 
-    reset->signal_clicked().connect( sigc::mem_fun(*this, &IPTCPanel::resetClicked) );
-    file->signal_clicked().connect( sigc::mem_fun(*this, &IPTCPanel::fileClicked) );
-    copy->signal_clicked().connect( sigc::mem_fun(*this, &IPTCPanel::copyClicked) );
-    paste->signal_clicked().connect( sigc::mem_fun(*this, &IPTCPanel::pasteClicked) );
-
-
-    addKW->signal_clicked().connect( sigc::mem_fun(*this, &IPTCPanel::addKeyWord) );
-    delKW->signal_clicked().connect( sigc::mem_fun(*this, &IPTCPanel::delKeyWord) );
-    addSC->signal_clicked().connect( sigc::mem_fun(*this, &IPTCPanel::addSuppCategory) );
-    delSC->signal_clicked().connect( sigc::mem_fun(*this, &IPTCPanel::delSuppCategory) );
-    keyword->get_entry()->signal_activate().connect( sigc::mem_fun(*this, &IPTCPanel::addKeyWord) );
-    suppCategory->get_entry()->signal_activate().connect( sigc::mem_fun(*this, &IPTCPanel::addSuppCategory) );
-
-    conns[0] = captionText->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-    conns[1] = captionWriter->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-    conns[2] = headline->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-    conns[3] = instructions->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-    conns[4] = category->get_entry()->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-    conns[5] = creator->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-    conns[6] = creatorJobTitle->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-    conns[7] = credit->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-    conns[8] = source->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-    conns[9] = copyright->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-    conns[10] = city->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-    conns[11] = province->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-    conns[12] = country->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-    conns[13] = title->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-    conns[14] = dateCreated->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-    conns[15] = transReference->signal_changed().connect( sigc::mem_fun(*this, &IPTCPanel::updateChangeList) );
-
-    category->get_entry()->set_max_length (3);
-    keyword->get_entry()->set_max_length (64);
-    captionWriter->set_max_length (32);
-    instructions->set_max_length (256);
-    creator->set_max_length (32);
-    creatorJobTitle->set_max_length (32);
-    credit->set_max_length (32);
-    source->set_max_length (32);
-    copyright->set_max_length (128);
-    city->set_max_length (32);
-    province->set_max_length (32);
-    country->set_max_length (64);
-    title->set_max_length (64);
-    dateCreated->set_max_length (8);
-    transReference->set_max_length (32);
-
-    show_all ();
+    reset->signal_clicked().connect(sigc::mem_fun(*this, &IPTCPanel::resetClicked));
+    file->signal_clicked().connect(sigc::mem_fun(*this, &IPTCPanel::fileClicked));
+    copy->signal_clicked().connect(sigc::mem_fun(*this, &IPTCPanel::copyClicked));
+    paste->signal_clicked().connect(sigc::mem_fun(*this, &IPTCPanel::pasteClicked));
+
+
+    addKW->signal_clicked().connect(sigc::mem_fun(*this, &IPTCPanel::addKeyWord));
+    delKW->signal_clicked().connect(sigc::mem_fun(*this, &IPTCPanel::delKeyWord));
+    addSC->signal_clicked().connect(sigc::mem_fun(*this, &IPTCPanel::addSuppCategory));
+    delSC->signal_clicked().connect(sigc::mem_fun(*this, &IPTCPanel::delSuppCategory));
+    keyword->get_entry()->signal_activate().connect(sigc::mem_fun(*this, &IPTCPanel::addKeyWord));
+    suppCategory->get_entry()->signal_activate().connect(sigc::mem_fun(*this, &IPTCPanel::addSuppCategory));
+
+    conns[0] = captionText->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+    conns[1] = captionWriter->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+    conns[2] = headline->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+    conns[3] = instructions->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+    conns[4] = category->get_entry()->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+    conns[5] = creator->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+    conns[6] = creatorJobTitle->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+    conns[7] = credit->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+    conns[8] = source->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+    conns[9] = copyright->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+    conns[10] = city->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+    conns[11] = province->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+    conns[12] = country->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+    conns[13] = title->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+    conns[14] = dateCreated->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+    conns[15] = transReference->signal_changed().connect(sigc::mem_fun(*this, &IPTCPanel::updateChangeList));
+
+    category->get_entry()->set_max_length(3);
+    keyword->get_entry()->set_max_length(64);
+    captionWriter->set_max_length(32);
+    instructions->set_max_length(256);
+    creator->set_max_length(32);
+    creatorJobTitle->set_max_length(32);
+    credit->set_max_length(32);
+    source->set_max_length(32);
+    copyright->set_max_length(128);
+    city->set_max_length(32);
+    province->set_max_length(32);
+    country->set_max_length(64);
+    title->set_max_length(64);
+    dateCreated->set_max_length(10);
+    transReference->set_max_length(32);
+
+    show_all();
 }
 
+
 void IPTCPanel::read (const ProcParams* pp, const ParamsEdited* pedited)
 {
-
-    disableListener ();
+    disableListener();
     changeList->clear();
 
-    if (!pp->iptc.empty()) {
-        *changeList = pp->iptc;
+    if (!pp->metadata.iptc.empty()) {
+        *changeList = pp->metadata.iptc;
+        changelist_valid_ = true;
     } else {
         *changeList = *embeddedData;
+        changelist_valid_ = false;
     }
 
-    applyChangeList ();
-    enableListener ();
+    applyChangeList();
+    enableListener();
 }
 
+
 void IPTCPanel::write (ProcParams* pp, ParamsEdited* pedited)
 {
-
-    pp->iptc = *changeList;
+    if (changelist_valid_) {
+        pp->metadata.iptc = *changeList;
+    } else {
+        pp->metadata.iptc.clear();
+    }
 }
 
+
 void IPTCPanel::setDefaults (const ProcParams* defParams, const ParamsEdited* pedited)
 {
-
-    *defChangeList = defParams->iptc;
+    *defChangeList = defParams->metadata.iptc;
 }
 
-void IPTCPanel::setImageData (const FramesMetaData* id)
-{
 
+void IPTCPanel::setImageData(const FramesMetaData* id)
+{
+    embeddedData->clear();
     if (id) {
-        *embeddedData = id->getIPTCData ();
-    } else {
-        embeddedData->clear ();
+        try {
+            rtengine::Exiv2Metadata meta(id->getFileName());
+            meta.load();
+            auto& iptc = meta.iptcData();
+            for (const auto& tag : iptc) {
+                if (iptc_keys.find(tag.key()) != iptc_keys.end()) {
+                    (*embeddedData)[tag.key()].push_back(tag.toString());
+                }
+            }
+        } catch (const std::exception& exc) {
+            embeddedData->clear();
+        }
     }
 
-    file->set_sensitive (!embeddedData->empty());
+    file->set_sensitive(!embeddedData->empty());
 }
 
-void IPTCPanel::notifyListener ()
-{
 
+void IPTCPanel::notifyListener()
+{
     if (listener) {
-        listener->panelChanged (EvIPTC, M("HISTORY_CHANGED"));
+        listener->panelChanged(EvIPTC, M("HISTORY_CHANGED"));
     }
 }
 
-void IPTCPanel::addKeyWord ()
-{
 
-    keyword->get_entry()->select_region (0, keyword->get_entry()->get_text().size());
+void IPTCPanel::addKeyWord()
+{
+    keyword->get_entry()->select_region(0, keyword->get_entry()->get_text().size());
 
-    for (unsigned int i = 0; i < keywords->size(); i++)
-        if (keywords->get_text (i) == keyword->get_entry()->get_text()) {
+    for (unsigned int i = 0; i < keywords->size(); i++) {
+        if (keywords->get_text(i) == keyword->get_entry()->get_text()) {
             return;
         }
+    }
 
-    keywords->append (keyword->get_entry()->get_text());
-    keyword->prepend (keyword->get_entry()->get_text());
+    keywords->append(keyword->get_entry()->get_text());
+    keyword->prepend(keyword->get_entry()->get_text());
     std::vector<Glib::ustring> items;
 
     for (Gtk::TreeModel::iterator i = keyword->get_model()->children().begin(); i != keyword->get_model()->children().end(); ++i) {
         Glib::ustring s;
-        i->get_value (0, s);
-        items.push_back (s);
+        i->get_value(0, s);
+        items.push_back(s);
     }
 
-    keyword->remove_all ();
+    keyword->remove_all();
 
     for (unsigned int i = 0; i < 10 && i < items.size(); i++) {
-        keyword->append (items[i]);
+        keyword->append(items[i]);
     }
 
-    keywords->scroll_to_row (keywords->get_model()->get_path(--keywords->get_model()->children().end()));
+    keywords->scroll_to_row(keywords->get_model()->get_path(--keywords->get_model()->children().end()));
 
-    updateChangeList ();
+    updateChangeList();
 }
 
-void IPTCPanel::delKeyWord ()
-{
 
-    std::vector<int> selection = keywords->get_selected ();
+void IPTCPanel::delKeyWord()
+{
+    std::vector<int> selection = keywords->get_selected();
 
     if (!selection.empty()) {
         std::vector<Glib::ustring> keep;
 
         for (unsigned int i = 0; i < keywords->size(); i++)
-            if (std::find (selection.begin(), selection.end(), i) == selection.end()) {
-                keep.push_back (keywords->get_text (i));
+            if (std::find(selection.begin(), selection.end(), i) == selection.end()) {
+                keep.push_back(keywords->get_text(i));
             }
 
-        keywords->clear_items ();
+        keywords->clear_items();
 
-        for (unsigned int i = 0; i < keep.size(); i++) {
-            keywords->append (keep[i]);
+        for(unsigned int i = 0; i < keep.size(); i++) {
+            keywords->append(keep[i]);
         }
     }
 
-    updateChangeList ();
+    updateChangeList();
 }
 
-void IPTCPanel::addSuppCategory ()
+void IPTCPanel::addSuppCategory()
 {
 
     for (unsigned int i = 0; i < suppCategories->size(); i++)
-        if (suppCategories->get_text (i) == suppCategory->get_entry()->get_text()) {
+        if (suppCategories->get_text(i) == suppCategory->get_entry()->get_text()) {
             return;
         }
 
-    suppCategories->append (suppCategory->get_entry()->get_text());
-    suppCategory->prepend (suppCategory->get_entry()->get_text());
+    suppCategories->append(suppCategory->get_entry()->get_text());
+    suppCategory->prepend(suppCategory->get_entry()->get_text());
     std::vector<Glib::ustring> items;
 
     for (Gtk::TreeModel::iterator i = suppCategory->get_model()->children().begin(); i != suppCategory->get_model()->children().end(); ++i) {
         Glib::ustring s;
-        i->get_value (0, s);
-        items.push_back (s);
+        i->get_value(0, s);
+        items.push_back(s);
     }
 
-    suppCategory->remove_all ();
+    suppCategory->remove_all();
 
     for (unsigned int i = 0; i < 10 && i < items.size(); i++) {
-        suppCategory->append (items[i]);
+        suppCategory->append(items[i]);
     }
 
-    suppCategories->scroll_to_row (suppCategories->get_model()->get_path(--suppCategories->get_model()->children().end()));
-    suppCategory->get_entry()->select_region (0, suppCategory->get_entry()->get_text().size());
+    suppCategories->scroll_to_row(suppCategories->get_model()->get_path(--suppCategories->get_model()->children().end()));
+    suppCategory->get_entry()->select_region(0, suppCategory->get_entry()->get_text().size());
 
-    updateChangeList ();
+    updateChangeList();
 }
 
-void IPTCPanel::delSuppCategory ()
+void IPTCPanel::delSuppCategory()
 {
 
-    std::vector<int> selection = suppCategories->get_selected ();
+    std::vector<int> selection = suppCategories->get_selected();
 
     if (!selection.empty()) {
         std::vector<Glib::ustring> keep;
 
         for (unsigned int i = 0; i < suppCategories->size(); i++)
-            if (std::find (selection.begin(), selection.end(), i) == selection.end()) {
-                keep.push_back (suppCategories->get_text (i));
+            if (std::find(selection.begin(), selection.end(), i) == selection.end()) {
+                keep.push_back(suppCategories->get_text(i));
             }
 
-        suppCategories->clear_items ();
+        suppCategories->clear_items();
 
         for (unsigned int i = 0; i < keep.size(); i++) {
-            suppCategories->append (keep[i]);
+            suppCategories->append(keep[i]);
         }
     }
 
-    updateChangeList ();
+    updateChangeList();
 }
 
-void IPTCPanel::updateChangeList ()
+void IPTCPanel::updateChangeList()
 {
+    changelist_valid_ = true;
+    changeList->clear();
+    (*changeList)[CAPTION].push_back(captionText->get_text());
+    (*changeList)[CAPTION_WRITER].push_back(captionWriter->get_text());
+    (*changeList)[HEADLINE].push_back(headline->get_text());
+    (*changeList)[INSTRUCTIONS].push_back(instructions->get_text());
 
-    changeList->clear ();
-    (*changeList)["Caption"        ].push_back (captionText->get_text ());
-    (*changeList)["CaptionWriter"  ].push_back (captionWriter->get_text ());
-    (*changeList)["Headline"       ].push_back (headline->get_text ());
-    (*changeList)["Instructions"   ].push_back (instructions->get_text ());
-
+    std::set<Glib::ustring> sset;
+    sset.clear();
     for (unsigned int i = 0; i < keywords->size(); i++) {
-        (*changeList)["Keywords"       ].push_back (keywords->get_text (i));
+        sset.insert(keywords->get_text(i));
+    }
+    for (auto &s : sset) {
+        (*changeList)[KEYWORDS].push_back(s);
     }
 
-    (*changeList)["Category"       ].push_back (category->get_entry()->get_text ());
+    (*changeList)[CATEGORY].push_back(category->get_entry()->get_text());
 
+    sset.clear();
     for (unsigned int i = 0; i < suppCategories->size(); i++) {
-        (*changeList)["SupplementalCategories"].push_back (suppCategories->get_text (i));
+        sset.insert(suppCategories->get_text(i));
+    }
+    for (auto &s : sset) {
+        (*changeList)[SUPPLEMENTAL_CATEGORIES].push_back(s);
     }
 
-    (*changeList)["Creator"        ].push_back (creator->get_text ());
-    (*changeList)["CreatorJobTitle"].push_back (creatorJobTitle->get_text ());
-    (*changeList)["Credit"         ].push_back (credit->get_text ());
-    (*changeList)["Source"         ].push_back (source->get_text ());
-    (*changeList)["Copyright"      ].push_back (copyright->get_text ());
-    (*changeList)["City"           ].push_back (city->get_text ());
-    (*changeList)["Province"       ].push_back (province->get_text ());
-    (*changeList)["Country"        ].push_back (country->get_text ());
-    (*changeList)["Title"          ].push_back (title->get_text ());
-    (*changeList)["DateCreated"    ].push_back (dateCreated->get_text ());
-    (*changeList)["TransReference" ].push_back (transReference->get_text ());
-
-    notifyListener ();
+    (*changeList)[CREATOR].push_back(creator->get_text());
+    (*changeList)[CREATOR_JOB_TITLE].push_back(creatorJobTitle->get_text());
+    (*changeList)[CREDIT].push_back(credit->get_text());
+    (*changeList)[SOURCE].push_back(source->get_text());
+    (*changeList)[COPYRIGHT].push_back(copyright->get_text());
+    (*changeList)[CITY].push_back(city->get_text());
+    (*changeList)[PROVINCE].push_back(province->get_text());
+    (*changeList)[COUNTRY].push_back(country->get_text());
+    (*changeList)[TITLE].push_back(title->get_text());
+    (*changeList)[DATE_CREATED].push_back(dateCreated->get_text());
+    (*changeList)[TRANS_REFERENCE].push_back(transReference->get_text());
+
+    for (auto &p : *embeddedData) {
+        auto it = changeList->find(p.first);
+        if (it != changeList->end() && p.second == it->second) {
+            changeList->erase(it);
+        }
+    }
+
+    notifyListener();
 }
 
-void IPTCPanel::applyChangeList ()
-{
 
+void IPTCPanel::applyChangeList()
+{
     for (int i = 0; i < 16; i++) {
-        conns[i].block (true);
+        conns[i].block(true);
     }
 
-    captionText->set_text ("");
-    captionWriter->set_text ("");
-    headline->set_text ("");
-    instructions->set_text ("");
-    keywords->clear_items ();
-    category->get_entry()->set_text ("");
-    suppCategories->clear_items ();
-    creator->set_text ("");
-    creatorJobTitle->set_text ("");
-    credit->set_text ("");
-    source->set_text ("");
-    copyright->set_text ("");
-    city->set_text ("");
-    province->set_text ("");
-    country->set_text ("");
-    title->set_text ("");
-    dateCreated->set_text ("");
-    transReference->set_text ("");
-    keyword->get_entry()->set_text ("");
-    suppCategory->get_entry()->set_text ("");
+    captionText->set_text("");
+    captionWriter->set_text("");
+    headline->set_text("");
+    instructions->set_text("");
+    keywords->clear_items();
+    category->get_entry()->set_text("");
+    suppCategories->clear_items();
+    creator->set_text("");
+    creatorJobTitle->set_text("");
+    credit->set_text("");
+    source->set_text("");
+    copyright->set_text("");
+    city->set_text("");
+    province->set_text("");
+    country->set_text("");
+    title->set_text("");
+    dateCreated->set_text("");
+    transReference->set_text("");
+    keyword->get_entry()->set_text("");
+    suppCategory->get_entry()->set_text("");
 
     for (rtengine::procparams::IPTCPairs::const_iterator i = changeList->begin(); i != changeList->end(); ++i) {
-        if (i->first == "Caption" && !i->second.empty()) {
-            captionText->set_text (i->second.at(0));
-        } else if (i->first == "CaptionWriter" && !i->second.empty()) {
-            captionWriter->set_text (i->second.at(0));
-        } else if (i->first == "Headline" && !i->second.empty()) {
-            headline->set_text (i->second.at(0));
-        } else if (i->first == "Instructions" && !i->second.empty()) {
-            instructions->set_text (i->second.at(0));
-        } else if (i->first == "Keywords")
+        if (i->first == CAPTION && !i->second.empty()) {
+            captionText->set_text(i->second.at(0));
+        } else if (i->first == CAPTION_WRITER && !i->second.empty()) {
+            captionWriter->set_text(i->second.at(0));
+        } else if (i->first == HEADLINE && !i->second.empty()) {
+            headline->set_text(i->second.at(0));
+        } else if (i->first == INSTRUCTIONS && !i->second.empty()) {
+            instructions->set_text(i->second.at(0));
+        } else if (i->first == KEYWORDS) {
+            std::set<Glib::ustring> sset;
             for (unsigned int j = 0; j < i->second.size(); j++) {
-                keywords->append (i->second.at(j));
+                sset.insert(i->second[j]);
+            }
+            for (auto &s : sset) {
+                keywords->append(s);
             }
-        else if (i->first == "Category" && !i->second.empty()) {
-            category->get_entry()->set_text (i->second.at(0));
-        } else if (i->first == "SupplementalCategories")
+        } else if (i->first == CATEGORY && !i->second.empty()) {
+            category->get_entry()->set_text(i->second.at(0));
+        } else if (i->first == SUPPLEMENTAL_CATEGORIES) {
+            std::set<Glib::ustring> sset;
             for (unsigned int j = 0; j < i->second.size(); j++) {
-                suppCategories->append (i->second.at(j));
+                sset.insert(i->second[j]);
             }
-        else if (i->first == "Creator" && !i->second.empty()) {
-            creator->set_text (i->second.at(0));
-        } else if (i->first == "CreatorJobTitle" && !i->second.empty()) {
-            creatorJobTitle->set_text (i->second.at(0));
-        } else if (i->first == "Credit" && !i->second.empty()) {
-            credit->set_text (i->second.at(0));
-        } else if (i->first == "Source" && !i->second.empty()) {
-            source->set_text (i->second.at(0));
-        } else if (i->first == "Copyright" && !i->second.empty()) {
-            copyright->set_text (i->second.at(0));
-        } else if (i->first == "City" && !i->second.empty()) {
-            city->set_text (i->second.at(0));
-        } else if (i->first == "Province" && !i->second.empty()) {
-            province->set_text (i->second.at(0));
-        } else if (i->first == "Country" && !i->second.empty()) {
-            country->set_text (i->second.at(0));
-        } else if (i->first == "Title" && !i->second.empty()) {
-            title->set_text (i->second.at(0));
-        } else if (i->first == "DateCreated" && !i->second.empty()) {
-            dateCreated->set_text (i->second.at(0));
-        } else if (i->first == "TransReference" && !i->second.empty()) {
-            transReference->set_text (i->second.at(0));
+            for (auto &s : sset) {
+                suppCategories->append(s);
+            }
+        } else if (i->first == CREATOR && !i->second.empty()) {
+            creator->set_text(i->second.at(0));
+        } else if (i->first == CREATOR_JOB_TITLE && !i->second.empty()) {
+            creatorJobTitle->set_text(i->second.at(0));
+        } else if (i->first == CREDIT && !i->second.empty()) {
+            credit->set_text(i->second.at(0));
+        } else if (i->first == SOURCE && !i->second.empty()) {
+            source->set_text(i->second.at(0));
+        } else if (i->first == COPYRIGHT && !i->second.empty()) {
+            copyright->set_text(i->second.at(0));
+        } else if (i->first == CITY && !i->second.empty()) {
+            city->set_text(i->second.at(0));
+        } else if (i->first == PROVINCE && !i->second.empty()) {
+            province->set_text(i->second.at(0));
+        } else if (i->first == COUNTRY && !i->second.empty()) {
+            country->set_text(i->second.at(0));
+        } else if (i->first == TITLE && !i->second.empty()) {
+            title->set_text(i->second.at(0));
+        } else if (i->first == DATE_CREATED && !i->second.empty()) {
+            dateCreated->set_text(i->second.at(0));
+        } else if (i->first == TRANS_REFERENCE && !i->second.empty()) {
+            transReference->set_text(i->second.at(0));
         }
     }
 
     for (int i = 0; i < 16; i++) {
-        conns[i].block (false);
+        conns[i].block(false);
     }
 }
 
-void IPTCPanel::resetClicked ()
+void IPTCPanel::resetClicked()
 {
-
-    disableListener ();
+    disableListener();
     *changeList = *defChangeList;
-    applyChangeList ();
-    enableListener ();
-    notifyListener ();
+    changelist_valid_ = false;
+    applyChangeList();
+    enableListener();
+    notifyListener();
 }
 
-void IPTCPanel::fileClicked ()
+void IPTCPanel::fileClicked()
 {
 
-    disableListener ();
+    disableListener();
     *changeList = *embeddedData;
-    applyChangeList ();
-    enableListener ();
-    notifyListener ();
+    applyChangeList();
+    enableListener();
+    notifyListener();
 }
 
-void IPTCPanel::copyClicked ()
+void IPTCPanel::copyClicked()
 {
 
-    clipboard.setIPTC (*changeList);
+    clipboard.setIPTC(*changeList);
 }
 
-void IPTCPanel::pasteClicked ()
+void IPTCPanel::pasteClicked()
 {
 
-    disableListener ();
-    *changeList = clipboard.getIPTC ();
-    applyChangeList ();
-    enableListener ();
-    notifyListener ();
+    disableListener();
+    *changeList = clipboard.getIPTC();
+    applyChangeList();
+    enableListener();
+    notifyListener();
 }
diff --git a/rtgui/iptcpanel.h b/rtgui/iptcpanel.h
index da52fa7d2..66564a151 100644
--- a/rtgui/iptcpanel.h
+++ b/rtgui/iptcpanel.h
@@ -34,6 +34,7 @@ private:
     const std::unique_ptr<rtengine::procparams::IPTCPairs> changeList;
     const std::unique_ptr<rtengine::procparams::IPTCPairs> defChangeList;
     const std::unique_ptr<rtengine::procparams::IPTCPairs> embeddedData;
+    bool changelist_valid_;
 
     Gtk::TextView*  captionView;
     Glib::RefPtr<Gtk::TextBuffer> captionText;
diff --git a/rtgui/main-cli.cc b/rtgui/main-cli.cc
index cebced274..703a590e5 100644
--- a/rtgui/main-cli.cc
+++ b/rtgui/main-cli.cc
@@ -67,25 +67,6 @@ Glib::ustring argv1;
 namespace
 {
 
-// For an unknown reason, Glib::filename_to_utf8 doesn't work on reliably Windows,
-// so we're using Glib::filename_to_utf8 for Linux/Apple and Glib::locale_to_utf8 for Windows.
-Glib::ustring fname_to_utf8 (const char* fname)
-{
-#ifdef WIN32
-
-    try {
-        return Glib::locale_to_utf8 (fname);
-    } catch (Glib::Error&) {
-        return Glib::convert_with_fallback (fname, "UTF-8", "ISO-8859-1", "?");
-    }
-
-#else
-
-    return Glib::filename_to_utf8 (fname);
-
-#endif
-}
-
 bool fast_export = false;
 
 }
diff --git a/rtgui/main.cc b/rtgui/main.cc
index 30e2d7da6..0f1edbd4d 100644
--- a/rtgui/main.cc
+++ b/rtgui/main.cc
@@ -44,6 +44,7 @@
 #include "extprog.h"
 #include "../rtengine/dynamicprofile.h"
 #include "../rtengine/procparams.h"
+#include "pathutils.h"
 
 #ifndef WIN32
 #include <glibmm/fileutils.h>
@@ -71,27 +72,7 @@ bool remote = false;
 unsigned char initialGdkScale = 1;
 //Glib::Threads::Thread* mainThread;
 
-namespace
-{
-
-// For an unknown reason, Glib::filename_to_utf8 doesn't work on reliably Windows,
-// so we're using Glib::filename_to_utf8 for Linux/Apple and Glib::locale_to_utf8 for Windows.
-Glib::ustring fname_to_utf8 (const char* fname)
-{
-#ifdef WIN32
-
-    try {
-        return Glib::locale_to_utf8 (fname);
-    } catch (Glib::Error&) {
-        return Glib::convert_with_fallback (fname, "UTF-8", "ISO-8859-1", "?");
-    }
-
-#else
-
-    return Glib::filename_to_utf8 (fname);
-
-#endif
-}
+namespace {
 
 // This recursive mutex will be used by gdk_threads_enter/leave instead of a simple mutex
 static Glib::Threads::RecMutex myGdkRecMutex;
diff --git a/rtgui/metadatapanel.cc b/rtgui/metadatapanel.cc
index e26444ccc..4e6252da4 100644
--- a/rtgui/metadatapanel.cc
+++ b/rtgui/metadatapanel.cc
@@ -127,3 +127,9 @@ void MetaDataPanel::metaDataModeChanged()
         listener->panelChanged(EvMetaDataMode, M("HISTORY_CHANGED"));
     }
 }
+
+
+void MetaDataPanel::setProgressListener(rtengine::ProgressListener *pl)
+{
+    exifpanel->setProgressListener(pl);
+}
diff --git a/rtgui/metadatapanel.h b/rtgui/metadatapanel.h
index bc74ac484..aacbb9fe1 100644
--- a/rtgui/metadatapanel.h
+++ b/rtgui/metadatapanel.h
@@ -45,5 +45,7 @@ public:
 
     void setImageData(const rtengine::FramesMetaData* id);
     void setListener(ToolPanelListener *tpl) override;
+
+    void setProgressListener(rtengine::ProgressListener *pl);
 };
 
diff --git a/rtgui/options.cc b/rtgui/options.cc
index e89fcd647..34948828d 100644
--- a/rtgui/options.cc
+++ b/rtgui/options.cc
@@ -636,7 +636,7 @@ void Options::setDefaults()
     rtSettings.edghi = 3.0;//1.1 and 5.
     rtSettings.edglo = 0.5;//0.1 and 0.95
     rtSettings.limrad = 20.;//1 and 60
-    
+
 
     rtSettings.protectred = 60;
     rtSettings.protectredh = 0.3;
@@ -696,6 +696,9 @@ void Options::setDefaults()
     cropAutoFit = false;
 
     rtSettings.thumbnail_inspector_mode = rtengine::Settings::ThumbnailInspectorMode::JPEG;
+
+    rtSettings.xmp_sidecar_style = rtengine::Settings::XmpSidecarStyle::STD;
+    rtSettings.metadata_xmp_sync = rtengine::Settings::MetadataXmpSync::NONE;
 }
 
 Options* Options::copyFrom(Options* other)
@@ -1713,11 +1716,11 @@ void Options::readFromFile(Glib::ustring fname)
                 if (keyFile.has_key("GUI", "CurveBBoxPosition")) {
                     curvebboxpos = keyFile.get_integer("GUI", "CurveBBoxPosition");
                 }
-                
+
                 if (keyFile.has_key("GUI", "Complexity")) {
                     complexity = keyFile.get_integer("GUI", "Complexity");
                 }
-                
+
                 if (keyFile.has_key("GUI", "InspectorWindow")) {
                     inspectorWindow = keyFile.get_boolean("GUI", "InspectorWindow");
                 }
@@ -1961,8 +1964,8 @@ void Options::readFromFile(Glib::ustring fname)
                 }
 
             }
-            
-            
+
+
             if (keyFile.has_group("ICC Profile Creator")) {
                 if (keyFile.has_key("ICC Profile Creator", "PimariesPreset")) {
                     ICCPC_primariesPreset = keyFile.get_string("ICC Profile Creator", "PimariesPreset");
@@ -2246,6 +2249,27 @@ void Options::readFromFile(Glib::ustring fname)
                 }
             }
 
+            if (keyFile.has_group("Metadata")) {
+                if (keyFile.has_key("Metadata", "XMPSidecarStyle")) {
+                    std::string val = keyFile.get_string("Metadata", "XMPSidecarStyle");
+                    if (val == "ext") {
+                        rtSettings.xmp_sidecar_style = rtengine::Settings::XmpSidecarStyle::EXT;
+                    } else {
+                        rtSettings.xmp_sidecar_style = rtengine::Settings::XmpSidecarStyle::STD;
+                    }
+                }
+                if (keyFile.has_key("Metadata", "XMPSynchronization")) {
+                    std::string val = keyFile.get_string("Metadata", "XMPSynchronization");
+                    if (val == "read") {
+                        rtSettings.metadata_xmp_sync = rtengine::Settings::MetadataXmpSync::READ;
+                    } else if (val == "readwrite") {
+                        rtSettings.metadata_xmp_sync = rtengine::Settings::MetadataXmpSync::READ_WRITE;
+                    } else {
+                        rtSettings.metadata_xmp_sync = rtengine::Settings::MetadataXmpSync::NONE;
+                    }
+                }
+            }
+
 // --------------------------------------------------------------------------------------------------------
 
             filterOutParsedExtensions();
@@ -2695,6 +2719,25 @@ void Options::saveToFile(Glib::ustring fname)
 
         keyFile.set_string("Lensfun", "DBDirectory", rtSettings.lensfunDbDirectory);
 
+        switch (rtSettings.xmp_sidecar_style) {
+        case rtengine::Settings::XmpSidecarStyle::EXT:
+            keyFile.set_string("Metadata", "XMPSidecarStyle", "ext");
+            break;
+        default:
+            keyFile.set_string("Metadata", "XMPSidecarStyle", "std");
+        }
+
+        switch (rtSettings.metadata_xmp_sync) {
+        case rtengine::Settings::MetadataXmpSync::READ:
+            keyFile.set_string("Metadata", "XMPSynchronization", "read");
+            break;
+        case rtengine::Settings::MetadataXmpSync::READ_WRITE:
+            keyFile.set_string("Metadata", "XMPSynchronization", "readwrite");
+            break;
+        default:
+            keyFile.set_string("Metadata", "XMPSynchronization", "none");
+        }
+
         keyData = keyFile.to_data();
 
     } catch (Glib::KeyFileError &e) {
diff --git a/rtgui/paramsedited.cc b/rtgui/paramsedited.cc
index 20450fa24..6dc6ccaf4 100644
--- a/rtgui/paramsedited.cc
+++ b/rtgui/paramsedited.cc
@@ -714,6 +714,7 @@ void ParamsEdited::set(bool v)
     dehaze.depth = v;
     dehaze.saturation = v;
     metadata.mode = v;
+    metadata.exifKeys = v;
     filmNegative.enabled = v;
     filmNegative.redRatio = v;
     filmNegative.greenExp = v;
@@ -2128,6 +2129,7 @@ void ParamsEdited::initFrom(const std::vector<rtengine::procparams::ProcParams>&
         dehaze.depth = dehaze.depth && p.dehaze.depth == other.dehaze.depth;
         dehaze.saturation = dehaze.saturation && p.dehaze.saturation == other.dehaze.saturation;
         metadata.mode = metadata.mode && p.metadata.mode == other.metadata.mode;
+        metadata.exifKeys = metadata.exifKeys && p.metadata.exifKeys == other.metadata.exifKeys;
         filmNegative.enabled = filmNegative.enabled && p.filmNegative.enabled == other.filmNegative.enabled;
         filmNegative.redRatio = filmNegative.redRatio && p.filmNegative.redRatio == other.filmNegative.redRatio;
         filmNegative.greenExp = filmNegative.greenExp && p.filmNegative.greenExp == other.filmNegative.greenExp;
@@ -7382,6 +7384,10 @@ void ParamsEdited::combine(rtengine::procparams::ProcParams& toEdit, const rteng
         toEdit.metadata.mode = mods.metadata.mode;
     }
 
+    if (metadata.exifKeys) {
+        toEdit.metadata.exifKeys = mods.metadata.exifKeys;
+    }
+
     if (filmNegative.enabled) {
         toEdit.filmNegative.enabled = mods.filmNegative.enabled;
     }
@@ -7419,15 +7425,15 @@ void ParamsEdited::combine(rtengine::procparams::ProcParams& toEdit, const rteng
 
     // Exif changes are added to the existing ones
     if (exif) {
-        for (procparams::ExifPairs::const_iterator i = mods.exif.begin(); i != mods.exif.end(); ++i) {
-            toEdit.exif[i->first] = i->second;
+        for (procparams::ExifPairs::const_iterator i = mods.metadata.exif.begin(); i != mods.metadata.exif.end(); ++i) {
+            toEdit.metadata.exif[i->first] = i->second;
         }
     }
 
     // IPTC changes are added to the existing ones
     if (iptc) {
-        for (procparams::IPTCPairs::const_iterator i = mods.iptc.begin(); i != mods.iptc.end(); ++i) {
-            toEdit.iptc[i->first] = i->second;
+        for (procparams::IPTCPairs::const_iterator i = mods.metadata.iptc.begin(); i != mods.metadata.iptc.end(); ++i) {
+            toEdit.metadata.iptc[i->first] = i->second;
         }
     }
 }
diff --git a/rtgui/paramsedited.h b/rtgui/paramsedited.h
index d85bec701..4df838194 100644
--- a/rtgui/paramsedited.h
+++ b/rtgui/paramsedited.h
@@ -1522,6 +1522,7 @@ struct RAWParamsEdited {
 
 struct MetaDataParamsEdited {
     bool mode;
+    bool exifKeys;
 };
 
 struct FilmNegativeParamsEdited {
diff --git a/rtgui/pathutils.cc b/rtgui/pathutils.cc
index fc47a0e25..ef67564b2 100644
--- a/rtgui/pathutils.cc
+++ b/rtgui/pathutils.cc
@@ -16,6 +16,7 @@
  *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
  */
 
+#include <glibmm/convert.h>
 #include <glibmm/miscutils.h>
 
 #include "pathutils.h"
@@ -48,3 +49,23 @@ Glib::ustring getExtension (const Glib::ustring& filename)
         return "";
     }
 }
+
+
+// For an unknown reason, Glib::filename_to_utf8 doesn't work on reliably Windows,
+// so we're using Glib::filename_to_utf8 for Linux/Apple and Glib::locale_to_utf8 for Windows.
+Glib::ustring fname_to_utf8(const std::string &fname)
+{
+#ifdef WIN32
+
+    try {
+        return Glib::locale_to_utf8(fname);
+    } catch (Glib::Error&) {
+        return Glib::convert_with_fallback(fname, "UTF-8", "ISO-8859-1", "?");
+    }
+
+#else
+
+    return Glib::filename_to_utf8(fname);
+
+#endif
+}
diff --git a/rtgui/pathutils.h b/rtgui/pathutils.h
index 482dfb82f..8ac1533b7 100644
--- a/rtgui/pathutils.h
+++ b/rtgui/pathutils.h
@@ -1,4 +1,5 @@
-/*
+/* -*- C++ -*-
+ *
  *  This file is part of RawTherapee.
  *
  *  Copyright (c) 2004-2010 Gabor Horvath <hgabor@rawtherapee.com>
@@ -18,7 +19,9 @@
  */
 #pragma once
 #include <glibmm/ustring.h>
+#include <string>
 
 // Removed from guiutils because used by rawtherapee-cli
 Glib::ustring removeExtension (const Glib::ustring& filename);
 Glib::ustring getExtension (const Glib::ustring& filename);
+Glib::ustring fname_to_utf8(const std::string& fname);
diff --git a/rtgui/preferences.cc b/rtgui/preferences.cc
index 1ae01da2d..34fd69da8 100644
--- a/rtgui/preferences.cc
+++ b/rtgui/preferences.cc
@@ -547,7 +547,7 @@ Gtk::Widget* Preferences::getImageProcessingPanel ()
     iprofiles->set_size_request(50, -1);
     setExpandAlignProperties(iprofiles, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_FILL);
     ipconn = iprofiles->signal_changed().connect(sigc::mem_fun(*this, &Preferences::forImageComboChanged));
-    
+
     Gtk::Grid* defpt = Gtk::manage(new Gtk::Grid());
     defpt->set_row_spacing(2);
     defpt->attach(*drlab, 0, 0, 1, 1);
@@ -555,7 +555,7 @@ Gtk::Widget* Preferences::getImageProcessingPanel ()
     defpt->attach(*drimg, 0, 1, 1, 1);
     defpt->attach(*iprofiles, 1, 1, 1, 1);
     vbpp->pack_start(*defpt, Gtk::PACK_SHRINK, 4);
-    
+
     useBundledProfiles = Gtk::manage(new Gtk::CheckButton(M("PREFERENCES_USEBUNDLEDPROFILES")));
     bpconn = useBundledProfiles->signal_clicked().connect(sigc::mem_fun(*this, &Preferences::bundledProfilesChanged));
     vbpp->pack_start(*useBundledProfiles, Gtk::PACK_SHRINK, 4);
@@ -601,9 +601,36 @@ Gtk::Widget* Preferences::getImageProcessingPanel ()
     fdp->add(*vbdp);
     vbImageProcessing->pack_start (*fdp, Gtk::PACK_SHRINK, 4);
 
-//    Gtk::Frame* fdf = Gtk::manage (new Gtk::Frame (M ("PREFERENCES_DARKFRAME")) );
-//    Gtk::Box* hb42 = Gtk::manage (new Gtk::Box ());
-//    darkFrameDir = Gtk::manage (new Gtk::FileChooserButton (M ("PREFERENCES_DIRDARKFRAMES"), Gtk::FILE_CHOOSER_ACTION_SELECT_FOLDER));
+    // Metadata
+    Gtk::Frame *mf = Gtk::manage(new Gtk::Frame(M("PREFERENCES_METADATA")));
+    Gtk::Grid *mtbl = Gtk::manage(new Gtk::Grid());
+    setExpandAlignProperties(mtbl, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
+
+    metadataSyncCombo = Gtk::manage(new Gtk::ComboBoxText());
+    metadataSyncCombo->set_active(0);
+    metadataSyncCombo->append(M("PREFERENCES_METADATA_SYNC_NONE"));
+    metadataSyncCombo->append(M("PREFERENCES_METADATA_SYNC_READ"));
+    metadataSyncCombo->append(M("PREFERENCES_METADATA_SYNC_READWRITE"));
+    Gtk::Label *mlbl = Gtk::manage(new Gtk::Label(M("PREFERENCES_METADATA_SYNC") + ": "));
+    mtbl->attach(*mlbl, 0, 0, 1, 1);
+    mtbl->attach_next_to(*metadataSyncCombo, *mlbl, Gtk::POS_RIGHT, 1, 1);
+    setExpandAlignProperties(mlbl, false, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
+    setExpandAlignProperties(metadataSyncCombo, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
+
+    xmpSidecarCombo = Gtk::manage(new Gtk::ComboBoxText());
+    xmpSidecarCombo->set_active(0);
+    xmpSidecarCombo->append(M("PREFERENCES_XMP_SIDECAR_MODE_STD"));
+    xmpSidecarCombo->append(M("PREFERENCES_XMP_SIDECAR_MODE_EXT"));
+
+    mlbl = Gtk::manage(new Gtk::Label(M("PREFERENCES_XMP_SIDECAR_MODE") + ": "));
+    mtbl->attach(*mlbl, 0, 2, 1, 1);
+    mtbl->attach_next_to(*xmpSidecarCombo, *mlbl, Gtk::POS_RIGHT, 1, 1);
+    setExpandAlignProperties(mlbl, false, false, Gtk::ALIGN_START, Gtk::ALIGN_CENTER);
+    setExpandAlignProperties(xmpSidecarCombo, true, false, Gtk::ALIGN_FILL, Gtk::ALIGN_CENTER);
+
+    mf->add(*mtbl);
+    vbImageProcessing->pack_start(*mf, Gtk::PACK_SHRINK, 4);
+
     // Directories
     Gtk::Frame* cdf = Gtk::manage(new Gtk::Frame(M("PREFERENCES_DIRECTORIES")));
     Gtk::Grid* dirgrid = Gtk::manage(new Gtk::Grid());
@@ -1162,7 +1189,7 @@ Gtk::Widget* Preferences::getGeneralPanel()
     setExpandAlignProperties(pseudoHiDPI, false, false, Gtk::ALIGN_START, Gtk::ALIGN_BASELINE);
 
     Gtk::Separator *vSep = Gtk::manage(new Gtk::Separator(Gtk::ORIENTATION_VERTICAL));
-    
+
 
     appearanceGrid->attach(*themeLbl,           0, 0, 1, 1);
     appearanceGrid->attach(*themeCBT,           1, 0, 1, 1);
@@ -1919,6 +1946,9 @@ void Preferences::storePreferences()
     moptions.cropAutoFit = cropAutoFitCB->get_active();
 
     toolLocationPreference->updateOptions();
+
+    moptions.rtSettings.metadata_xmp_sync = rtengine::Settings::MetadataXmpSync(metadataSyncCombo->get_active_row_number());
+    moptions.rtSettings.xmp_sidecar_style = rtengine::Settings::XmpSidecarStyle(xmpSidecarCombo->get_active_row_number());
 }
 
 void Preferences::fillPreferences()
@@ -2096,7 +2126,7 @@ void Preferences::fillPreferences()
     }
 
     curveBBoxPosC->set_active(moptions.curvebboxpos);
-    complexitylocal->set_active(moptions.complexity); 
+    complexitylocal->set_active(moptions.complexity);
     inspectorWindowCB->set_active(moptions.inspectorWindow);
     zoomOnScrollCB->set_active(moptions.zoomOnScroll);
 
@@ -2167,6 +2197,9 @@ void Preferences::fillPreferences()
     txtSndLngEditProcDone->set_text(moptions.sndLngEditProcDone);
     spbSndLngEditProcDoneSecs->set_value(moptions.sndLngEditProcDoneSecs);
 #endif
+
+    metadataSyncCombo->set_active(int(moptions.rtSettings.metadata_xmp_sync));
+    xmpSidecarCombo->set_active(int(moptions.rtSettings.xmp_sidecar_style));
 }
 
 /*
diff --git a/rtgui/preferences.h b/rtgui/preferences.h
index 6e31761a4..2ed7889ab 100644
--- a/rtgui/preferences.h
+++ b/rtgui/preferences.h
@@ -246,6 +246,9 @@ class Preferences final :
     Gtk::ComboBoxText *cropGuidesCombo;
     Gtk::CheckButton *cropAutoFitCB;
 
+    Gtk::ComboBoxText *metadataSyncCombo;
+    Gtk::ComboBoxText *xmpSidecarCombo;
+
     Glib::ustring storedValueRaw;
     Glib::ustring storedValueImg;
 
diff --git a/rtgui/procparamchangers.h b/rtgui/procparamchangers.h
index 8dd3769c6..0ca76a0eb 100644
--- a/rtgui/procparamchangers.h
+++ b/rtgui/procparamchangers.h
@@ -1,4 +1,5 @@
-/*
+/* -*- C++ -*-
+ *  
  *  This file is part of RawTherapee.
  *
  *  Copyright (c) 2004-2010 Gabor Horvath <hgabor@rawtherapee.com>
@@ -16,9 +17,9 @@
  *  You should have received a copy of the GNU General Public License
  *  along with RawTherapee.  If not, see <https://www.gnu.org/licenses/>.
  */
-#define UNKNOWN    -1
-#define FILEBROWSER 1
-#define EDITOR      2
-#define BATCHEDITOR 3
-#define CACHEMGR    4
-#define SAFETYUPDATE 5
+constexpr int UNKNOWN = -1;
+constexpr int FILEBROWSER = 1;
+constexpr int EDITOR = 2;
+constexpr int BATCHEDITOR = 3;
+constexpr int CACHEMGR = 4;
+constexpr int SAFETYUPDATE = 5;
diff --git a/rtgui/shcselector.cc b/rtgui/shcselector.cc
index ad2c28aaa..175c732a2 100644
--- a/rtgui/shcselector.cc
+++ b/rtgui/shcselector.cc
@@ -20,6 +20,7 @@
 #include <iomanip>
 
 #include "shcselector.h"
+
 #include "multilangmgr.h"
 #include "mycurve.h"
 #include "rtscalable.h"
diff --git a/rtgui/thumbnail.cc b/rtgui/thumbnail.cc
index dd7995feb..a2941aaa5 100644
--- a/rtgui/thumbnail.cc
+++ b/rtgui/thumbnail.cc
@@ -34,16 +34,78 @@
 #include <glibmm/timezone.h>
 
 #include "../rtengine/dynamicprofile.h"
+#include "../rtengine/metadata.h"
 #include "../rtengine/profilestore.h"
 #include "../rtengine/settings.h"
-#include "../rtexif/rtexif.h"
 #include "guiutils.h"
 #include "batchqueue.h"
 #include "extprog.h"
 #include "md5helper.h"
 #include "pathutils.h"
 #include "paramsedited.h"
+#include "ppversion.h"
 #include "procparamchangers.h"
+#include "version.h"
+
+
+namespace {
+
+bool CPBDump(
+    const Glib::ustring& commFName,
+    const Glib::ustring& imageFName,
+    const Glib::ustring& profileFName,
+    const Glib::ustring& defaultPParams,
+    const CacheImageData* cfs,
+    bool flagMode
+)
+{
+    const std::unique_ptr<Glib::KeyFile> kf(new Glib::KeyFile);
+
+    if (!kf) {
+        return false;
+    }
+
+    // open the file in write mode
+    const std::unique_ptr<FILE, decltype(&std::fclose)> f(g_fopen(commFName.c_str (), "wt"), &std::fclose);
+
+    if (!f) {
+        printf ("CPBDump(\"%s\") >>> Error: unable to open file with write access!\n", commFName.c_str());
+        return false;
+    }
+
+    try {
+        kf->set_string ("RT General", "CachePath", options.cacheBaseDir);
+        kf->set_string ("RT General", "AppVersion", RTVERSION);
+        kf->set_integer ("RT General", "ProcParamsVersion", PPVERSION);
+        kf->set_string ("RT General", "ImageFileName", imageFName);
+        kf->set_string ("RT General", "OutputProfileFileName", profileFName);
+        kf->set_string ("RT General", "DefaultProcParams", defaultPParams);
+        kf->set_boolean ("RT General", "FlaggingMode", flagMode);
+
+        kf->set_integer ("Common Data", "FrameCount", cfs->frameCount);
+        kf->set_integer ("Common Data", "SampleFormat", cfs->sampleFormat);
+        kf->set_boolean ("Common Data", "IsHDR", cfs->isHDR);
+        kf->set_boolean ("Common Data", "IsPixelShift", cfs->isPixelShift);
+        kf->set_double ("Common Data", "FNumber", cfs->fnumber);
+        kf->set_double ("Common Data", "Shutter", cfs->shutter);
+        kf->set_double ("Common Data", "FocalLength", cfs->focalLen);
+        kf->set_integer ("Common Data", "ISO", cfs->iso);
+        kf->set_string ("Common Data", "Lens", cfs->lens);
+        kf->set_string ("Common Data", "Make", cfs->camMake);
+        kf->set_string ("Common Data", "Model", cfs->camModel);
+
+    } catch (const Glib::KeyFileError&) {
+    }
+
+    try {
+        fprintf (f.get(), "%s", kf->to_data().c_str());
+    } catch (const Glib::KeyFileError&) {
+    }
+
+    return true;
+}
+
+} // namespace
 
 using namespace rtengine::procparams;
 
@@ -86,7 +148,7 @@ Thumbnail::Thumbnail(CacheManager* cm, const Glib::ustring& fname, CacheImageDat
     tpp = nullptr;
 }
 
-Thumbnail::Thumbnail(CacheManager* cm, const Glib::ustring& fname, const std::string& md5) :
+Thumbnail::Thumbnail(CacheManager* cm, const Glib::ustring& fname, const std::string& md5, const std::string &xmpSidecarMd5) :
     fname(fname),
     cachemgr(cm),
     ref(1),
@@ -104,6 +166,7 @@ Thumbnail::Thumbnail(CacheManager* cm, const Glib::ustring& fname, const std::st
 
 
     cfs.md5 = md5;
+    cfs.xmpSidecarMd5 = xmpSidecarMd5;
     loadProcParams ();
     _generateThumbnailImage ();
     cfs.recentlySaved = false;
@@ -114,6 +177,11 @@ Thumbnail::Thumbnail(CacheManager* cm, const Glib::ustring& fname, const std::st
     tpp = nullptr;
 }
 
+Glib::ustring Thumbnail::xmpSidecarPath(const Glib::ustring &imagePath)
+{
+    return rtengine::Exiv2Metadata::xmpSidecarPath(imagePath);
+}
+
 void Thumbnail::_generateThumbnailImage ()
 {
 
@@ -163,24 +231,27 @@ void Thumbnail::_generateThumbnailImage ()
         //     image out of the RAW. Mark as "quick".
         //  2. if we don't find that then just grab the real image.
         bool quick = false;
-        rtengine::RawMetaDataLocation ri;
 
         rtengine::eSensorType sensorType = rtengine::ST_NONE;
         if ( initial_ && options.internalThumbIfUntouched) {
             quick = true;
-            tpp = rtengine::Thumbnail::loadQuickFromRaw (fname, ri, sensorType, tw, th, 1, TRUE);
+            tpp = rtengine::Thumbnail::loadQuickFromRaw (fname, sensorType, tw, th, 1, TRUE);
         }
 
         if ( tpp == nullptr ) {
             quick = false;
-            tpp = rtengine::Thumbnail::loadFromRaw (fname, ri, sensorType, tw, th, 1, pparams->wb.equal, pparams->wb.observer, TRUE);
+            tpp = rtengine::Thumbnail::loadFromRaw (fname, sensorType, tw, th, 1, pparams->wb.equal, pparams->wb.observer, TRUE);
         }
 
         cfs.sensortype = sensorType;
         if (tpp) {
             cfs.format = FT_Raw;
             cfs.thumbImgType = quick ? CacheImageData::QUICK_THUMBNAIL : CacheImageData::FULL_THUMBNAIL;
-            infoFromImage (fname, std::unique_ptr<rtengine::RawMetaDataLocation>(new rtengine::RawMetaDataLocation(ri)));
+            infoFromImage (fname);
+            if (!quick) {
+                cfs.width = tpp->full_width;
+                cfs.height = tpp->full_height;
+            }
         }
     }
 
@@ -241,7 +312,6 @@ const ProcParams& Thumbnail::getProcParamsU ()
  */
 rtengine::procparams::ProcParams* Thumbnail::createProcParamsForUpdate(bool returnParams, bool force, bool flaggingMode)
 {
-
     // try to load the last saved parameters from the cache or from the paramfile file
     ProcParams* ldprof = nullptr;
 
@@ -259,52 +329,35 @@ rtengine::procparams::ProcParams* Thumbnail::createProcParamsForUpdate(bool retu
 
     if (!run_cpb) {
         if (defProf == DEFPROFILE_DYNAMIC && create && cfs && cfs->exifValid) {
-            rtengine::FramesMetaData* imageMetaData;
-            if (getType() == FT_Raw) {
-                // Should we ask all frame's MetaData ?
-                imageMetaData = rtengine::FramesMetaData::fromFile (fname, std::unique_ptr<rtengine::RawMetaDataLocation>(new rtengine::RawMetaDataLocation(rtengine::Thumbnail::loadMetaDataFromRaw(fname))), true);
-            } else {
-                // Should we ask all frame's MetaData ?
-                imageMetaData = rtengine::FramesMetaData::fromFile (fname, nullptr, true);
-            }
-            PartialProfile *pp = ProfileStore::getInstance()->loadDynamicProfile(imageMetaData, fname);
-            delete imageMetaData;
-            int err = pp->pparams->save(outFName);
-            pp->deleteInstance();
-            delete pp;
-            if (!err) {
+            const auto pp_deleter =
+                [](PartialProfile* pp)
+                {
+                    pp->deleteInstance();
+                    delete pp;
+                };
+            const std::unique_ptr<const rtengine::FramesMetaData> imageMetaData(rtengine::FramesMetaData::fromFile(fname));
+            const std::unique_ptr<PartialProfile, decltype(pp_deleter)> pp(
+                imageMetaData
+                    ? ProfileStore::getInstance()->loadDynamicProfile(imageMetaData.get(), fname)
+                    : nullptr,
+                pp_deleter
+            );
+            if (pp && !pp->pparams->save(outFName)) {
                 loadProcParams();
             }
         } else if (create && defProf != DEFPROFILE_DYNAMIC) {
-            const PartialProfile *p = ProfileStore::getInstance()->getProfile(defProf);
+            const PartialProfile* const p = ProfileStore::getInstance()->getProfile(defProf);
             if (p && !p->pparams->save(outFName)) {
                 loadProcParams();
             }
         }
     } else {
         // First generate the communication file, with general values and EXIF metadata
-        rtengine::FramesMetaData* imageMetaData;
-
-        if (getType() == FT_Raw) {
-            // Should we ask all frame's MetaData ?
-            imageMetaData = rtengine::FramesMetaData::fromFile (fname, std::unique_ptr<rtengine::RawMetaDataLocation>(new rtengine::RawMetaDataLocation(rtengine::Thumbnail::loadMetaDataFromRaw(fname))), true);
-        } else {
-            // Should we ask all frame's MetaData ?
-            imageMetaData = rtengine::FramesMetaData::fromFile (fname, nullptr, true);
-        }
-
         static int index = 0; // Will act as unique identifier during the session
         Glib::ustring tmpFileName( Glib::build_filename(options.cacheBaseDir, Glib::ustring::compose("CPB_temp_%1.txt", index++)) );
 
-        const rtexif::TagDirectory* exifDir = nullptr;
-
-        if (imageMetaData && (exifDir = imageMetaData->getRootExifData())) {
-            exifDir->CPBDump(tmpFileName, fname, outFName,
-                             defaultPparamsPath == DEFPROFILE_INTERNAL ? DEFPROFILE_INTERNAL : Glib::build_filename(defaultPparamsPath, Glib::path_get_basename(defProf) + paramFileExtension),
-                             cfs,
-                             flaggingMode);
-        }
-        delete imageMetaData;
+        CPBDump(tmpFileName, fname, outFName,
+                defaultPparamsPath == DEFPROFILE_INTERNAL ? DEFPROFILE_INTERNAL : Glib::build_filename(defaultPparamsPath, Glib::path_get_basename(defProf) + paramFileExtension), cfs, flaggingMode);
 
         // For the filename etc. do NOT use streams, since they are not UTF8 safe
         Glib::ustring cmdLine = options.CPBPath + Glib::ustring(" \"") + tmpFileName + Glib::ustring("\"");
@@ -345,7 +398,7 @@ void Thumbnail::notifylisterners_procParamsChanged(int whoChangedIt)
  * The result is a complete ProcParams with default values merged with the values
  * from the loaded ProcParams (sidecar or cache file).
 */
-void Thumbnail::loadProcParams ()
+void Thumbnail::loadProcParams()
 {
     MyMutex::MyLock lock(mutex);
 
@@ -803,9 +856,14 @@ ThFileType Thumbnail::getType () const
     return (ThFileType) cfs.format;
 }
 
-int Thumbnail::infoFromImage (const Glib::ustring& fname, std::unique_ptr<rtengine::RawMetaDataLocation> rml)
+int Thumbnail::infoFromImage (const Glib::ustring& fname)
 {
-    rtengine::FramesMetaData* idata = rtengine::FramesMetaData::fromFile (fname, std::move(rml));
+    return infoFromImage(fname, cfs);
+}
+
+int Thumbnail::infoFromImage(const Glib::ustring &fname, CacheImageData &cfs)
+{
+    std::unique_ptr<rtengine::FramesMetaData> idata(rtengine::FramesMetaData::fromFile (fname));
 
     if (!idata) {
         return 0;
@@ -866,7 +924,8 @@ int Thumbnail::infoFromImage (const Glib::ustring& fname, std::unique_ptr<rtengi
         cfs.filetype = "";
     }
 
-    delete idata;
+    idata->getDimensions(cfs.width, cfs.height);
+
     return deg;
 }
 
@@ -986,6 +1045,10 @@ void Thumbnail::updateCache (bool updatePParams, bool updateCacheImageData)
     if (updateCacheImageData) {
         cfs.save (getCacheFileName ("data", ".txt"));
     }
+
+    if (updatePParams && pparamsValid) {
+        saveMetadata();
+    }
 }
 
 Thumbnail::~Thumbnail ()
@@ -1164,6 +1227,33 @@ void Thumbnail::getCamWB(double& temp, double& green, rtengine::StandardObserver
     }
 }
 
+void Thumbnail::saveMetadata()
+{
+    if (options.rtSettings.metadata_xmp_sync != rtengine::Settings::MetadataXmpSync::READ_WRITE) {
+        return;
+    }
+
+    if (pparams->metadata.exif.empty() && pparams->metadata.iptc.empty()) {
+        return;
+    }
+
+    auto fn = rtengine::Exiv2Metadata::xmpSidecarPath(fname);
+    try {
+        auto xmp = rtengine::Exiv2Metadata::getXmpSidecar(fname);
+        rtengine::Exiv2Metadata meta;
+        meta.xmpData() = std::move(xmp);
+        meta.setExif(pparams->metadata.exif);
+        meta.setIptc(pparams->metadata.iptc);
+        meta.saveToXmp(fn);
+        if (options.rtSettings.verbose) {
+            std::cout << "saved edited metadata for " << fname << " to "
+                      << fn << std::endl;
+        }
+    } catch (std::exception &exc) {
+        std::cerr << "ERROR saving metadata for " << fname << " to " << fn
+                  << ": " << exc.what() << std::endl;
+    }
+}
 void Thumbnail::getSpotWB(int x, int y, int rect, double& temp, double& green)
 {
     if (tpp) {
diff --git a/rtgui/thumbnail.h b/rtgui/thumbnail.h
index 4d0355747..9ead1e5e8 100644
--- a/rtgui/thumbnail.h
+++ b/rtgui/thumbnail.h
@@ -84,16 +84,21 @@ class Thumbnail
     void            _loadThumbnail (bool firstTrial = true);
     void            _saveThumbnail ();
     void            _generateThumbnailImage ();
-    int             infoFromImage (const Glib::ustring& fname, std::unique_ptr<rtengine::RawMetaDataLocation> rml = nullptr);
+    int             infoFromImage (const Glib::ustring& fname);
     void            generateExifDateTimeStrings ();
 
     Glib::ustring    getCacheFileName (const Glib::ustring& subdir, const Glib::ustring& fext) const;
 
+    void saveMetadata();
+
 public:
     Thumbnail (CacheManager* cm, const Glib::ustring& fname, CacheImageData* cf);
-    Thumbnail (CacheManager* cm, const Glib::ustring& fname, const std::string& md5);
+    Thumbnail (CacheManager* cm, const Glib::ustring& fname, const std::string& md5, const std::string &xmpSidecarMd5);
     ~Thumbnail ();
 
+    static int infoFromImage(const Glib::ustring &fname, CacheImageData &cfs);
+    static Glib::ustring xmpSidecarPath(const Glib::ustring &imagePath);
+
     bool              hasProcParams () const;
     const rtengine::procparams::ProcParams& getProcParams ();
     const rtengine::procparams::ProcParams& getProcParamsU ();  // Unprotected version
diff --git a/rtgui/toolpanelcoord.cc b/rtgui/toolpanelcoord.cc
index 92bf3d7a5..4863732f9 100644
--- a/rtgui/toolpanelcoord.cc
+++ b/rtgui/toolpanelcoord.cc
@@ -1175,8 +1175,8 @@ void ToolPanelCoordinator::profileChange(
 
     // Reset IPTC values when switching procparams from the History
     if (event == rtengine::EvHistoryBrowsed) {
-        mergedParams->iptc.clear();
-        mergedParams->exif.clear();
+        mergedParams->metadata.iptc.clear();
+        mergedParams->metadata.exif.clear();
     }
 
     // And apply the partial profile nparams to mergedParams
@@ -1900,6 +1900,12 @@ bool ToolPanelCoordinator::getFilmNegativeSpot(rtengine::Coord spot, int spotSiz
     return ipc && ipc->getFilmNegativeSpot(spot.x, spot.y, spotSize, refInput, refOutput);
 }
 
+
+void ToolPanelCoordinator::setProgressListener(rtengine::ProgressListener *pl)
+{
+    metadata->setProgressListener(pl);
+}
+
 FoldableToolPanel *ToolPanelCoordinator::getFoldableToolPanel(Tool tool) const
 {
     switch (tool) {
diff --git a/rtgui/toolpanelcoord.h b/rtgui/toolpanelcoord.h
index 7542343eb..b7e1d104e 100644
--- a/rtgui/toolpanelcoord.h
+++ b/rtgui/toolpanelcoord.h
@@ -458,6 +458,8 @@ public:
 
     void setEditProvider(EditDataProvider *provider);
 
+    void setProgressListener(rtengine::ProgressListener *pl);
+
 protected:
     static std::unordered_map<std::string, Tool> toolNamesReverseMap;
 
diff --git a/tools/generateRtexifUpdates b/tools/generateRtexifUpdates
deleted file mode 100755
index b4ace209d..000000000
--- a/tools/generateRtexifUpdates
+++ /dev/null
@@ -1,155 +0,0 @@
-#!/usr/bin/env bash
-
-# This Bash4 script generates lens ID and other parameter lists for rtexif/*.cc
-# using ExifTool. It uses xmlstarlet to parse ExifTool's output.
-#
-# Run the script from the project root:
-#   ./tools/generateRtexifUpdates
-#
-# Manually replace old code in rtexif/* with new from /tmp/rt-generateRtexifUpdates/*
-#
-# Blame DrSlony
-# Please report bugs or enhancements to https://github.com/Beep6581/RawTherapee
-
-et="$HOME/programs/code-exiftool/exiftool"
-
-hash "$et" 2>/dev/null || { echo >&2 "ExifTool not found, install it first."; exit 1; }
-hash xmlstarlet 2>/dev/null || { echo >&2 "XMLStarlet not found, install it first."; exit 1; }
-
-unset cam cams
-
-tmpdir="/tmp/rt-generateRtexifUpdates"
-
-printf '%s\n' "ExifTool version: $("$et" -ver)" "" "XMLStarlet version: $(xmlstarlet --version)"  | sed 's/^/# /'
-
-if [[ -d ${tmpdir} ]]; then
-    printf '%s\n' "" "Must remove temp folder from previous run: $tmpdir"
-    rm -rvI "$tmpdir" || exit 1
-fi
-mkdir -p "$tmpdir" || { printf '%s\n' "Error creating $tmpdir" ""; exit 1; }
-echo
-
-#------------------------------------------------------------------------------
-# Canon
-printf '%s\n' "Saving ${tmpdir}/canon_lenses"
-xmlstarlet sel -T -t \
-    -m "taginfo/table/tag[@name='LensType']/values/key" \
-    -v "concat(@id,'	',val)" \
-    -n < <("$et" -listx -canon:all) | sort -fuV > "${tmpdir}/canon_lenses"
-
-#In :10.1    Sigma 50mm f/2.8 EX
-#Out:            {10, "Sigma 50mm f/2.8 EX"},
-# delete lines matching '-1<tab>n/a'
-# replace '10.1<tab>Sigma' with '10, "Sigma'
-# prepend whitespace
-# append closing braces
-# replace ' F/11' with ' f/11'
-sed -r -i \
-    -e '/-1\tn\/a/d' \
-    -e 's/([0-9]+)[0-9.]*\t/\1, "/' \
-    -e 's/^/            {/' \
-    -e 's/$/"},/' \
-    -e 's| F/([0-9]+)| f/\1|' \
-    "${tmpdir}/canon_lenses"
-
-#In :16842752        PowerShot A30
-#Out:        choices[16842752] = "PowerShot A30";
-# prepend whitespace and 'choices['
-# replace <tab> with '] = "'
-# append '";'
-printf '%s\n' "Saving ${tmpdir}/canon_cameras"
-xmlstarlet sel -T -t \
-    -m "taginfo/table/tag[@name='CanonModelID']/values/key" \
-    -v "concat(@id,'	',val)" \
-    -n < <("$et" -listx -canon:all) | sort -fuV > "${tmpdir}/canon_cameras"
-
-sed -r -i \
-    -e 's/^/        choices[/' \
-    -e 's/\t/] = "/' \
-    -e 's/$/";/' \
-    "${tmpdir}/canon_cameras"
-
-#------------------------------------------------------------------------------
-# Nikon LensIDs are composite tags
-printf '%s\n' "Saving ${tmpdir}/nikon"
-
-xmlstarlet sel -T -t \
-    -m "taginfo/table/tag[@name='LensID']/values/key" \
-    -v "concat(@id,'	',val)" \
-    -n < <("$et" -listx -composite:all) > "${tmpdir}/nikon"
-
-sed -r -i \
-    -e '/^...	/d' \
-    -e 's/^/    {"/' \
-    -e 's/([A-F0-9]+)[A-F0-9.]*\t/\1", "/' \
-    -e 's/$/"},/' \
-    -e 's|(.* ")(.*) F([0-9]+)|\1\2 f/\3|' \
-    -e 's| F/([0-9]+)| f/\1|' \
-    "${tmpdir}/nikon"
-
-#------------------------------------------------------------------------------
-# Olympus
-printf '%s\n' "Saving ${tmpdir}/olympus"
-
-xmlstarlet sel -T -t \
-    -m "taginfo/table/tag[@name='LensType']/values/key" \
-    -v "concat(@id,'	',val)" \
-    -n < <("$et" -listx -olympus:all) | sort -fuV > "${tmpdir}/olympus"
-
-sed -r -i \
-    -e '/0 00 00\tNone/d' \
-    -e 's/^/        lenses["0/' \
-    -e 's/\t/"] = "/' \
-    -e 's/$/";/' \
-    -e 's| F([0-9]+)| f/\1|g' \
-    "${tmpdir}/olympus"
-
-#------------------------------------------------------------------------------
-# Pentax
-printf '%s\n' "Saving ${tmpdir}/pentax"
-
-xmlstarlet sel -T -t \
-    -m "taginfo/table/tag[@name='LensType']/values/key" \
-    -v "concat(@id,'	',val)" \
-    -n < <("$et" -listx -pentax:all) | sort -fuV > "${tmpdir}/pentax"
-
-sed -r -i \
-    -e 's/^/        choices.insert (p_t (256 * /' \
-    -e 's/([0-9]+) ([0-9]+)([0-9.]*)/\1 + \2/' \
-    -e 's/\t/, "/' \
-    -e 's/$/"));/' \
-    -e 's| F([0-9]+)| f/\1|' \
-    "${tmpdir}/pentax"
-
-#------------------------------------------------------------------------------
-# Sony
-printf '%s\n' "Saving ${tmpdir}/sony"
-
-xmlstarlet sel -T -t \
-    -m "taginfo/table/tag[@name='LensType']/values/key" \
-    -v "concat(@id,'	',val)" \
-    -n < <("$et" -listx -sony:all) | sort -fuV > "${tmpdir}/sony"
-
-# Sony has more lenses under the LensType2 tag
-printf '%s\n' "Saving ${tmpdir}/sony-lenstype2"
-
-xmlstarlet sel -T -t \
-    -m "taginfo/table/tag[@name='LensType2']/values/key" \
-    -v "concat(@id,'	',val)" \
-    -n < <("$et" -listx -sony:all) | sort -fuV > "${tmpdir}/sony-lenstype2"
-
-sed -r -i \
-    -e 's/^/            {/' \
-    -e 's/([0-9]+)[0-9.]*\t/\1, "/' \
-    -e 's/$/"},/' \
-    -e 's| F([0-9]+)| f/\1|g' \
-    "${tmpdir}/sony"
-
-sed -r -i \
-    -e '/255\tTamron Lens (255)/d' \
-    -e 's/([0-9]+)[0-9.]*\t/\1, "/' \
-    -e 's/^/        choices.insert (p_t (/' \
-    -e 's/$/"));/' \
-    -e 's| F([0-9]+)| f/\1|g' \
-    "${tmpdir}/sony-lenstype2"
-
